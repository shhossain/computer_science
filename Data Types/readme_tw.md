# [資料型別](#資料型別)

在程式設計中，資料型別是一種分類，能指定變數具有哪種型別的值，以及可以對其進行哪種型別的數學、關係或邏輯操作而不會造成錯誤。

在電腦科學和程式設計中，「資料型別」是一組可能的值和一組允許的操作。資料型別會告訴編譯器或解釋器程式設計者打算如何使用資料。

---

## 主要資料型別

- [原始資料型別](#原始資料型別)
- [非原始資料型別](#非原始資料型別)

---

## [原始資料型別](#原始資料型別)

「原始資料型別 (Primitive data types)」是程式語言中最基本的資料型別，它們是那些更複雜資料型別的構成要素。原始資料型別由程式語言預先定義，並以保留字命名。

### 常見的原始資料型別

- [整數](#整數)
- [浮點數](#浮點數)
- [布林值](#布林值)
- [字元](#字元)
- [字串](#字串)

---

### [整數](#整數)

「整數 (Integer)」是可以是正、負或零的整數。在大多數程式語言中，整數是 32 位元的有符號整數，這表示它的值可以介於 -2,147,483,648 和 2,147,483,647 之間。而在某些程式語言中，整數可以是 64 位元，這表示它的值可以介於 -9,223,372,036,854,775,808 和 9,223,372,036,854,775,807 之間。



#### 範例:

##### **C, C++, C#, Java**

```c
// 將整數變數 'x' 初始化為 '5'。
int x = 5;
```

##### **Python**

```python
# 將整數變數 'x' 初始化為 '5'。
x = 5
```

##### **JavaScript**

```javascript
// 將整數變數 'x' 初始化為 '5'。
let x = 5;
```

---

### [浮點數](#浮點數)

「浮點數 (Float)」是可以有小數點的數字。在大多數程式語言中，float 是 32 位元的浮點數，也就是說它的值可以介於 1.175494351e-38 和 3.402823466e+38 之間。在某些程式語言中，浮點數可以是 64 位元，這表示它的值可以介於 2.2250738585072014e-308 和 1.7976931348623157e+308 之間。

#### 範例:

##### **C, C++**

```c
// 將浮點數變數 x 初始化為 5.5。
float x = 5.5;
```

##### **C#**

```c#
// 將浮點數變數 x 初始化為 5.5。
float x = 5.5D;
```

##### **Python**

```python
# 將浮點數變數 x 初始化為 5.5。
x = 5.5
```

##### **Java**

```java
// 將浮點數變數 x 初始化為 5.5。
float x = 5.5f;
```

##### **JavaScript**

```javascript
// 將浮點數變數 x 初始化為 5.5。
let x = 5.5;
```

---

### [布林值](#布林值)

「布林值 (Boolean)」是一種資料型別，只能是兩個值其中之一：true 或 false。

#### 範例:

##### **C, C++, C#**

```c
// 將布林變數 x 初始化為 true。
bool x = true;
```

##### **Python**

```python
# 將布林變數 x 初始化為 true。
x = True
```

##### **Java**

```java
// 將布林變數 x 初始化為 true。
boolean x = true;
```

##### **JavaScript**

```javascript
// 將布林變數 x 初始化為 true。
let x = true;
```

---


### [字元](#字元)

「字元 (Character)」是單一字母、數字或符號。在大多數程式語言中，一個字元是一個 16 位元的無符號整數，這表示它的值可以介於 0 到 65,535 之間。

#### 範例:

##### **C, C++, C#, Java**

```c
// 將字元變數 x 初始化為 'a'。
char x = 'a';
```

##### **Python**

```python
# Python 沒有「字元」型別。所有單一字元在 Python 中都被視為長度為 1 的字串(String)。
x = "a"
```

##### **JavaScript**

```javascript
// 將字元變數 x 初始化為 'a'。
let x = "a";
```

---

### [字串](#字串)

「字串 (string)」是一連串的字元。在大多數程式語言中，字串是一組字元的陣列 (array)。

#### 範例:

##### **C**

```c
// 初始化字串變數 x，並賦值為 'Hello World!'。
char sayHello[] = "Hello World!";
```

##### **C++, C#**

```c++
// 初始化字串變數 x，並賦值為 'Hello World!'。
string sayHello = "Hello World!";
```

##### **Python**

```python
# 初始化字串變數 x，並賦值為 'Hello World!'。
say_hello = "Hello World!"
```

##### **Java**

```java
// 初始化字串變數 x，並賦值為 'Hello World!'。
String sayHello = "Hello World!";
```

##### **JavaScript**

```javascript
// 初始化字串變數 x，並賦值為 'Hello World!'。
let x = "Hello World!";
```

---


## [非原始資料型別](#非原始資料型別)

「非原始資料型別 (Non-primitive data types)」又稱為「參考資料型別」。它們由程式設計者創建，並非由程式語言定義。非原始資料型別也稱為「複合資料型別」，因為它們是由其他型別組成的。

### 常見的非原始資料型別

- [陣列](#陣列)
- [結構](#結構)
- [聯集](#聯集)
- [指標](#指標)
- [函式](#函式)
- [類別](#類別)
- [串列](#串列)
- [映射/字典](#映射字典)
- [集合](#集合)
- [配對/元組](#配對元組)

---

### [陣列](#陣列)

「陣列 (Array)」是一組存放在連續記憶體位置的項目集合。其概念是將多個相同型別的項目一起存放。這使得計算每個元素的位置變得更簡單，只需將偏移量加到基準值上，即陣列第一個元素的記憶體位置（通常以陣列名稱表示）。


#### 範例:

##### **C, C++**

```c
// 初始化一個可以存放整數值的陣列 x 。
int x[] = {5, 10, 15, 20, 25};
```

##### **C#**

```c#
// 初始化一個可以存放整數值的陣列 x 。
int[] x = {5, 10, 15, 20, 25};
```

##### **Java**

```java
// 初始化一個可以存放整數值的陣列 x 。
int[] x = {5, 10, 15, 20, 25};
```

##### **JavaScript**

```javascript
// 初始化一個可以存放整數值的陣列 x 。
const x = [5, 10, 15, 20, 25];
```

---

### [結構](#結構)

「結構 (Struct)」是一組不同資料型別的變數集合，統一在一個名稱之下。它用來結合不同種類的資料項目。

#### 範例:

##### **C, C++**

```c
// 建立一個包含三個變數的結構。
struct Person {
    char name[50];
    int age;
    float salary;
};
```

##### **C#**

```c#
// 建立一個包含三個變數的結構。
struct Person
{
    public string name;
    public int age;
    public float salary;
}
```

---


### [聯集](#聯集)

「聯集 (Union)」是 C 語言中一種特殊的資料型別，允許在相同的記憶體位置存放不同的資料型別。你可以定義一個包含多個成員的聯集，但在任何特定時間內，只有一個成員可以存有值。聯集提供了一種有效利用相同記憶體位置來達成多重用途的方法。

#### 範例:

##### **C**

```c
// 建立一個聯集
union Data {
    int i;
    float f;
    char str[20];
};
```

---

### [指標](#指標)

「指標 (Pointer)」是一種變數，其值為另一個變數的位址，也就是記憶體的直接位置。像任何變數或常數一樣，必須先宣告指標，才能用來儲存任何變數的位址。指標變數宣告的一般形式為：

```c
type *var-name;
```

在這裡，type 是指標的基礎型別；它必須是有效的 C 資料型別，而 var-name 是指標變數的名稱。用來宣告指標的星號 \* 與用於乘法的星號相同。然而在此語句中，星號用來指定變數為指標。範例：

```c
int *ip; // ip 是一個指向整數的指標。
```

---


### [函式](#函式)

「函式 (Function)」是一組共同執行特定任務的敘述。每個 C 程式至少有一個函式，也就是 main()，而所有最簡單的程式都可以定義額外的函式。C 標準函式庫提供了許多內建函式，您的程式可以呼叫它們。

#### 範例:

##### **C, C++**

```c
// 使用以下格式創建自訂的函式：
void functionName() {
    // 要執行的程式碼
}
```

##### **C#, Java**

```c#
// 在 C# 和 Java 中，函式也稱為方法，定義如下：
static void functionName()
{
    // 要執行的程式碼
}
```

##### **Python**

```python
# 在 Python 中定義一個函式
def function_name():
    # 要執行的程式碼
```

##### **JavaScript**

```javascript
// 在 JavaScript 中定義一個函式
function functionName() {
  // 要執行的程式碼
}
```

---


### [類別](#類別)

「類別 (Class)」是一種使用者定義的資料型別，包含其自身的資料成員和成員函式，透過建立該類別的實例即可存取和使用。類別就像是物件的藍圖。

#### 範例:

##### **C++**

```c++
class Person {
    public:
        string name;
        int age;
        float salary;
};
```

##### **C#**

```c#
class Car
{
    string brand;
    string color;

}
```

##### **Python**

```python
class Country:
    name = "United States"
    capital = "Washington"
```

##### **Java**

```java
public class Candidate {
    String name;
    int age;
};
```

##### **JavaScript**

```javascript
class Boat {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }
}
```

---


### [串列](#串列)

「串列 (List)」被指定為有序物件的集合。列表類似於陣列，但列表的大小可以根據需要增長或縮小。列表也被稱為動態陣列。

#### 範例:

##### **Python**

```python
x = [1, 2, 3]
```

---


### [映射/字典](#mapdictionary)

「映射 (Map)」是一種資料結構，用於快速存取元素。每個元素以鍵值對（key-value pair）的形式儲存。映射中不能包含重複的鍵，每個鍵最多只能對應一個值。

#### 範例:

##### **Python**

```python
x = {"name": "John", "age": 30}
```

##### **C++**

```c++
#include <map>
map<string, int> x = {{"name", "John"}, {"age", 30}};
```

---


### [集合](#集合)

「集合 (Set)」是指一組元素，其中沒有重複的元素。集合是無序的，這表示元素加入集合的順序並不重要。集合也被稱為無序列表。

#### 範例:

##### **Python**

```python
x = {"apple", "banana", "cherry"}
```

##### **C++**

```c++
#include <set>
set<string> x = {"apple", "banana", "cherry"};
```

---


### [配對/元組](#配對/元組)

「配對 (Pair)」是一種容器，用來一起儲存兩個值。「元組 (Tuple)」是一種容器，用來一起儲存固定數量的值。這些值可以是不同型別的。

#### 範例:

##### **Python**

```python
x = ("apple", "banana", "cherry")
```

##### **C++**

```c++
#include <tuple>
tuple<string, string, string> x = {"apple", "banana", "cherry"};
```

---


## 資料型別轉換

「資料型別轉換 (Data type conversion)」是將資料從一種型別轉換為另一種型別。在大多數情況下，資料型別轉換是由編譯器自動完成的。然而，有時你需要手動執行資料型別轉換以獲得預期的結果。

### 常見資料型別轉換
- [隱性轉換](#隱性轉換)
- [顯性轉換](#顯性轉換)

### [隱性轉換](#隱性轉換)

「隱性轉換(Implicit conversion)」是指資料從一種型別自動轉換為另一種型別。當編譯器偵測到需要進行轉換時，會自動執行此轉換。例如：當你將較小資料型別的值指派給較大資料型別的變數時，編譯器會自動將該值轉換為較大的資料型別。

範例：

```c
int x = 10; // x 是整數
float y = x; // y 是浮點數
```

```python
x = 10 # x 是整數
y = float(x) # y 是浮點數
```


### [顯性轉換](#顯性轉換)

「顯性轉換 (Explicit conversion)」是指由程式設計者主動將資料從一種型別轉換為另一種型別。這種轉換是使用型別轉換運算子來完成。例如：當你將一個較大資料型別的值指派給較小資料型別的變數時，編譯器不會自動將該值轉換為較小的資料型別。在這種情況下，你必須使用型別轉換運算子將該值轉換為較小的資料型別。


範例：

```c
float x = 10.5; // x 是浮點數
int y = (int)x; // y 是整數
```

```python
x = 10.5 # x 是浮點數
y = int(x) # y 是整數
```

## 注意事項

我們在進行顯性轉換時應該小心，例如：
- 將浮點數型別的值轉換為整數型別的值，這會導致小數部分的數值丟失。
- 將較大的資料型別轉換為較小的資料型別時，會導致資料丟失，因為數值會被截斷。

---

## 有號與無號的概念（符號型別）
在 C 以及 C++、Java 等許多其他程式語言中，「有號」與「無號」的概念用來指定整數型別資料（例如：int、short、long 等）在數值表示上的解讀方式。這些概念決定資料是否能同時表示正負值（有號），或僅能表示非負值（無號）。

### 常見的符號型別


- [有號型別](#有號型別)
- [無號型別](#無號型別)

### [有號型別](#有號型別)

「有號整數型別 (Signed type)」可以表示正值與負值。

最高有效位元（最左邊的位元， MSB）通常用來表示數值的符號：0 表示正數，1 表示負數（採用二補數表示法）。

例如：一個有符號的 8 位元整數可以表示的數值範圍是從 -128 到 127，因為最高有效位元被用來表示符號，剩下的 7 位元則用來表示數值本身。 在二補數表示法中，計算其可表示範圍的公式為：
-(2^(n-1)) 至 (2^(n-1)-1)，其中 n 是暫存器的位元數。

#### 範例:

##### **C**


```c
signed int a = -10;
```


### [無號型別](#無號型別)

「無號資料型別 (Unsigned type)」只能表示非負的數值，包括零。
在二進位表示中，所有位元都用來表示數值的大小，不包含符號位元。常見的無號資料型別包括：無號整數 (unsigned int) 、無號短整數 (unsigned short)、無號長整數 (unsigned long) 等。

例如：一個無號的 8 位元整數可以表示的數值範圍是 0 到 255，因為它不包含符號位元，因此全部 8 個位元都用來表示數值本身，這使得可表示的正數範圍比有號整數更大。
計算其可表示範圍的公式為： 0 至 ((2^n)−1) ，其中 n 是暫存器的位元數。

#### 範例:

##### **C**

```c
unsigned int unsignedValue = 42; 
```

### 有號 V/s 無號

### 有號整數型別的優點:

負值的表示能力：有號整數可以表示正值與負值，因此適用於需要處理包含負數的廣泛數值範圍的情境。

算術運算：在執行可能產生負值的算術運算時，有號整數有助於正確處理這些結果。

相容性高：有號整數在多數程式語言與函式庫中廣泛使用，能與各種軟體與系統高度相容。

### 無號整數型別的優點:

非負數值：無號整數只適用於處理非負數值的情境。當負值無意義或不適用時，例如陣列索引、大小、位元運算，使用無號整數是理想選擇。

更大的正值範圍：在相同位元數下，無號整數能表示的正整數範圍比有號整數更大。這對於需要儲存較大正值的應用場景非常有幫助。

位元運算：無號整數常用於位元運算中，因為此類操作不涉及數值的正負號。它們常用於操作個別位元或執行位元遮罩（bitmasking）等操作。

防止溢位錯誤：在某些情況下，使用無號整數有助於避免因數值過大而導致的溢位錯誤。當超過最大可表示值時，無號整數會回繞至零，降低錯誤風險。


## 資料型別大小

「資料型別大小 (Data type size)」是指儲存某個特定資料型別的值所需的記憶體空間。資料型別的大小取決於編譯器與電腦架構，因此在不同的電腦之間可能會有所差異。 此外，資料型別的大小也可能因編譯器或作業系統的不同而有所變化。

### 資料型別大小的比較（以 64 位元系統、x86-64 架構為基準）

- 字元：1 位元組（byte）
- 布林值：1 位元組
- 整數：4 位元組
- 短整數：2 位元組
- 長整數：8 位元組
- 浮點數：4 位元組
- 雙精度浮點數（Double）：8 位元組
- 長雙精度浮點數（Long Double）：16 位元組
