<h1 align="center">સામગ્રીનું કોષ્ટક</h1>
<h4 align="center">
    <p>
        <a href="https://github.com/shhossain/computer_science/blob/main/README.md">English</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_it.md">Italiano</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_es.md">Español</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_fr.md">Français</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_bn.md">বাংলা</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_ta.md">தமிழ்</a> |
        <b>ગુજરાતી</b> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_pt.md">Portuguese</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_ro.md">Română</a>
    </p>
</h4>

- [પરિચય](#પરિચય)
- [ઈલેક્ટ્રોનિક કોમ્પ્યુટર](#ઈલેક્ટ્રોનિક-કોમ્પ્યુટર)
- [બૂલિયન લોજિક](#બૂલિયન-લોજિક)
- [નંબર સિસ્ટમ્સ](#નંબર-સિસ્ટમ્સ)
- [સેન્ટ્રલ પ્રોસેસિંગ યુનિટ(CPU)](#central-processing-unit-cpu)
- [રજિસ્ટર્સ, કેશ અને રેમ](#registers-cache-and-ram)
- [સૂચનાઓ અને પ્રોગ્રામ](#સૂચનાઓ-અને-પ્રોગ્રામ)
- [પ્રોગ્રામિંગ ભાષાઓ](#પ્રોગ્રામિંગ-ભાષાઓ)
- [ડેટા પ્રકારો](#ડેટા-પ્રકારો)
- [વિધાન અને કાર્યો](#વિધાન-અને-કાર્યો)
- [ડેટા સ્ટ્રક્ચર્સ](#ડેટા-સ્ટ્રક્ચર્સ)
- [એલ્ગોરિધમ્સ](#એલ્ગોરિધમ્સ)
- [એલન ટ્યુરિંગ](#એલન-ટ્યુરિંગ)
- [સોફ્ટવેર એન્જિનિયરિંગ](#સોફ્ટવેર-એન્જિનિયરિંગ)
- [ઇન્ટિગ્રેટેડ સર્કિટ્સ](#ઇન્ટિગ્રેટેડ-સર્કિટ્સ)
- [ઑબ્જેક્ટ ઓરિએન્ટેડ પ્રોગ્રામિંગ](#ઑબ્જેક્ટ-ઓરિએન્ટેડ-પ્રોગ્રામિંગ)
- [ફંક્શનલ પ્રોગ્રામિંગ](#ફંક્શનલ-પ્રોગ્રામિંગ)
- [ઓપરેટિંગ સિસ્ટમ્સ](#ઓપરેટિંગ-સિસ્ટમ્સ)
- [મેમરી અને સ્ટોરેજ](#મેમરી-અને-સ્ટોરેજ)
- [ફાઇલ સિસ્ટમ](#ફાઇલ-સિસ્ટમ)
- [ક્લાઉડ કમ્પ્યુટિંગ](#ક્લાઉડ-કમ્પ્યુટિંગ)
- [મશીન લર્નિંગ](#મશીન-લર્નિંગ)
- [વેબ ટેકનોલોજી](#વેબ-ટેકનોલોજી)
- [નેટવર્કિંગ](#નેટવર્કિંગ)
- [ઇન્ટરનેટ](#ઇન્ટરનેટ)
- [DBMS(ડેટાબેઝ મેનેજમેન્ટ સિસ્ટમ)](#dbms)
- [ક્રિપ્ટોગ્રાફી](#ક્રિપ્ટોગ્રાફી)
- [ગણતરીનો સિદ્ધાંત](#ગણતરીનો-સિદ્ધાંત)

## પરિચય

કમ્પ્યુટર વિજ્ઞાન કમ્પ્યુટરો અને કમ્પ્યુટિંગ અને તેમની સિદ્ધાંતિક અને વ્યાવસાયિક અરજુન સિધ્ધાંતોનું અધ્યયન છે. કમ્પ્યુટર વિજ્ઞાન ગણિત, ઇન્જીનિયરીંગ, અને તર્કશાસ્ત્રનો તત્વોને મૂકે છે અને તેનો અનુયાય માટે વિવિધ સમસ્યાઓનું સમાધાન કરે છે. આમગ્યું માટે મુદ્દોનું અલ્ગોરિથમ રૂપરેખણ, સોફ્ટવેર/હાર્ડવેર વિકાસ, અને કૃત્રિમ બુદ્ધિમત્તા સહિત છે.

## [ઈલેક્ટ્રોનિક કોમ્પ્યુટર](Electronic%20Computer/readme.md)
એવું એક યંત્ર જે ગણના કરે છે, વિશેષત: એવું પ્રોગ્રામેબલ ઇલેક્ટ્રોનિક મશીન જે ઉચ્ચ ગતિવાળી ગણિતિક અથવા તાત્ત્વિક કાર્યો અથવા માહિતીનું સંમિલન, સંગ્રહણ, સંકરણ, અથવા અન્ય રીતે પ્રક્રિયા કરે છે.

## [બૂલિયન લોજિક](Boolean%20Logic/readme.md)
બુલિયન લોજિક એ એવું ગણિતનું શાખ્તિ છે જે સત્ય અને મિથ્યાની મૂલ્યો સાથે વાત કરે છે. આ એવી તર્કશાસ્ત્રનું સિસ્ટમ છે જે ફક્ત બે મૂલ્યો, 0 અને 1, નો ઉપયોગ કરે છે, જે મિથ્યા અને સત્યને પ્રતિનિધિત્વ આપે છે. આને બૂલિયન બીજાનું નામ પડે છે, જેનો આદિકાર જોર્જ બૂલે દ્વારા 1854 માં પહેલી વખત વર્ણન કર્યો છે.

### Common Boolean Operators
| Operator | Name |               Description               |
| :------: | :--: | :-------------------------------------: |
|    !     | NOT  |    Negates the value of the operand.    |
|    &&    | AND  | Returns **true** if both operands are true. |
|   \|\|   |  OR  | Returns **true** if one or all operands are true. |

### Nice to know Boolean Operators
| Operator | Name |               Description               |
| :------: | :--: | :-------------------------------------: |
|    ()    | Parentheses     |   Allows you to group keywords and control the order in which the terms will be searched.    |
|    “”    | Quotation marks | Provides results with the exact phrase. |
|   *      |  Asterisk       | Provides results containing a keyword variation. |
|   ⊕     |  XOR            | Returns **true** if the operands are different |
|   ⊽      |  NOR            | Returns **true** if all operands are false. |
|   ⊼      |  NAND           | Returns **false** only if both values of its two inputs are true.


## [નંબર સિસ્ટમ્સ](Number%20System/readme.md#number-systems)
આંકડા તંત્ર આંકડાઓનું વ્યક્ત કરવા માટેના ગણિત તંત્રો છે. એક આંકડા તંત્ર એ એવી ચિહ્નોનો સેટ સમાવે છે જે આંકડાઓને પ્રતિનિધિત્વ કરવામાં આવે છે અને તેમના ચિહ્નોને વપરાવવા માટેના નિયમોનો સેટ સમાવે છે. એક આંકડા તંત્રમાં વપરાયેલા ચિહ્નોને 'અંક' કહેવામાં આવે છે.

### [Types of Number Systems](Number%20System/readme.md#types-of-number-systems)
- [Positional Numeral System](Number%20System/readme.md#positional-numeral-system)
- [Sign-value Notation System](Number%20System/readme.md#sign-value-notation-system)

### [Common Positional Number Systems](Number%20System/readme.md#common-positional-number-systems)
- [Binary](Number%20System/readme.md#binary)
- [Octal](Number%20System/readme.md#octal)
- [Decimal](Number%20System/readme.md#decimal)
- [Hexadecimal](Number%20System/readme.md#hexadecimal)


### બાઈનરીનું મહત્વ
દ્વિસંગી એ બેઝ-2 નંબર સિસ્ટમ છે જેની શોધ ગોટફ્રાઈડ લીબનીઝ દ્વારા કરવામાં આવી છે જે ફક્ત બે સંખ્યાઓ અથવા અંકોથી બનેલી છે: 0 (શૂન્ય) અને 1 (એક). આ નંબરિંગ સિસ્ટમ એ તમામ બાઈનરી કોડ માટેનો આધાર છે, જેનો ઉપયોગ ડિજિટલ ડેટા લખવા માટે થાય છે જેમ કે કમ્પ્યુટર પ્રોસેસર સૂચનાઓ દરરોજ ઉપયોગમાં લેવાય છે. બાઈનરીમાં 0s અને 1s અનુક્રમે OFF અથવા ON દર્શાવે છે. ટ્રાન્ઝિસ્ટરમાં, "0" એ વીજળીના પ્રવાહને રજૂ કરે છે, અને "1" દર્શાવે છે કે વીજળીને વહેવાની મંજૂરી છે. આ રીતે, સંખ્યાઓને ભૌતિક રીતે કમ્પ્યુટિંગ ઉપકરણની અંદર રજૂ કરવામાં આવે છે, ગણતરીની પરવાનગી આપે છે.

 
દ્વિસંગી હજી પણ કમ્પ્યુટર્સ માટેની પ્રાથમિક ભાષા છે અને તેનો ઉપયોગ નીચેના કારણોસર ઇલેક્ટ્રોનિક્સ અને કમ્પ્યુટર હાર્ડવેર સાથે થાય છે:

- તે એક સરળ અને ભવ્ય ડિઝાઇન છે.
- બાઈનરીની 0 અને 1 પદ્ધતિ વિદ્યુત સિગ્નલની બંધ (ખોટી) અથવા ચાલુ (સાચી) સ્થિતિ શોધવા માટે ઝડપી છે.
- વિદ્યુત સિગ્નલમાં માત્ર બે અવસ્થાઓ દૂર રાખવાથી તે વિદ્યુત હસ્તક્ષેપ માટે ઓછી સંવેદનશીલ બને છે.
- ચુંબકીય માધ્યમોના સકારાત્મક અને નકારાત્મક ધ્રુવો ઝડપથી બાઈનરીમાં અનુવાદિત થાય છે.
- બાઈનરી એ લોજિક સર્કિટને નિયંત્રિત કરવાની સૌથી કાર્યક્ષમ રીત છે.



## [Central Processing Unit (CPU)](CPU/readme.md#central-processing-unitcpu)
A Central Processing Unit (CPU) is the most important part of any computer. The CPU sends signals to control the other parts of the computer, almost like how a brain controls a body. The CPU is an electronic machine that works on a list of computer things to do, called instructions. It reads the list of instructions and runs (executes) each one in order. A list of instructions that a CPU can run is a computer program. A CPU can process more than one instruction at a time on sections called "cores". A CPU with four cores may process four programs at once. The CPU itself is made of three main components. They are:
1. [Memory or storage Unit](CPU/readme.md#memory-or-storage-unit)
2. [Control Unit](CPU/readme.md#control-unit)
3. [Arithmetic and Logic unit (ALU)](CPU/readme.md#arithmetic-and-logic-unit-alu)


## [Registers, Cache and RAM](/Registers%20Cache%20and%20RAM)

### [નોંધણી કરો](/Registers%20Cache%20and%20RAM/readme.md#register)
રજિસ્ટર એ CPU ની અંદર સમાયેલ હાઇ-સ્પીડ મેમરીની નાની માત્રા છે. રજિસ્ટર એ "ફ્લિપ-ફ્લોપ્સ" (1 બીટ મેમરી સ્ટોર કરવા માટે વપરાતું સર્કિટ) નો સંગ્રહ છે. તેઓનો ઉપયોગ પ્રોસેસર દ્વારા પ્રક્રિયા દરમિયાન જરૂરી હોય તેવા નાના પ્રમાણમાં ડેટા સ્ટોર કરવા માટે થાય છે. CPU માં રજિસ્ટરના ઘણા સેટ હોઈ શકે છે જેને "કોર" કહેવામાં આવે છે. નોંધણી અંકગણિત અને તર્કશાસ્ત્રની કામગીરીમાં પણ મદદ કરે છે.

અંકગણિત કામગીરી એ રજિસ્ટરમાં સંગ્રહિત આંકડાકીય માહિતી પર CPU દ્વારા કરવામાં આવતી ગાણિતિક ગણતરીઓ છે. આ ક્રિયાઓમાં સરવાળો, બાદબાકી, ગુણાકાર અને ભાગાકારનો સમાવેશ થાય છે. લોજિક ઓપરેશન્સ એ રજિસ્ટરમાં સંગ્રહિત બાઈનરી ડેટા પર CPU દ્વારા કરવામાં આવતી બુલિયન ગણતરીઓ છે. આ કામગીરીમાં સરખામણીઓ (દા.ત. બે મૂલ્યો સમાન હોય તો પરીક્ષણ) અને તાર્કિક કામગીરી (દા.ત. AND, OR, NOT) નો સમાવેશ થાય છે.

આ કામગીરી કરવા માટે રજિસ્ટર આવશ્યક છે કારણ કે તેઓ CPU ને થોડી માત્રામાં ડેટાને ઝડપથી ઍક્સેસ કરવા અને તેની હેરફેર કરવાની મંજૂરી આપે છે. રજિસ્ટરમાં વારંવાર એક્સેસ કરાયેલ ડેટા સ્ટોર કરીને, CPU મેમરીમાંથી ડેટા પુનઃપ્રાપ્ત કરવાની ધીમી પ્રક્રિયાને ટાળી શકે છે.

કેશ ("રોકડ" તરીકે ઉચ્ચારવામાં આવે છે) માં મોટી માત્રામાં ડેટા સંગ્રહિત થઈ શકે છે, જે રજીસ્ટરની જેમ સમાન સંકલિત સર્કિટ પર સ્થિત ખૂબ જ ઝડપી મેમરી છે. કેશનો ઉપયોગ પ્રોગ્રામ ચાલે ત્યારે વારંવાર એક્સેસ કરવામાં આવતા ડેટા માટે થાય છે. RAM માં પણ મોટી માત્રામાં ડેટા સંગ્રહિત થઈ શકે છે. RAM એ રેન્ડમ-એક્સેસ મેમરી માટે વપરાય છે, જે મેમરીનો એક પ્રકાર છે જે ડેટા અને સૂચનાઓ ધરાવે છે જે પ્રોસેસરને તેની જરૂર પડે ત્યાં સુધી ડિસ્ક સ્ટોરેજમાંથી ખસેડવામાં આવી છે.

### [કેશ](/Registers%20Cache%20and%20RAM/readme.md#cache)
કેશ મેમરી એ ચિપ-આધારિત કમ્પ્યુટર ઘટક છે જે કમ્પ્યુટરની મેમરીમાંથી ડેટા પુનઃપ્રાપ્ત કરવાનું વધુ કાર્યક્ષમ બનાવે છે. તે અસ્થાયી સંગ્રહ વિસ્તાર તરીકે કાર્ય કરે છે જેથી કમ્પ્યુટરનું પ્રોસેસર સરળતાથી ડેટા પુનઃપ્રાપ્ત કરી શકે. આ કામચલાઉ સ્ટોરેજ એરિયા, કેશ તરીકે ઓળખાય છે, કમ્પ્યુટરના મુખ્ય મેમરી સ્ત્રોત કરતાં પ્રોસેસર માટે વધુ સરળતાથી ઉપલબ્ધ છે, સામાન્ય રીતે DRAM ના અમુક સ્વરૂપ.

કેશ મેમરીને કેટલીકવાર સીપીયુ (સેન્ટ્રલ પ્રોસેસિંગ યુનિટ) મેમરી કહેવામાં આવે છે કારણ કે તે સામાન્ય રીતે સીપીયુ ચિપમાં સીધી રીતે સંકલિત થાય છે અથવા સીપીયુ સાથે અલગ બસ ઇન્ટરકનેક્ટ ધરાવતી અલગ ચિપ પર મૂકવામાં આવે છે. તેથી, તે પ્રોસેસર માટે વધુ સુલભ છે અને કાર્યક્ષમતા વધારવા માટે સક્ષમ છે કારણ કે તે ભૌતિક રીતે પ્રોસેસરની નજીક છે.

પ્રોસેસરની નજીક રહેવા માટે, કેશ મેમરી મુખ્ય મેમરી કરતા ઘણી નાની હોવી જરૂરી છે. પરિણામે, તેમાં સ્ટોરેજ સ્પેસ ઓછી છે. તે મુખ્ય મેમરી કરતાં પણ વધુ ખર્ચાળ છે, કારણ કે તે વધુ જટિલ ચિપ છે જે ઉચ્ચ પ્રદર્શન આપે છે.

તે કદ અને કિંમતમાં શું બલિદાન આપે છે, તે ઝડપમાં બનાવે છે. કેશ મેમરી RAM કરતાં 10 થી 100 ગણી વધુ ઝડપથી કાર્ય કરે છે, જેને CPU વિનંતીનો જવાબ આપવા માટે માત્ર થોડા નેનોસેકન્ડની જરૂર પડે છે.

કેશ મેમરી માટે ઉપયોગમાં લેવાતા વાસ્તવિક હાર્ડવેરનું નામ હાઇ-સ્પીડ સ્ટેટિક રેન્ડમ એક્સેસ મેમરી (SRAM) છે. કમ્પ્યુટરની મુખ્ય મેમરીમાં ઉપયોગમાં લેવાતા હાર્ડવેરનું નામ ડાયનેમિક રેન્ડમ-એક્સેસ મેમરી (DRAM) છે.

કેશ મેમરીને વ્યાપક શબ્દ કેશ સાથે ભેળસેળ ન કરવી જોઈએ. કેશ એ અસ્થાયી ડેટા સ્ટોર્સ છે જે હાર્ડવેર અને સોફ્ટવેર બંનેમાં અસ્તિત્વમાં હોઈ શકે છે. કેશ મેમરી એ ચોક્કસ હાર્ડવેર ઘટકનો સંદર્ભ આપે છે જે કમ્પ્યુટરને નેટવર્કના વિવિધ સ્તરો પર કેશ બનાવવા માટે પરવાનગી આપે છે. કેશ એ હાર્ડવેર અથવા સોફ્ટવેર છે જેનો ઉપયોગ કમ્પ્યુટિંગ વાતાવરણમાં અસ્થાયી રૂપે, સામાન્ય રીતે ડેટાને સંગ્રહિત કરવા માટે થાય છે.

### [RAM](/Registers%20Cache%20and%20RAM/readme.md#ram)
રેમ (રેન્ડમ એક્સેસ મેમરી) એ કમ્પ્યુટર મેમરીનું એક સ્વરૂપ છે જે કોઈપણ ક્રમમાં વાંચી અને બદલી શકાય છે, સામાન્ય રીતે કાર્યકારી ડેટા અને મશીન કોડ સ્ટોર કરવા માટે વપરાય છે. રેન્ડમ એક્સેસ મેમરી ડિવાઇસ ડેટા આઇટમ્સને મંજૂરી આપે છે
અન્ય ડાયરેક્ટ-એક્સેસ ડેટા સ્ટોરેજ મીડિયા (જેમ કે હાર્ડ ડિસ્ક, CD-RWS,
DVD-RWs અને જૂની ચુંબકીય ટેપ અને ડ્રમ મેમરી), જ્યાં ડેટા આઇટમ્સ વાંચવા અને લખવા માટે જરૂરી સમય રેકોર્ડિંગ માધ્યમ પર તેમના ભૌતિક સ્થાનોના આધારે નોંધપાત્ર રીતે બદલાય છે, મીડિયા રોટેશન સ્પીડ અને હાથની હિલચાલ જેવી યાંત્રિક મર્યાદાઓને કારણે.


## [સૂચનાઓ અને પ્રોગ્રામ](ઉમેરાયેલ-નથી)
કોમ્પ્યુટર વિજ્ઞાનમાં, સૂચના એ પ્રોસેસર સૂચના સમૂહ દ્વારા વ્યાખ્યાયિત થયેલ પ્રોસેસરની એક કામગીરી છે. કમ્પ્યુટર પ્રોગ્રામ એ સૂચનાઓની સૂચિ છે જે કમ્પ્યુટરને શું કરવું તે જણાવે છે. કમ્પ્યુટર જે કરે છે તે બધું કમ્પ્યુટર પ્રોગ્રામનો ઉપયોગ કરીને પરિપૂર્ણ થાય છે. પ્રોગ્રામ કે જે કમ્પ્યુટરની મેમરીમાં સંગ્રહિત થાય છે ("આંતરિક પ્રોગ્રામિંગ") કમ્પ્યુટરને એક પછી એક કામ કરવા દે છે, વચ્ચે વિરામ હોવા છતાં.

## [પ્રોગ્રામિંગ ભાષાઓ](/Programming_Languages/readme.md)
પ્રોગ્રામિંગ લેંગ્વેજ એ નિયમોનો કોઈપણ સમૂહ છે જે સ્ટ્રીંગ્સ અથવા વિઝ્યુઅલ પ્રોગ્રામિંગ લેંગ્વેજના કિસ્સામાં ગ્રાફિકલ પ્રોગ્રામ તત્વોને વિવિધ પ્રકારના મશીન કોડ આઉટપુટમાં રૂપાંતરિત કરે છે. પ્રોગ્રામિંગ લેંગ્વેજ એ એક પ્રકારની કોમ્પ્યુટર લેંગ્વેજ છે જેનો ઉપયોગ એલ્ગોરિધમ્સના અમલીકરણ માટે કોમ્પ્યુટર પ્રોગ્રામિંગમાં થાય છે.

પ્રોગ્રામિંગ ભાષાઓને ઘણીવાર બે વ્યાપક શ્રેણીઓમાં વિભાજિત કરવામાં આવે છે:
1. ઉચ્ચ-સ્તરની ભાષા અંગ્રેજી ભાષાની જેમ જ વાક્યરચનાનો ઉપયોગ કરે છે. કમ્પાઈલર અથવા ઈન્ટરપ્રીટરનો ઉપયોગ કરીને સ્ત્રોત કોડને મશીન-સમજી શકાય તેવા મશીન કોડમાં રૂપાંતરિત કરવામાં આવે છે. જાવા અને પાયથોન ઉચ્ચ-સ્તરની પ્રોગ્રામિંગ ભાષાઓના કેટલાક ઉદાહરણો છે. આ સામાન્ય રીતે નિમ્ન-સ્તર કરતા ધીમા હોય છે, પરંતુ તે સરળ હોવા સાથે આવે છે.
2. નિમ્ન-સ્તરની પ્રોગ્રામિંગ ભાષાઓ હાર્ડવેર સાથે વધુ નજીકથી કામ કરે છે અને તેના પર વધુ નિયંત્રણ ધરાવે છે. તેઓ સીધા જ હાર્ડવેર સાથે સંપર્ક કરે છે. નિમ્ન-સ્તરની ભાષાઓના બે સામાન્ય ઉદાહરણો મશીન ભાષા અને એસેમ્બલી ભાષા છે. આ સામાન્ય રીતે ઉચ્ચ-સ્તર કરતાં વધુ ઝડપી હોય છે, પરંતુ તે ખૂબ જ મોટી મુશ્કેલી અને વાંચવાની ક્ષમતાના અભાવના ખર્ચે આવે છે.
### [પ્રોગ્રામિંગ દાખલાઓ](/Programming_Languages/readme.md#Programming+Paradigms)
ત્યાં પણ વિવિધ *પ્રોગ્રામિંગ દાખલાઓ* છે. પ્રોગ્રામિંગ દાખલાઓ એ વિવિધ રીતો અથવા શૈલીઓ છે જેમાં આપેલ પ્રોગ્રામ અથવા પ્રોગ્રામિંગ ભાષાને ગોઠવી શકાય છે. દરેક દાખલામાં અમુક રચનાઓ, વિશેષતાઓ અને સામાન્ય પ્રોગ્રામિંગ સમસ્યાઓને કેવી રીતે સંબોધિત કરવી જોઈએ તે અંગેના અભિપ્રાયોનો સમાવેશ થાય છે.

પ્રોગ્રામિંગ દાખલાઓ એ *નહી* ભાષાઓ અથવા ટૂલ્સ છે. તમે દાખલા સાથે કંઈપણ "બિલ્ડ" કરી શકતા નથી. તેઓ આદર્શો અને માર્ગદર્શિકાઓના સમૂહ જેવા છે કે જેના પર ઘણા લોકો સંમત થયા છે, અનુસર્યા છે અને વિસ્તૃત થયા છે. પ્રોગ્રામિંગ ભાષાઓ હંમેશા કોઈ ચોક્કસ દાખલા સાથે જોડાયેલી હોતી નથી. એવી *ભાષાઓ* છે કે જે ચોક્કસ નમૂનાને ધ્યાનમાં રાખીને બનાવવામાં આવી છે અને તેમાં એવા લક્ષણો છે જે અન્ય કરતાં તે પ્રકારના પ્રોગ્રામિંગને વધુ સુવિધા આપે છે (હેસ્કેલ અને ફંક્શનલ પ્રોગ્રામિંગ એક સારું ઉદાહરણ છે). પરંતુ ત્યાં "મલ્ટી-પેરાડાઈમ" ભાષાઓ પણ છે જેમાં તમે તમારા કોડને કોઈ ચોક્કસ પેરાડાઈમ અથવા અન્ય (જાવાસ્ક્રિપ્ટ અને પાયથોન સારા ઉદાહરણો છે) ફિટ કરવા માટે અનુકૂળ કરી શકો છો.


## [ડેટા પ્રકારો](Data%20Types/readme.md#data-types)
ડેટા પ્રકાર, પ્રોગ્રામિંગમાં, એક વર્ગીકરણ છે જે સ્પષ્ટ કરે છે કે વેરીએબલમાં કયા પ્રકારનું મૂલ્ય છે અને કયા પ્રકારની ગાણિતિક, સંબંધી અથવા તાર્કિક ક્રિયાઓ ભૂલ કર્યા વિના તેના પર લાગુ કરી શકાય છે.

### [આદિમ ડેટા પ્રકાર](Data%20Types/readme.md#primitive-data-types)
આદિમ ડેટા પ્રકારો પ્રોગ્રામિંગ ભાષામાં સૌથી મૂળભૂત ડેટા પ્રકારો છે. તેઓ વધુ જટિલ ડેટા પ્રકારોના બિલ્ડીંગ બ્લોક્સ છે. આદિમ ડેટા પ્રકારો પ્રોગ્રામિંગ ભાષા દ્વારા પૂર્વવ્યાખ્યાયિત છે અને આરક્ષિત કીવર્ડ દ્વારા નામ આપવામાં આવ્યું છે.

### [સામાન્ય આદિમ ડેટા પ્રકાર](Data%20Types/readme.md#common-primitive-data-types)
- [પૂર્ણાંક](ડેટા%20Types/readme.md#integer)
- [ફ્લોટ](ડેટા%20Types/readme.md#float)
- [બૂલિયન](ડેટા%20Types/readme.md#boolean)
- [અક્ષર](ડેટા%20Types/readme.md#character)
- [સ્ટ્રિંગ](ડેટા%20Types/readme.md#string)

### [બિન-આદિમ ડેટા પ્રકાર](Data%20Types/readme.md#non-primitive-data-types)
બિન-આદિમ ડેટા પ્રકારોને સંદર્ભ ડેટા પ્રકારો તરીકે પણ ઓળખવામાં આવે છે. તેઓ પ્રોગ્રામર દ્વારા બનાવવામાં આવ્યા છે અને પ્રોગ્રામિંગ ભાષા દ્વારા વ્યાખ્યાયિત નથી. બિન-આદિમ ડેટા પ્રકારોને સંયુક્ત ડેટા પ્રકારો પણ કહેવામાં આવે છે કારણ કે તે અન્ય પ્રકારોથી બનેલા છે.

### [સામાન્ય બિન-આદિમ ડેટા પ્રકાર](Data%20Types/readme.md#common-non-primitive-data-types)
- [એરે](Data%20Types/readme.md#array)
- [સ્ટ્રક્ચર](Data%20Types/readme.md#struct)
- [યુનિયન](Data%20Types/readme.md#union)
- [પોઇન્ટર](Data%20Types/readme.md#pointer)
- [ફંક્શન](Data%20Types/readme.md#function)
- [વર્ગ](Data%20Types/readme.md#class)

## [વિધાન અને કાર્યો](Statements%20and%20Functions/readme.md)
કમ્પ્યુટર પ્રોગ્રામિંગમાં, નિવેદન એ આવશ્યક પ્રોગ્રામિંગ ભાષાનું સિન્ટેક્ટિક એકમ છે જે હાથ ધરવા માટેની કેટલીક ક્રિયાઓને વ્યક્ત કરે છે. આવી ભાષામાં લખાયેલ પ્રોગ્રામ એક અથવા વધુ વિધાનોના ક્રમ દ્વારા રચાય છે. નિવેદનમાં આંતરિક ઘટકો હોઈ શકે છે (દા.ત., અભિવ્યક્તિઓ).
કોઈપણ પ્રોગ્રામિંગ ભાષામાં બે મુખ્ય પ્રકારનાં નિવેદનો છે જે કોડના તર્કને બનાવવા માટે જરૂરી છે.

1. [શરતી-નિવેદનો](Statements%20and%20Functions/readme.md#conditional-statements)

મુખ્યત્વે બે પ્રકારના શરતી નિવેદનો છે:
- જો
- જો બીજુ
- કેસ સ્વિચ કરો


2. [લૂપ્સ](Statements%20and%20Functions/readme.md#loops)

મુખ્યત્વે ત્રણ પ્રકારના શરતી નિવેદનો છે:
- લૂપ માટે
- જ્યારે લૂપ
- ડુ - જ્યારે લૂપ (વ્હાઈલ લૂપની વિવિધતા)
- do - લૂપ સુધી
------------

ફંક્શન એ નિવેદનોનો એક બ્લોક છે જે ચોક્કસ કાર્ય કરે છે. કાર્યો ડેટા સ્વીકારે છે, તેની પ્રક્રિયા કરે છે અને પરિણામ આપે છે અથવા તેને એક્ઝિક્યુટ કરે છે. વિધેયો મુખ્યત્વે પુનઃઉપયોગિતાના ખ્યાલને સમર્થન આપવા માટે લખવામાં આવે છે. એકવાર ફંક્શન લખાઈ ગયા પછી, તે જ કોડનું પુનરાવર્તન કર્યા વિના તેને સરળતાથી કૉલ કરી શકાય છે.

વિવિધ કાર્યાત્મક ભાષાઓ ફંક્શન લખવા માટે વિવિધ વાક્યરચનાનો ઉપયોગ કરે છે.

ફંક્શન્સ વિશે વધુ વાંચો [અહીં](Statements%20and%20Functions/readme.md#functions)


## [ડેટા સ્ટ્રક્ચર્સ](Data%20Structures/readme.md)
કોમ્પ્યુટર વિજ્ઞાનમાં, ડેટા સ્ટ્રક્ચર એ ડેટા ઓર્ગેનાઈઝેશન, મેનેજમેન્ટ અને સ્ટોરેજ ફોર્મેટ છે જે કાર્યક્ષમ ઍક્સેસ અને ફેરફારને સક્ષમ કરે છે. વધુ સ્પષ્ટ રીતે, ડેટા માળખું એ ડેટા મૂલ્યોનો સંગ્રહ, તેમની વચ્ચેના સંબંધો અને ડેટા પર લાગુ કરી શકાય તેવા કાર્યો અથવા કામગીરી છે.

### ડેટા સ્ટ્રક્ચરના પ્રકારો
- [એરે](Data%20Structures/readme.md#array)
- [લિંક કરેલ યાદી](Data%20Structures/readme.md#linkedlist)
- [સ્ટેક](Data%20Structures/readme.md#stack)
- [કતાર](Data%20Structures/readme.md#queue)
- [હેશ ટેબલ](Data%20Structures/readme.md#hashtable)
- [હીપ](Data%20Structures/readme.md#heap)
- [વૃક્ષ](Data%20Structures/readme.md#tree)
- [ગ્રાફ](Data%20Structures/readme.md#graph)

## [એલ્ગોરિધમ્સ](Algorithms/readme.md)
એલ્ગોરિધમ્સ એ ગણતરી પૂર્ણ કરવા માટે જરૂરી પગલાંઓનો સમૂહ છે. અમારા ઉપકરણો જે કરે છે તેના હૃદયમાં તેઓ છે અને આ કોઈ નવો ખ્યાલ નથી. ગણિતના જ વિકાસથી, કાર્યોને વધુ કાર્યક્ષમ રીતે પૂર્ણ કરવામાં અમને મદદ કરવા માટે અલ્ગોરિધમ્સની આવશ્યકતા હતી, પરંતુ આજે આપણે સોર્ટિંગ અને ગ્રાફ શોધ જેવી કેટલીક આધુનિક કમ્પ્યુટિંગ સમસ્યાઓ પર એક નજર નાખીશું અને બતાવીશું કે અમે તેમને કેવી રીતે વધુ બનાવ્યા છે. કાર્યક્ષમ જેથી તમે વધુ સરળતાથી સસ્તું હવાઈ ભાડું શોધી શકો અથવા વિન્ટરફેલ અથવા રેસ્ટોરન્ટ અથવા કંઈક માટે દિશા નિર્દેશો શોધી શકો.

### [સમય જટિલતા](Algorithms/Time%20Complexity/readme.md)
અલ્ગોરિધમના સમયની જટિલતા અંદાજે છે કે અલ્ગોરિધમ કેટલાંક ઇનપુટ માટે કેટલો સમય વાપરે છે. આ વિચાર કાર્યક્ષમતાને એક કાર્ય તરીકે રજૂ કરવાનો છે જેનું પરિમાણ ઇનપુટ કદ છે. સમયની જટિલતાની ગણતરી કરીને, અમે નક્કી કરી શકીએ છીએ કે અલ્ગોરિધમનો અમલ કર્યા વિના તે પર્યાપ્ત ઝડપી છે કે કેમ.

### [સ્પેસ જટિલતા](Algorithms/Space%20Complexity/readme.md)
સ્પેસ જટિલતા એ એક્ઝેક્યુશન માટે ઇનપુટ મૂલ્યોની જગ્યા સહિત અલ્ગોરિધમ/પ્રોગ્રામ વાપરેલ મેમરી સ્પેસની કુલ રકમનો સંદર્ભ આપે છે. અવકાશ જટિલતા નક્કી કરવા માટે અલ્ગોરિધમ/પ્રોગ્રામમાં ચલ દ્વારા કબજે કરેલી જગ્યાની ગણતરી કરો.

### [સૉર્ટિંગ](Algorithms/Sorting/readme.md)
સૉર્ટિંગ એ વસ્તુઓની સૂચિને ચોક્કસ ક્રમમાં ગોઠવવાની પ્રક્રિયા છે. ઉદાહરણ તરીકે, જો તમારી પાસે નામોની સૂચિ હોય, તો તમે તેને મૂળાક્ષરો પ્રમાણે સૉર્ટ કરી શકો છો. વૈકલ્પિક રીતે, જો તમારી પાસે સંખ્યાઓની સૂચિ હોય, તો તમે તેને નાનાથી મોટામાં ક્રમમાં મૂકવા માગી શકો છો. સૉર્ટિંગ એ એક સામાન્ય કાર્ય છે, અને તે એક છે જે આપણે ઘણી જુદી જુદી રીતે કરી શકીએ છીએ.

### [શોધ](Algorithms/Searching/readme.md)
શોધ એ કન્ટેનરની અંદર ચોક્કસ લક્ષ્ય તત્વ શોધવા માટેનું અલ્ગોરિધમ છે. સર્ચિંગ એલ્ગોરિધમ્સ એ એલિમેન્ટની તપાસ કરવા અથવા કોઈ પણ ડેટા સ્ટ્રક્ચરમાંથી એલિમેન્ટને પુનઃપ્રાપ્ત કરવા માટે રચાયેલ છે જ્યાં તે સંગ્રહિત છે.

### [ગ્રાફ શોધ](Algorithms/Graph/readme.md)
ગ્રાફ શોધ એ ચોક્કસ નોડ શોધવા માટે ગ્રાફ દ્વારા શોધવાની પ્રક્રિયા છે. આલેખ એ એક ડેટા માળખું છે જેમાં શિરોબિંદુઓ અથવા ગાંઠો અથવા બિંદુઓના મર્યાદિત (અને સંભવતઃ પરિવર્તનશીલ) સમૂહનો સમાવેશ થાય છે, સાથે સાથે આ શિરોબિંદુઓના અક્રમાંકિત જોડીના સમૂહ સાથે બિન-નિર્દેશિત ગ્રાફ અથવા નિર્દેશિત ગ્રાફ માટે ક્રમાંકિત જોડીના સમૂહનો સમાવેશ થાય છે. આ જોડીને દિશાહીન ગ્રાફ માટે કિનારીઓ, ચાપ અથવા રેખાઓ તરીકે ઓળખવામાં આવે છે અને નિર્દેશિત ગ્રાફ માટે તીર, નિર્દેશિત ધાર, નિર્દેશિત ચાપ અથવા નિર્દેશિત રેખાઓ તરીકે ઓળખાય છે. શિરોબિંદુઓ ગ્રાફ સ્ટ્રક્ચરનો ભાગ હોઈ શકે છે અથવા પૂર્ણાંક સૂચકાંકો અથવા સંદર્ભો દ્વારા રજૂ કરાયેલ બાહ્ય એન્ટિટી હોઈ શકે છે. વાસ્તવિક દુનિયાની ઘણી એપ્લિકેશનો માટે આલેખ સૌથી ઉપયોગી ડેટા સ્ટ્રક્ચર્સમાંનું એક છે. આલેખનો ઉપયોગ વસ્તુઓ વચ્ચેના જોડીના સંબંધોને મોડેલ કરવા માટે થાય છે. ઉદાહરણ તરીકે, એરલાઇન રૂટ નેટવર્ક એ એક ગ્રાફ છે જેમાં શહેરો શિરોબિંદુઓ છે, અને ફ્લાઇટ રૂટ એજ છે. આલેખનો ઉપયોગ નેટવર્કનું પ્રતિનિધિત્વ કરવા માટે પણ થાય છે. ઈન્ટરનેટને એક ગ્રાફ તરીકે મોડેલ કરી શકાય છે જેમાં કોમ્પ્યુટર્સ શિરોબિંદુઓ છે, અને કમ્પ્યુટર્સ વચ્ચેની લિંક્સ કિનારીઓ છે. LinkedIn અને Facebook જેવા સોશિયલ નેટવર્ક પર પણ ગ્રાફનો ઉપયોગ થાય છે. આલેખનો ઉપયોગ વાસ્તવિક દુનિયાના ઘણા કાર્યક્રમોને રજૂ કરવા માટે થાય છે: કોમ્પ્યુટર નેટવર્ક, સર્કિટ ડિઝાઇન અને એરોનોટિકલ શેડ્યુલિંગ માત્ર થોડા જ નામ માટે.



### [ડાયનેમિક પ્રોગ્રામિંગ](Algorithms/Dynamic%20Programming/README.md)
ડાયનેમિક પ્રોગ્રામિંગ એ ગાણિતિક ઑપ્ટિમાઇઝેશન પદ્ધતિ અને કમ્પ્યુટર પ્રોગ્રામિંગ પદ્ધતિ બંને છે. રિચાર્ડ બેલમેને 1950ના દાયકામાં આ પદ્ધતિ વિકસાવી હતી અને એરોસ્પેસ એન્જિનિયરિંગથી લઈને અર્થશાસ્ત્ર સુધીના અસંખ્ય ક્ષેત્રોમાં એપ્લિકેશન મળી છે. બંને સંદર્ભોમાં, તે એક જટિલ સમસ્યાને સરળ પેટા-સમસ્યાઓમાં વિભાજીત કરીને પુનરાવર્તિત રીતે સરળ બનાવવાનો ઉલ્લેખ કરે છે. જ્યારે કેટલીક નિર્ણય સમસ્યાઓને આ રીતે અલગ કરી શકાતી નથી, ત્યારે નિર્ણયો કે જે સમયના કેટલાક બિંદુઓ સુધી વિસ્તરે છે તે વારંવાર વારંવાર તૂટી જાય છે. તેવી જ રીતે, કોમ્પ્યુટર સાયન્સમાં, જો કોઈ સમસ્યાને પેટા-સમસ્યાઓમાં વિભાજિત કરીને અને પછી પેટા-સમસ્યાઓના શ્રેષ્ઠ ઉકેલો વારંવાર શોધીને શ્રેષ્ઠ રીતે ઉકેલી શકાય, તો તેને શ્રેષ્ઠ સબસ્ટ્રક્ચર કહેવાય છે. ડાયનેમિક પ્રોગ્રામિંગ આ પ્રોપર્ટીઝ સાથેની સમસ્યાઓને ઉકેલવાનો એક રસ્તો છે. જટિલ સમસ્યાને સરળ પેટા-સમસ્યાઓમાં વિભાજીત કરવાની પ્રક્રિયાને "વિભાજિત કરો અને જીતી લો" કહેવામાં આવે છે.


### [લોભી અલ્ગોરિધમ્સ](Algorithms/Greedy%20Algorithm/readme.md)
લોભી અલ્ગોરિધમ્સ એ અલ્ગોરિધમનો એક સરળ, સાહજિક વર્ગ છે જેનો ઉપયોગ કેટલીક ઑપ્ટિમાઇઝેશન સમસ્યાઓના શ્રેષ્ઠ ઉકેલ શોધવા માટે થઈ શકે છે. તેમને લોભી કહેવામાં આવે છે કારણ કે, દરેક પગલા પર, તેઓ તે ક્ષણે શ્રેષ્ઠ લાગે તેવી પસંદગી કરે છે. આનો અર્થ એ છે કે લોભી અલ્ગોરિધમ્સ વૈશ્વિક સ્તરે શ્રેષ્ઠ ઉકેલ પરત કરવાની બાંયધરી આપતા નથી પરંતુ તેના બદલે વૈશ્વિક શ્રેષ્ઠતમ શોધવાની આશામાં સ્થાનિક રીતે શ્રેષ્ઠ પસંદગીઓ કરે છે. લોભી અલ્ગોરિધમનો ઉપયોગ ઓપ્ટિમાઇઝેશન સમસ્યાઓ માટે થાય છે. જો સમસ્યામાં નીચેની મિલકત હોય તો લોભીનો ઉપયોગ કરીને ઑપ્ટિમાઇઝેશન સમસ્યા હલ કરી શકાય છે: દરેક પગલા પર, અમે આ ક્ષણે શ્રેષ્ઠ લાગે તેવી પસંદગી કરી શકીએ છીએ, અને અમને સંપૂર્ણ સમસ્યાનો શ્રેષ્ઠ ઉકેલ મળે છે.


### [બેકટ્રેકિંગ](Algorithms/Backtracking/README.md)
બેકટ્રેકિંગ એ સમસ્યાને વારંવાર ઉકેલવા માટેની અલ્ગોરિધમિક ટેકનિક છે, જે એક સમયે એક જ સમયે ઉકેલો બનાવવાનો પ્રયાસ કરીને, તે ઉકેલોને દૂર કરે છે જે કોઈપણ સમયે સમસ્યાના અવરોધોને સંતોષવામાં નિષ્ફળ જાય છે (સમય દ્વારા, અહીં, સંદર્ભિત કરવામાં આવે છે. શોધ વૃક્ષના કોઈપણ સ્તર સુધી પહોંચવામાં સમય વીતી ગયો).


### [શાખા અને બાઉન્ડ](Algorithms/Branch%20and%20Bound/README.md)
બ્રાન્ચ અને બાઉન્ડ એ કોમ્બીનેટર ઓપ્ટિમાઇઝેશન સમસ્યાઓ ઉકેલવા માટેની સામાન્ય તકનીક છે. તે એક વ્યવસ્થિત ગણતરીની ટેકનિક છે જે ઉમેદવારોના ઉકેલોને દૂર કરવા માટે સમસ્યાના બંધારણનો ઉપયોગ કરીને ઉમેદવારોના ઉકેલોની સંખ્યામાં ઘટાડો કરે છે જે સંભવતઃ શ્રેષ્ઠ ન હોઈ શકે.


### [વિવિધ શોધ અને વર્ગીકરણ અલ્ગોરિધમ્સની સમય જટિલતા અને અવકાશ જટિલતા](ઉમેરાયેલ-નથી)
**સમય જટિલતા**: તે કુલ લેવામાં આવેલા સમયને બદલે ચોક્કસ સૂચના સેટને કેટલી વખત અમલમાં મૂકવાની અપેક્ષા રાખવામાં આવે છે તે સંખ્યા તરીકે વ્યાખ્યાયિત કરવામાં આવે છે. સમય એક નિર્ભર ઘટના હોવાથી, સમયની જટિલતા કેટલાક બાહ્ય પરિબળો જેમ કે પ્રોસેસરની ઝડપ, વપરાયેલ કમ્પાઈલર વગેરે પર બદલાઈ શકે છે.

**સ્પેસ કોમ્પ્લેક્સિટી**: તે તેના અમલ માટે પ્રોગ્રામ દ્વારા વપરાશમાં લેવાયેલી કુલ મેમરી સ્પેસ છે.

બંનેની ગણતરી ઇનપુટ કદ(n) ના કાર્ય તરીકે કરવામાં આવે છે. અલ્ગોરિધમનો સમય જટિલતા મોટા O નોટેશનમાં દર્શાવવામાં આવે છે.

અલ્ગોરિધમની કાર્યક્ષમતા આ બે પરિમાણો પર આધારિત છે.

સમયની જટિલતાના પ્રકાર:

- *શ્રેષ્ઠ સમય જટિલતા*: ઇનપુટ કે જેના માટે અલ્ગોરિધમ ઓછો સમય અથવા ન્યૂનતમ સમય લે છે. શ્રેષ્ઠ કિસ્સામાં, અમે અલ્ગોરિધમના નીચલા બાઉન્ડ ટાઇમ જટિલતાની ગણતરી કરીએ છીએ. ઉદાહરણ તરીકે: જો શોધવાનો ડેટા રેખીય શોધમાં મોટા ડેટા એરેના પ્રથમ સ્થાન પર હાજર હોય, તો શ્રેષ્ઠ કેસ થાય છે.
- *સરેરાશ સમય જટિલતા*: અમે બધા રેન્ડમ ઇનપુટ્સ લઈએ છીએ અને તમામ ઇનપુટ્સ માટે ગણતરીના સમયની ગણતરી કરીએ છીએ. અને પછી, આપણે તેને ઇનપુટ્સની કુલ સંખ્યા વડે વિભાજીત કરીએ છીએ.
- *સૌથી ખરાબ સમયની જટિલતા*: ઇનપુટ વ્યાખ્યાયિત કરો જેના માટે અલ્ગોરિધમ લાંબો સમય અથવા મહત્તમ સમય લે છે. સૌથી ખરાબ કિસ્સામાં, અમે અલ્ગોરિધમના ઉપલા બાઉન્ડની ગણતરી કરીએ છીએ. ઉદાહરણ: જો શોધવાનો ડેટા રેખીય શોધ અલ્ગોરિધમમાં મોટા ડેટા એરેના છેલ્લા સ્થાન પર હાજર હોય, તો સૌથી ખરાબ કેસ થાય છે.

કેટલીક સામાન્ય સમયની જટિલતાઓ છે:

- **O(1)**: આ સતત સમય સૂચવે છે. O(1) નો સામાન્ય રીતે અર્થ એ થાય છે કે અલ્ગોરિધમનો ઇનપુટ કદને ધ્યાનમાં લીધા વિના સતત સમય હશે. હેશ નકશા એ સતત સમયના સંપૂર્ણ ઉદાહરણો છે.

- **O(લોગ એન)**: આ લઘુગણક સમય સૂચવે છે. O(log n) નો અર્થ એ છે કે ઓપરેશન્સ માટે દરેક ઇન્સ્ટન્સ સાથે ઘટાડો. દ્વિસંગી શોધ વૃક્ષો (BSTs) માં તત્વોની શોધ એ લઘુગણક સમયનું સારું ઉદાહરણ છે.

- **O(n): આ રેખીય સમય સૂચવે છે. O(n) નો અર્થ છે કે પ્રદર્શન ઇનપુટના કદના સીધા પ્રમાણસર છે. સરળ શબ્દોમાં કહીએ તો, ઇનપુટ્સની સંખ્યા અને તે ઇનપુટ્સને એક્ઝિક્યુટ કરવામાં લાગતો સમય પ્રમાણસર હશે. એરેમાં લીનિયર શોધ એ રેખીય સમય જટિલતાનું ઉત્તમ ઉદાહરણ છે.

- **O(n*n)**: આ ચતુર્ભુજ સમય સૂચવે છે. O(n^2) નો અર્થ છે કે પ્રદર્શન લેવામાં આવેલ ઇનપુટના ચોરસના સીધા પ્રમાણસર છે. સરળ રીતે, એક્ઝેક્યુશનમાં લાગતો સમય ઇનપુટ કદના ચોરસ ગણો લગભગ લેશે. નેસ્ટેડ લૂપ્સ ચતુર્ભુજ સમય જટિલતાના સંપૂર્ણ ઉદાહરણો છે.

- **O(n log n): આ બહુપદી સમયની જટિલતા દર્શાવે છે. O(n log n) નો અર્થ છે કે પ્રદર્શન O(log n) કરતા n ગણું છે, (જે સૌથી ખરાબ-કેસ જટિલતા છે). એક સારું ઉદાહરણ વિભાજિત કરવામાં આવશે અને મર્જ સૉર્ટ જેવા અલ્ગોરિધમ્સ પર વિજય મેળવશે. આ અલ્ગોરિધમ પહેલા સમૂહને વિભાજિત કરે છે, જે O(n log n) સમય લે છે, પછી જીતે છે અને સમૂહને સૉર્ટ કરે છે, જે O(n) સમય લે છે- તેથી, મર્જ સૉર્ટ O(n log n) સમય લે છે.

| Algorithm	     |             |  Time Complexity|	       | Space Complexity |
|   :---:        |  :---:      |  :---: 	   |   :---: 	   |   :---:          |
|  	             | Best	       | Average	   |  Worst	     |  Worst           |
| Selection Sort | Ω(n^2)	     | θ(n^2)	     | O(n^2)	     | O(1)             |
| Bubble Sort	 | Ω(n)	         | θ(n^2)	     | O(n^2)	     | O(1)             |
| Insertion Sort | Ω(n)	       | θ(n^2)	     | O(n^2)	     | O(1)             |
| Heap Sort	     | Ω(n log(n)) | θ(n log(n)) | O(n log(n)) | O(1)             |
| Quick Sort	   | Ω(n log(n)) | θ(n log(n)) | O(n^2)	     | O(n)             |
| Merge Sort	   | Ω(n log(n)) | θ(n log(n)) | O(n log(n)) | O(n)             |
| Bucket Sort    | Ω(n +k)	   | θ(n +k)	   | O(n^2)	     | O(n)             |
| Radix Sort  	 | Ω(nk)	     | θ(nk)	     | O(nk)	     | O(n + k)         |
| Count Sort  	 | Ω(n +k)	   | θ(n +k)	   | O(n +k)	   | O(k)             |
| Shell Sort  	 | Ω(n log(n)) | θ(n log(n)) | O(n^2)	     | O(1)             |
| Tim Sort	     | Ω(n)	       | θ(n log(n)) | O(n log(n)) | O(n)             |
| Tree Sort   	 | Ω(n log(n)) | θ(n log(n)) | O(n^2)	     | O(n)             |
| Cube Sort	     | Ω(n)	       | θ(n log(n)) | O(n log(n)) | O(n)             |

| Algorithm	     |             |  Time Complexity|	     |
|   :---:        |  :---:      |  :---: 	 |   :---: 	   |  
|  	             | Best	       | Average	 |  Worst	     |
| Linear Search  | O(1)	       | O(N)	     | O(N)	       | O(1)  |
| Binary Search	 | O(1)	       | O(logN)   | O(logN)	   |



## [એલન ટ્યુરિંગ](ઉમેરાયેલ-નથી)
એલન ટ્યુરિંગ (જન્મ જૂન 23, 1912, લંડન, એન્જી.—મૃત્યુ જૂન 7, 1954, વિલ્મસ્લો, ચેશાયર) એક અંગ્રેજી ગણિતશાસ્ત્રી અને તર્કશાસ્ત્રી હતા. તેમણે કેમ્બ્રિજ યુનિવર્સિટી અને પ્રિન્સટન ઇન્સ્ટિટ્યૂટ ફોર એડવાન્સ્ડ સ્ટડીમાં અભ્યાસ કર્યો. તેમના 1936ના સેમિનલ પેપર "ઓન કોમ્પ્યુટેબલ નંબર્સ" માં તેમણે સાબિત કર્યું કે ગણિતમાં સત્ય નક્કી કરવા માટેની કોઈ સાર્વત્રિક અલ્ગોરિધમિક પદ્ધતિ અસ્તિત્વમાં નથી અને ગણિતમાં હંમેશા અનિર્ણાયક (અજાણ્યાની વિરુદ્ધ) પ્રસ્તાવો હશે. તે કાગળે ટ્યુરિંગ મશીન પણ રજૂ કર્યું. તેઓ માનતા હતા કે કોમ્પ્યુટરો આખરે માનવીથી અસ્પષ્ટ વિચાર કરવા સક્ષમ હશે અને આ ક્ષમતાનું મૂલ્યાંકન કરવા માટે એક સરળ પરીક્ષણ (જુઓ ટ્યુરિંગ ટેસ્ટ) પ્રસ્તાવિત કર્યું. આ વિષય પરના તેમના પેપર્સ કૃત્રિમ બુદ્ધિમાં સંશોધનના પાયા તરીકે વ્યાપકપણે સ્વીકારવામાં આવે છે. તેમણે બીજા વિશ્વયુદ્ધ દરમિયાન ક્રિપ્ટોગ્રાફીમાં મૂલ્યવાન કાર્ય કર્યું, રેડિયો સંચાર માટે જર્મની દ્વારા ઉપયોગમાં લેવાતા એનિગ્મા કોડને તોડવામાં મહત્વની ભૂમિકા ભજવી. યુદ્ધ પછી, તેમણે યુનિવર્સિટી ઓફ માન્ચેસ્ટરમાં ભણાવ્યું અને હવે જે આર્ટિફિશિયલ ઈન્ટેલિજન્સ તરીકે ઓળખાય છે તેના પર કામ કરવાનું શરૂ કર્યું. આ ગ્રાઉન્ડબ્રેકિંગ કામની વચ્ચે, ટ્યુરિંગ તેના પથારીમાં સાયનાઇડ દ્વારા ઝેરી મૃત હાલતમાં મળી આવ્યા હતા. સમલૈંગિક કૃત્ય (ત્યારબાદ ગુનો) અને 12 મહિનાની હોર્મોન થેરાપીની સજા માટે તેની ધરપકડ બાદ તેનું મૃત્યુ થયું.


2009માં જાહેર ઝુંબેશ બાદ, બ્રિટિશ વડા પ્રધાન ગોર્ડન બ્રાઉને ટ્યુરિંગ સાથે જે રીતે ભયાનક વર્તન કર્યું હતું તેના માટે બ્રિટિશ સરકાર વતી સત્તાવાર જાહેર માફી માંગી હતી. રાણી એલિઝાબેથ II એ 2013 માં મરણોત્તર માફી આપી હતી. "એલન ટ્યુરિંગ કાયદો" શબ્દનો ઉપયોગ હવે યુનાઇટેડ કિંગડમમાં 2017 ના કાયદાનો સંદર્ભ આપવા માટે અનૌપચારિક રીતે કરવામાં આવે છે જે ઐતિહાસિક કાયદા હેઠળ સજાતીય અથવા સજા પામેલા પુરૂષોને પૂર્વવર્તી રીતે માફ કરે છે જે સમલૈંગિક કૃત્યોને ગેરકાયદેસર ઠેરવે છે.

ટ્યુરિંગ પાસે તેમની મૂર્તિઓ અને કમ્પ્યુટર વિજ્ઞાનની નવીનતાઓ માટે વાર્ષિક પુરસ્કાર સહિત તેમના નામની ઘણી વસ્તુઓનો વ્યાપક વારસો છે. તે વર્તમાન બેંક ઓફ ઈંગ્લેન્ડ £50 ની નોટ પર દેખાય છે, જે 23 જૂન, 2021 ના ​​રોજ તેના જન્મદિવસ સાથે એકરૂપ થવા માટે બહાર પાડવામાં આવી હતી. 2019 ની બીબીસી શ્રેણી, જેમ કે પ્રેક્ષકો દ્વારા મત આપવામાં આવ્યો, તેણે તેમને 20મી સદીના મહાન વ્યક્તિ તરીકે નામ આપ્યું.


## [સોફ્ટવેર એન્જિનિયરિંગ](Software%20Engineering/readme.md)
સોફ્ટવેર એન્જિનિયરિંગ એ કોમ્પ્યુટર સાયન્સની શાખા છે જે સોફ્ટવેર એપ્લીકેશનની ડિઝાઇન, વિકાસ, પરીક્ષણ અને જાળવણી સાથે કામ કરે છે. સોફ્ટવેર એન્જિનિયરો અંતિમ વપરાશકર્તાઓ માટે સોફ્ટવેર સોલ્યુશન્સ બનાવવા માટે એન્જિનિયરિંગ સિદ્ધાંતો અને પ્રોગ્રામિંગ ભાષાઓના જ્ઞાનને લાગુ કરે છે.
ચાલો સોફ્ટવેર એન્જિનિયરિંગની વિવિધ વ્યાખ્યાઓ જોઈએ:

- IEEE, તેના ધોરણ 610.12-1990માં, સૉફ્ટવેર એન્જિનિયરિંગને વ્યવસ્થિત, શિસ્તબદ્ધ એપ્લિકેશન તરીકે વ્યાખ્યાયિત કરે છે, જે સોફ્ટવેરના વિકાસ, સંચાલન અને જાળવણી માટે ગણતરી યોગ્ય અભિગમ છે.
- ફ્રિટ્ઝ બાઉરે તેને 'સ્થાપના તરીકે વ્યાખ્યાયિત કર્યું અને પ્રમાણભૂત એન્જિનિયરિંગ સિદ્ધાંતોનો ઉપયોગ કર્યો. તે તમને આર્થિક સૉફ્ટવેર મેળવવામાં મદદ કરે છે જે વિશ્વસનીય છે અને વાસ્તવિક મશીનો પર કાર્યક્ષમ રીતે કાર્ય કરે છે.
- બોહેમ સૉફ્ટવેર એન્જિનિયરિંગને 'કમ્પ્યુટર પ્રોગ્રામ્સની રચનાત્મક ડિઝાઇન અને નિર્માણ માટે વૈજ્ઞાનિક જ્ઞાનનો વ્યવહારિક ઉપયોગ' તરીકે વ્યાખ્યાયિત કરે છે. તેમાં તેમના વિકાસ, સંચાલન અને જાળવણી માટે જરૂરી સંકળાયેલ દસ્તાવેજોનો પણ સમાવેશ થાય છે.'

### સોફ્ટવેર એન્જિનિયરના કાર્યો અને જવાબદારીઓ
સફળ એન્જિનિયરો જાણે છે કે કોમ્પ્યુટર ગેમ્સથી લઈને નેટવર્ક કંટ્રોલ સિસ્ટમ્સ સુધીની દરેક વસ્તુને વિકસાવવા માટે યોગ્ય પ્રોગ્રામિંગ ભાષાઓ, પ્લેટફોર્મ્સ અને આર્કિટેક્ચરનો ઉપયોગ કેવી રીતે કરવો. તેમની સિસ્ટમ બનાવવા ઉપરાંત, સૉફ્ટવેર એન્જિનિયરો અન્ય એન્જિનિયરો દ્વારા બનાવવામાં આવેલ સૉફ્ટવેરનું પરીક્ષણ, સુધારણા અને જાળવણી પણ કરે છે.

આ ભૂમિકામાં, તમારા રોજિંદા કાર્યોમાં નીચેનાનો સમાવેશ થઈ શકે છે:

- સોફ્ટવેર સિસ્ટમ્સની ડિઝાઇન અને જાળવણી
- નવા સોફ્ટવેર પ્રોગ્રામ્સનું મૂલ્યાંકન અને પરીક્ષણ
- ઝડપ અને માપનીયતા માટે સૉફ્ટવેરને ઑપ્ટિમાઇઝ કરવું
- લેખન અને પરીક્ષણ કોડ
- ગ્રાહકો, ઇજનેરો, સુરક્ષા નિષ્ણાતો અને અન્ય હિસ્સેદારો સાથે પરામર્શ
- હિતધારકો અને આંતરિક ગ્રાહકોને નવી સુવિધાઓ રજૂ કરવી

### સોફ્ટવેર એન્જિનિયરિંગના તબક્કાઓ
સૉફ્ટવેર એન્જિનિયરિંગ પ્રક્રિયામાં જરૂરિયાતો એકત્ર કરવા, ડિઝાઇન, અમલીકરણ, પરીક્ષણ અને જાળવણી સહિત અનેક તબક્કાઓનો સમાવેશ થાય છે. સોફ્ટવેર ડેવલપમેન્ટ માટે શિસ્તબદ્ધ અભિગમને અનુસરીને, સોફ્ટવેર એન્જિનિયરો ઉચ્ચ ગુણવત્તાવાળા સોફ્ટવેર બનાવી શકે છે જે તેના વપરાશકર્તાઓની જરૂરિયાતોને પૂર્ણ કરે છે.

- સોફ્ટવેર એન્જિનિયરિંગનો પ્રથમ તબક્કો જરૂરીયાતો એકત્રીકરણ છે. આ તબક્કામાં, સોફ્ટવેર એન્જિનિયર ક્લાયન્ટ સાથે સોફ્ટવેરની કાર્યાત્મક અને બિન-કાર્યકારી જરૂરિયાતો નક્કી કરવા માટે કામ કરે છે. કાર્યાત્મક આવશ્યકતાઓ વર્ણવે છે કે સૉફ્ટવેરએ શું કરવું જોઈએ, જ્યારે બિન-કાર્યકારી આવશ્યકતાઓ વર્ણવે છે કે તે કેટલું સારું કરવું જોઈએ. જરૂરીયાતો ભેગી કરવી એ એક નિર્ણાયક તબક્કો છે, કારણ કે તે સમગ્ર સોફ્ટવેર વિકાસ પ્રક્રિયા માટે પાયો નાખે છે.

- જરૂરિયાતો એકત્ર થયા પછી, આગળનો તબક્કો ડિઝાઇન છે. આ તબક્કામાં, સોફ્ટવેર એન્જિનિયર સોફ્ટવેરના આર્કિટેક્ચર અને કાર્યક્ષમતા માટે વિગતવાર યોજના બનાવે છે. આ યોજનામાં સોફ્ટવેર ડિઝાઇન દસ્તાવેજનો સમાવેશ થાય છે જે સોફ્ટવેરની રચના, વર્તન અને અન્ય સિસ્ટમો સાથેની ક્રિયાપ્રતિક્રિયાઓને સ્પષ્ટ કરે છે. સોફ્ટવેર ડિઝાઇન દસ્તાવેજ આવશ્યક છે કારણ કે તે અમલીકરણના તબક્કા માટે બ્લુ પ્રિન્ટ તરીકે કામ કરે છે.

- અમલીકરણનો તબક્કો એ છે કે જ્યાં સોફ્ટવેર એન્જિનિયર સોફ્ટવેર માટે વાસ્તવિક કોડ બનાવે છે. આ તે છે જ્યાં ડિઝાઇન દસ્તાવેજ કાર્યકારી સોફ્ટવેરમાં રૂપાંતરિત થાય છે. અમલીકરણના તબક્કામાં કોડ લખવો, તેનું સંકલન કરવું અને તે ડિઝાઇન દસ્તાવેજમાં ઉલ્લેખિત આવશ્યકતાઓને પૂર્ણ કરે છે તેની ખાતરી કરવા માટે તેનું પરીક્ષણ કરવાનો સમાવેશ થાય છે.

- સોફ્ટવેર એન્જીનીયરીંગમાં ટેસ્ટીંગ એ એક નિર્ણાયક તબક્કો છે. આ તબક્કામાં, સોફ્ટવેર એન્જિનિયર એ ખાતરી કરવા માટે તપાસ કરે છે કે સોફ્ટવેર યોગ્ય રીતે કાર્ય કરે છે, વિશ્વસનીય છે અને ઉપયોગમાં સરળ છે. આમાં એકમ પરીક્ષણ, એકીકરણ પરીક્ષણ અને સિસ્ટમ પરીક્ષણ સહિત વિવિધ પ્રકારના પરીક્ષણનો સમાવેશ થાય છે. પરીક્ષણ સુનિશ્ચિત કરે છે કે સૉફ્ટવેર અપેક્ષા મુજબ જરૂરિયાતો અને કાર્યોને પૂર્ણ કરે છે.

- સોફ્ટવેર એન્જિનિયરિંગનો અંતિમ તબક્કો મેઇન્ટેનન્સનો છે. આ તબક્કામાં, સોફ્ટવેર એન્જિનિયર ભૂલો સુધારવા, નવી સુવિધાઓ ઉમેરવા અથવા તેના પ્રદર્શનને સુધારવા માટે સોફ્ટવેરમાં ફેરફાર કરે છે. જાળવણી એ એક ચાલુ પ્રક્રિયા છે જે સોફ્ટવેરના સમગ્ર જીવનકાળ દરમિયાન ચાલુ રહે છે.

### સોફ્ટવેર એન્જિનિયરિંગ શા માટે લોકપ્રિય છે?

- કોમ્પ્યુટર સાયન્સ: સોફ્ટવેર માટે વૈજ્ઞાનિક પાયો આપે છે કારણ કે ઇલેક્ટ્રિકલ એન્જિનિયરિંગ મુખ્યત્વે ભૌતિકશાસ્ત્ર પર આધારિત છે.
- મેનેજમેન્ટ સાયન્સ: સોફ્ટવેર એન્જિનિયરિંગ શ્રમ-સઘન છે અને તકનીકી અને વ્યવસ્થાપક નિયંત્રણની માંગ કરે છે. તેથી, તે મેનેજમેન્ટ વિજ્ઞાનમાં વ્યાપકપણે ઉપયોગમાં લેવાય છે.
- અર્થશાસ્ત્ર: આ ક્ષેત્રમાં, સોફ્ટવેર એન્જિનિયરિંગ તમને સંસાધનોનો અંદાજ કાઢવા અને ખર્ચને નિયંત્રિત કરવામાં મદદ કરે છે. એક કમ્પ્યુટિંગ સિસ્ટમ વિકસાવવી જોઈએ, અને આપેલ બજેટમાં ડેટા નિયમિતપણે જાળવવો જોઈએ.
- સિસ્ટમ એન્જિનિયરિંગ: મોટાભાગના સોફ્ટવેર એ ઘણી મોટી સિસ્ટમનો એક ઘટક છે. ઉદાહરણ તરીકે, ઇન્ડસ્ટ્રી મોનિટરિંગ સિસ્ટમમાંનું સોફ્ટવેર અથવા એરપ્લેન પર ફ્લાઇટ સોફ્ટવેર. આ પ્રકારની સિસ્ટમના અભ્યાસ માટે સૉફ્ટવેર એન્જિનિયરિંગ પદ્ધતિઓ લાગુ કરવી જોઈએ.


## [ઇન્ટિગ્રેટેડ સર્કિટ્સ](Integrated%20Circuits/readme.md)
ઇન્ટિગ્રેટેડ સર્કિટ અથવા મોનોલિથિક ઇન્ટિગ્રેટેડ સર્કિટ (જેને IC, એક ચિપ અથવા માઇક્રોચિપ તરીકે પણ ઓળખવામાં આવે છે) એ સેમિકન્ડક્ટર સામગ્રીના એક નાના સપાટ ટુકડા (અથવા "ચિપ") પર ઇલેક્ટ્રોનિક સર્કિટનો સમૂહ છે, સામાન્ય રીતે સિલિકોન. ઘણા નાના MOSFET (મેટલ-ઓક્સાઇડ-સેમિકન્ડક્ટર ફીલ્ડ-ઇફેક્ટ ટ્રાન્ઝિસ્ટર) નાની ચિપમાં એકીકૃત થાય છે. આ સર્કિટમાં પરિણમે છે જે અલગ ઇલેક્ટ્રોનિક ઘટકોથી બનેલા સર્કિટ કરતાં નાના, ઝડપી અને ઓછા ખર્ચાળ હોય છે. IC ની સામૂહિક ઉત્પાદન ક્ષમતા, વિશ્વસનીયતા અને એકીકૃત સર્કિટ ડિઝાઇન માટે બિલ્ડીંગ-બ્લોક અભિગમે અલગ ટ્રાન્ઝિસ્ટરની જગ્યાએ પ્રમાણિત આઇસીના ઝડપી દત્તકની ખાતરી કરી છે. IC હવે વર્ચ્યુઅલ રીતે તમામ ઇલેક્ટ્રોનિક સાધનોમાં ઉપયોગમાં લેવાય છે અને તેણે ઇલેક્ટ્રોનિક્સની દુનિયામાં ક્રાંતિ લાવી છે. કોમ્પ્યુટર, મોબાઈલ ફોન અને અન્ય હોમ એપ્લાયન્સિસ હવે આધુનિક સમાજના માળખાના અવિભાજ્ય ભાગો છે, જે આધુનિક કોમ્પ્યુટર પ્રોસેસર્સ અને માઇક્રોકન્ટ્રોલર જેવા IC ના નાના કદ અને ઓછી કિંમતના કારણે શક્ય બને છે.
મેટલ-ઓક્સાઇડ-સિલિકોન (એમઓએસ) સેમિકન્ડક્ટર ડિવાઇસ ફેબ્રિકેશનમાં તકનીકી પ્રગતિ દ્વારા ખૂબ મોટા પાયે એકીકરણ વ્યવહારુ બન્યું હતું. 1960 ના દાયકામાં તેમની ઉત્પત્તિ થઈ ત્યારથી, ચિપ્સનું કદ, ઝડપ અને ક્ષમતા ખૂબ જ આગળ વધી છે, જે તકનીકી પ્રગતિ દ્વારા સંચાલિત છે જે સમાન કદની ચિપ્સ પર વધુને વધુ MOS ટ્રાન્ઝિસ્ટર ફિટ કરે છે - આધુનિક ચિપમાં ઘણા અબજો MOS ટ્રાન્ઝિસ્ટર હોઈ શકે છે. માનવ આંગળીના નખનું ક્ષેત્રફળ. આ એડવાન્સિસ, લગભગ મૂરેના કાયદાને અનુસરીને, આજની કોમ્પ્યુટર ચિપ્સ 1970ના દાયકાની શરૂઆતની કોમ્પ્યુટર ચિપ્સ કરતા લાખો ગણી ક્ષમતા અને હજારો ગણી ઝડપ ધરાવે છે.

અલગ સર્કિટ્સ પર IC ના મુખ્ય બે ફાયદા છે: કિંમત અને કામગીરી. કિંમત ઓછી છે કારણ કે ચિપ્સ, તેમના તમામ ઘટકો સાથે, એક સમયે એક ટ્રાન્ઝિસ્ટર બનાવવાને બદલે ફોટોલિથોગ્રાફી દ્વારા એક એકમ તરીકે છાપવામાં આવે છે. વધુમાં, પેકેજ્ડ ICs અલગ સર્કિટ કરતાં ઘણી ઓછી સામગ્રીનો ઉપયોગ કરે છે. કામગીરી ઊંચી છે કારણ કે IC ના ઘટકો ઝડપથી સ્વિચ કરે છે અને તેમના નાના કદ અને નિકટતાને કારણે તુલનાત્મક રીતે ઓછી શક્તિ વાપરે છે. ICs નો મુખ્ય ગેરલાભ એ તેમને ડિઝાઇન કરવા અને જરૂરી ફોટોમાસ્ક બનાવવાની ઊંચી કિંમત છે. આ ઉચ્ચ પ્રારંભિક ખર્ચનો અર્થ એ છે કે જ્યારે ઉચ્ચ ઉત્પાદન વોલ્યુમની અપેક્ષા હોય ત્યારે જ IC વ્યાપારી રીતે સક્ષમ હોય છે.

### પ્રકારો
આધુનિક ઇલેક્ટ્રોનિક ઘટક વિતરકો ઘણીવાર સંકલિત સર્કિટને પેટા-વર્ગીકરણ કરે છે:

- ડિજિટલ IC ને લોજિક ICs (જેમ કે માઇક્રોપ્રોસેસર્સ અને માઇક્રોકન્ટ્રોલર્સ), મેમરી ચિપ્સ (જેમ કે MOS મેમરી અને ફ્લોટિંગ-ગેટ મેમરી), ઇન્ટરફેસ ICs (લેવલ શિફ્ટર્સ, સિરિયલાઇઝર/ડિસિરિયલાઇઝર, વગેરે), પાવર મેનેજમેન્ટ ICs અને પ્રોગ્રામેબલ તરીકે વર્ગીકૃત કરવામાં આવે છે. ઉપકરણો
- એનાલોગ IC ને રેખીય સંકલિત સર્કિટ અને RF સર્કિટ (રેડિયો ફ્રીક્વન્સી સર્કિટ) તરીકે વર્ગીકૃત કરવામાં આવે છે.
- મિશ્ર-સિગ્નલ ઇન્ટિગ્રેટેડ સર્કિટ્સને ડેટા એક્વિઝિશન ICs (A/D કન્વર્ટર, D/A કન્વર્ટર અને ડિજિટલ પોટેન્ટિઓમીટર), ઘડિયાળ/ટાઇમિંગ ICs, સ્વિચ્ડ કેપેસિટર (SC) સર્કિટ્સ અને RF CMOS સર્કિટ તરીકે વર્ગીકૃત કરવામાં આવે છે.
- ત્રિ-પરિમાણીય સંકલિત સર્કિટ (3D ICs) ને થ્રુ-સિલિકોન વાયા (TSV) ICs અને Cu-Cu કનેક્શન ICs માં વર્ગીકૃત કરવામાં આવે છે.

## [ઑબ્જેક્ટ ઓરિએન્ટેડ પ્રોગ્રામિંગ](Object%20Oriented%20Programming/readme.md)
ઑબ્જેક્ટ ઓરિએન્ટેડ પ્રોગ્રામિંગ એ મૂળભૂત પ્રોગ્રામિંગ પેરાડાઈમ છે જે ઑબ્જેક્ટ્સ અને ડેટાના ખ્યાલો પર આધારિત છે.

તે કોડની પ્રમાણભૂત રીત છે જે દરેક પ્રોગ્રામરે કોડની વધુ સારી વાંચનક્ષમતા અને પુનઃઉપયોગીતા માટે પાલન કરવું જોઈએ.

### * ઑબ્જેક્ટ ઓરિએન્ટેડ પ્રોગ્રામિંગના ચાર મૂળભૂત ખ્યાલો છે:
- એબ્સ્ટ્રેક્શન
- એન્કેપ્સ્યુલેશન
- વારસો
- પોલીમોર્ફિઝમ
OOP ના આ ખ્યાલો વિશે વધુ વાંચો [અહીં](Object%20Oriented%20Programming/readme.md)

## [ફંક્શનલ પ્રોગ્રામિંગ](Functional%20Programming/readme.md)

કોમ્પ્યુટર સાયન્સમાં, ફંક્શનલ પ્રોગ્રામિંગ એ પ્રોગ્રામિંગ પેરાડાઈમ છે જ્યાં ફંક્શન લાગુ કરીને અને કંપોઝ કરીને પ્રોગ્રામ્સ બનાવવામાં આવે છે. તે એક ઘોષણાત્મક પ્રોગ્રામિંગ પેરાડાઈમ છે જેમાં ફંક્શન વ્યાખ્યાઓ અભિવ્યક્તિના વૃક્ષો છે જે મૂલ્યોને અન્ય મૂલ્યો સાથે નકશા કરે છે, આવશ્યક નિવેદનોના ક્રમને બદલે જે પ્રોગ્રામની ચાલી રહેલ સ્થિતિને અપડેટ કરે છે.

ફંક્શનલ પ્રોગ્રામિંગમાં, ફંક્શન્સને પ્રથમ-વર્ગના નાગરિકો તરીકે ગણવામાં આવે છે, જેનો અર્થ છે કે તેઓ નામો (સ્થાનિક ઓળખકર્તાઓ સહિત), દલીલો તરીકે પસાર થઈ શકે છે અને અન્ય ફંક્શન્સમાંથી પરત આવી શકે છે, જેમ કે કોઈપણ અન્ય ડેટા પ્રકાર કરી શકે છે. આ પ્રોગ્રામ્સને ઘોષણાત્મક અને કંપોઝેબલ શૈલીમાં લખવાની મંજૂરી આપે છે, જ્યાં નાના કાર્યોને મોડ્યુલર રીતે જોડવામાં આવે છે.

ફંક્શનલ પ્રોગ્રામિંગને કેટલીકવાર શુદ્ધ વિધેયાત્મક પ્રોગ્રામિંગના સમાનાર્થી તરીકે ગણવામાં આવે છે, કાર્યાત્મક પ્રોગ્રામિંગનો સબસેટ જે તમામ કાર્યોને નિર્ધારિત ગાણિતિક કાર્યો અથવા શુદ્ધ કાર્યો તરીકે ગણે છે. જ્યારે અમુક આપેલ દલીલો સાથે શુદ્ધ કાર્યને બોલાવવામાં આવે છે, ત્યારે તે હંમેશા સમાન પરિણામ આપશે, અને કોઈપણ પરિવર્તનશીલ સ્થિતિ અથવા અન્ય આડઅસરોથી પ્રભાવિત થઈ શકશે નહીં. આ અશુદ્ધ પ્રક્રિયાઓથી વિપરીત છે, જે અનિવાર્ય પ્રોગ્રામિંગમાં સામાન્ય છે, જેની આડઅસર થઈ શકે છે (જેમ કે પ્રોગ્રામની સ્થિતિમાં ફેરફાર કરવો અથવા વપરાશકર્તા પાસેથી ઇનપુટ લેવા). સંપૂર્ણ રીતે કાર્યાત્મક પ્રોગ્રામિંગના સમર્થકો દાવો કરે છે કે આડ અસરોને પ્રતિબંધિત કરીને, પ્રોગ્રામ્સમાં ઓછી ભૂલો હોઈ શકે છે, ડિબગ અને પરીક્ષણ કરવામાં સરળ હોઈ શકે છે અને ઔપચારિક ચકાસણી પ્રક્રિયાઓ માટે વધુ અનુકૂળ હોઈ શકે છે.

ફંક્શનલ પ્રોગ્રામિંગના મૂળ એકેડેમિયામાં છે, જે લેમ્બડા કેલ્ક્યુલસમાંથી વિકસિત થાય છે, જે માત્ર ફંકશન પર આધારિત ગણતરીની ઔપચારિક સિસ્ટમ છે. કાર્યાત્મક પ્રોગ્રામિંગ ઐતિહાસિક રીતે અનિવાર્ય પ્રોગ્રામિંગ કરતાં ઓછું લોકપ્રિય રહ્યું છે, પરંતુ ઘણી કાર્યાત્મક ભાષાઓ આજે ઉદ્યોગ અને શિક્ષણમાં ઉપયોગ જોઈ રહી છે.

કાર્યાત્મક પ્રોગ્રામિંગ ભાષાઓના કેટલાક ઉદાહરણો છે:
- <a href="https://lisp-lang.org/"> સામાન્ય લિસ્પ </a>
- <a href="https://www.scheme.org/"> યોજના </a>
- <a href="https://racket-lang.org/"> રેકેટ </a>
- <a href="https://www.erlang.org/"> Erlang </a>
- <a href="https://www.haskell.org/"> હાસ્કેલ </a>
- <a href="https://fsharp.org/"> F# </a>
- <a href="https://cs.lmu.edu/~ray/notes/introml/"> ML </a>

કાર્યાત્મક પ્રોગ્રામિંગ ઐતિહાસિક રીતે *લેમ્બડા કેલ્ક્યુલસ* પરથી ઉતરી આવ્યું છે. લેમ્બડા કેલ્ક્યુલસ એ એલોન્ઝો ચર્ચ દ્વારા વિધેયો સાથેની ગણતરીઓનો અભ્યાસ કરવા માટે વિકસાવવામાં આવેલ માળખું છે. તેને ઘણીવાર "વિશ્વની સૌથી નાની પ્રોગ્રામિંગ ભાષા" કહેવામાં આવે છે. તે શું ગણતરીપાત્ર છે અને શું નથી તેની વ્યાખ્યા આપે છે. તે તેની કોમ્પ્યુટેશનલ ક્ષમતામાં ટ્યુરિંગ મશીનની સમકક્ષ છે અને લેમ્બડા કેલ્ક્યુલસ દ્વારા ગણતરી કરી શકાય તેવી કોઈપણ વસ્તુ, જેમ કે ટ્યુરિંગ મશીન દ્વારા ગણતરી કરી શકાય તેવી કોઈપણ વસ્તુ, ગણતરીપાત્ર છે. તે કાર્યો અને તેમના મૂલ્યાંકનનું વર્ણન કરવા માટે એક સૈદ્ધાંતિક માળખું પૂરું પાડે છે.

કાર્યાત્મક પ્રોગ્રામિંગના કેટલાક આવશ્યક ખ્યાલો છે:
- શુદ્ધ કાર્યો
- પુનરાવર્તન
- સંદર્ભિત પારદર્શિતા
- પ્રથમ વર્ગ અને ઉચ્ચ ક્રમના કાર્યો તરીકે કાર્યો
- ચલ અપરિવર્તનશીલ છે.

**શુદ્ધ કાર્યો**: આ કાર્યોમાં બે મુખ્ય ગુણધર્મો છે. પ્રથમ, તેઓ અન્ય કંઈપણને ધ્યાનમાં લીધા વિના સમાન દલીલો માટે હંમેશા સમાન આઉટપુટ ઉત્પન્ન કરે છે. બીજું, તેમની કોઈ આડઅસર નથી. એટલે કે તેઓ કોઈપણ દલીલો અથવા સ્થાનિક/વૈશ્વિક ચલમાં ફેરફાર કરતા નથી
અથવા ઇનપુટ/આઉટપુટ સ્ટ્રીમ્સ. પછીની મિલકતને *અપરિવર્તનક્ષમતા* કહેવાય છે. શુદ્ધ કાર્યનું એકમાત્ર પરિણામ તે આપે છે તે મૂલ્ય છે. તેઓ નિશ્ચયવાદી છે. ફંક્શનલ પ્રોગ્રામિંગનો ઉપયોગ કરીને કરવામાં આવેલ પ્રોગ્રામ ડીબગ કરવા માટે સરળ છે કારણ કે તેમાં કોઈ આડઅસર અથવા છુપાયેલ I/O નથી. શુદ્ધ કાર્યો પણ સમાંતર/સમયવર્તી એપ્લિકેશનો લખવાનું સરળ બનાવે છે. જ્યારે આ શૈલીમાં કોડ લખવામાં આવે છે, ત્યારે સ્માર્ટ કમ્પાઈલર ઘણી વસ્તુઓ કરી શકે છે- તે સૂચનાઓને સમાંતર બનાવી શકે છે, જ્યાં સુધી જરૂર હોય ત્યાં સુધી પરિણામોનું મૂલ્યાંકન કરવા માટે રાહ જુઓ અને પરિણામોને યાદ રાખો કારણ કે જ્યાં સુધી ઇનપુટ બદલાતું નથી ત્યાં સુધી પરિણામો ક્યારેય બદલાતા નથી. અહીં પાયથોનમાં શુદ્ધ કાર્યનું એક સરળ ઉદાહરણ છે:

```python
def sum(x ,y): # sum એ x અને y ને દલીલો તરીકે લેતી ફંક્શન છે
    return x + y # મૂલ્ય બદલ્યા વિના x + y પરત કરે છે
 ```

**પુનરાવર્તન**: શુદ્ધ કાર્યાત્મક પ્રોગ્રામિંગ ભાષાઓમાં કોઈ "માટે" અથવા "જ્યારે" લૂપ્સ નથી. પુનરાવર્તન દ્વારા પુનરાવૃત્તિ અમલમાં મૂકવામાં આવે છે. જ્યાં સુધી બેઝ કેસ ન આવે ત્યાં સુધી પુનરાવર્તિત કાર્યો વારંવાર પોતાને કૉલ કરે છે. અહીં પુનરાવર્તિતનું એક સરળ ઉદાહરણ છે
C માં કાર્ય:

```c
int fib(n) {
  if(n <= 1)
    return 1;
   else
     return (fib(n-1) + fib(n-2));
}
 ```

**રેફરન્શિયલ પારદર્શિતા**: કાર્યાત્મક પ્રોગ્રામ્સમાં, એકવાર વ્યાખ્યાયિત કરવામાં આવેલ વેરિયેબલ્સ સમગ્ર પ્રોગ્રામ દરમિયાન તેમની કિંમતમાં ફેરફાર કરતા નથી.
કાર્યાત્મક પ્રોગ્રામ્સમાં અસાઇનમેન્ટ સ્ટેટમેન્ટ હોતા નથી. જો આપણે અમુક મૂલ્ય સંગ્રહિત કરવું હોય, તો અમે તેના બદલે એક નવું ચલ વ્યાખ્યાયિત કરીએ છીએ. આ આડઅસરોની કોઈપણ તકને દૂર કરે છે કારણ કે અમલના કોઈપણ તબક્કે કોઈપણ ચલને તેના વાસ્તવિક મૂલ્ય સાથે બદલી શકાય છે. કોઈપણ ચલની સ્થિતિ કોઈપણ ક્ષણે સ્થિર હોય છે. ઉદાહરણ:
 
```bash
x = x + 1 # this changed the value assigned to the varable x
         # therefore, the expression is NOT referentially transparent
```

**ફંક્શનો ફર્સ્ટ-ક્લાસ છે અને ઉચ્ચ ક્રમમાં હોઈ શકે છે**: ફર્સ્ટ ક્લાસ ફંક્શનને ફર્સ્ટ-ક્લાસ ચલો તરીકે ગણવામાં આવે છે. ફર્સ્ટ ક્લાસ વેરીએબલ્સ ફંક્શનમાં પેરામીટર તરીકે પસાર કરી શકાય છે, ફંક્શનમાંથી પરત કરી શકાય છે અથવા ડેટા સ્ટ્રક્ચર્સમાં સ્ટોર કરી શકાય છે.
         
ફંક્શન એપ્લીકેશનના સંયોજનને LISP ફોર્મનો ઉપયોગ કરીને વ્યાખ્યાયિત કરી શકાય છે જેને **funcall** કહેવાય છે, જે દલીલો તરીકે ફંક્શન અને દલીલોની શ્રેણી લે છે અને તે ફંક્શનને તે દલીલો પર લાગુ કરે છે:

```Lisp
(defun filter (list-of-elements test)
    (cond ((null list-of-elements) nil)
          ((funcall test (car list-of-elements))
            (cons (car list-of-elements)
                (filter (cdr list-of-elements)
                      test)))
           (t (filter (cdr list-of-elements)
                       test))))
   ```
  ફંક્શન **ફિલ્ટર** સૂચિના પ્રથમ ઘટક પર પરીક્ષણ લાગુ કરે છે. જો પરીક્ષણ બિન-શૂન્ય પરત કરે છે, તો તે સૂચિના cdr પર લાગુ ફિલ્ટરના પરિણામ પર તત્વને સમાવે છે; નહિંતર, તે ફક્ત ફિલ્ટર કરેલ સીડીઆર પરત કરે છે. આ ફંક્શનનો ઉપયોગ વિવિધ ફિલ્ટરિંગ કાર્યો કરવા માટે પેરામીટર્સ તરીકે પસાર કરાયેલા વિવિધ અનુમાન સાથે થઈ શકે છે:

```Lisp
    > (filter '(1 3 -9 5 -2 -7 6) #'plusp)   ; filter out all negative numbers 
```    
    output: (1 3 5 6)

```Lisp
   > (filter '(1 2 3 4 5 6 7 8 9) #'evenp)   ; filter out all odd numbers
```   
   output: (2 4 6 8)

   and so on.

**ચલો અપરિવર્તનશીલ છે**: ફંક્શનલ પ્રોગ્રામિંગમાં, અમે વેરીએબલને બીમ ઇનિશિયલાઈઝ કર્યા પછી તેમાં ફેરફાર કરી શકતા નથી.
અમે નવા વેરીએબલ બનાવી શકીએ છીએ- પરંતુ અમે હાલના વેરીએબલને સંશોધિત કરી શકતા નથી, અને આ ખરેખર પ્રોગ્રામના રનટાઇમ દરમિયાન સ્થિતિ જાળવવામાં મદદ કરે છે. એકવાર આપણે વેરીએબલ બનાવીએ અને તેની કિંમત સેટ કરીએ, તો આપણે એ જાણીને સંપૂર્ણ વિશ્વાસ રાખી શકીએ કે તે વેરીએબલની કિંમત ક્યારેય બદલાશે નહીં.

## [ઓપરેટિંગ સિસ્ટમ્સ](Operating%20Systems/readme.md)
ઑપરેટિંગ સિસ્ટમ (અથવા ટૂંકમાં OS) કમ્પ્યુટર વપરાશકર્તા અને કમ્પ્યુટર હાર્ડવેર વચ્ચે મધ્યસ્થી તરીકે કાર્ય કરે છે. ઑપરેટિંગ સિસ્ટમનો ઉદ્દેશ્ય એવું વાતાવરણ પૂરું પાડવાનો છે કે જેમાં વપરાશકર્તા પ્રોગ્રામને અનુકૂળ અને અસરકારક રીતે ચલાવી શકે.
ઓપરેટિંગ સિસ્ટમ એ સોફ્ટવેર છે જે કમ્પ્યુટર હાર્ડવેરનું સંચાલન કરે છે. હાર્ડવેર એ કોમ્પ્યુટર સિસ્ટમના યોગ્ય સંચાલનને સુનિશ્ચિત કરવા અને વપરાશકર્તા પ્રોગ્રામ્સને સિસ્ટમના યોગ્ય સંચાલનમાં દખલ કરતા અટકાવવા માટે યોગ્ય મિકેનિઝમ્સ પ્રદાન કરવી આવશ્યક છે.
તેનાથી પણ વધુ સામાન્ય વ્યાખ્યા એ છે કે ઓપરેટિંગ સિસ્ટમ એ એક પ્રોગ્રામ છે જે કોમ્પ્યુટર (સામાન્ય રીતે કર્નલ તરીકે ઓળખાય છે) પર દરેક સમયે ચાલતો હોય છે, બાકીના બધા એપ્લીકેશન પ્રોગ્રામ હોય છે.

ઓપરેટિંગ સિસ્ટમ્સને બે દૃષ્ટિકોણથી જોઈ શકાય છે: રિસોર્સ મેનેજર અને
વિસ્તૃત મશીનો. રિસોર્સ-મેનેજરની દૃષ્ટિએ, ઑપરેટિંગ સિસ્ટમનું કામ છે
સિસ્ટમના વિવિધ ભાગોને અસરકારક રીતે સંચાલિત કરો. વિસ્તૃત-મશીન દૃશ્યમાં,
સિસ્ટમનું કામ વપરાશકર્તાઓને એબ્સ્ટ્રેક્શન્સ પ્રદાન કરવાનું છે જે વધુ વિરોધાભાસી છે.
વાસ્તવિક મશીન કરતાં વાપરવા માટે અનુકૂળ. આમાં પ્રક્રિયાઓ, સરનામાંની જગ્યાઓ,
અને ફાઇલો.
ઓપરેટિંગ સિસ્ટમનો લાંબો ઈતિહાસ છે, જ્યારે તેઓ ઓપરેટરને બદલીને આધુનિક મલ્ટિપ્રોગ્રામિંગ સિસ્ટમ્સ પર આવ્યા.
હાઇલાઇટ્સમાં પ્રારંભિક બેચ સિસ્ટમ્સ, મલ્ટિપ્રોગ્રામિંગ સિસ્ટમ્સ અને વ્યક્તિગત કમ્પ્યુટર સિસ્ટમ્સનો સમાવેશ થાય છે.
ઓપરેટિંગ સિસ્ટમ હાર્ડવેર સાથે નજીકથી ક્રિયાપ્રતિક્રિયા કરતી હોવાથી, કેટલાક જ્ઞાન
તેમને સમજવા માટે કમ્પ્યુટર હાર્ડવેર ઉપયોગી છે. કોમ્પ્યુટર બનેલ છે
પ્રોસેસર્સ, મેમરીઝ અને I/O ઉપકરણો. આ ભાગો બસો દ્વારા જોડાયેલા છે.
મૂળભૂત વિભાવનાઓ કે જેના પર તમામ ઓપરેટિંગ સિસ્ટમ્સ બનાવવામાં આવી છે તે પ્રક્રિયાઓ છે,
મેમરી મેનેજમેન્ટ, I/O મેનેજમેન્ટ, ફાઇલ સિસ્ટમ અને સુરક્ષા. કોઈપણ ઓપરેટિંગ સિસ્ટમનું હૃદય એ સિસ્ટમ કૉલ્સનો સમૂહ છે જેને તે હેન્ડલ કરી શકે છે.
આ ઓપરેટિંગ સિસ્ટમ શું કરે છે તે જણાવે છે.

### રિસોર્સ મેનેજર તરીકે ઓપરેટિંગ સિસ્ટમ
ઓપરેટિંગ સિસ્ટમ જટિલ સિસ્ટમના તમામ ભાગોનું સંચાલન કરે છે. આધુનિક કોમ્પ્યુટરમાં પ્રોસેસર, સ્મૃતિઓ, ટાઈમર, ડિસ્ક, ઉંદર,
નેટવર્ક ઇન્ટરફેસ, પ્રિન્ટર્સ અને અન્ય ઉપકરણોની વિશાળ વિવિધતા.
બોટમ-અપ વ્યુમાં, ઓપરેટિંગ સિસ્ટમનું કામ વ્યવસ્થિત અને નિયંત્રિત ફાળવણી માટે પ્રદાન કરવાનું છે.
પ્રોસેસર્સ, મેમોરીઝ, અને I/O ઉપકરણો જે તેમને જોઈતા હોય તેવા વિવિધ પ્રોગ્રામમાં.
આધુનિક ઓપરેટિંગ સિસ્ટમ બહુવિધ પ્રોગ્રામ્સને મેમરીમાં રાખવા અને ચલાવવાની મંજૂરી આપે છે
સાથે સાથે કલ્પના કરો કે જો કેટલાક પર ત્રણ પ્રોગ્રામ ચાલતા હોય તો શું થશે
કોમ્પ્યુટર બધાએ તેમના આઉટપુટને એક જ પ્રિન્ટર પર વારાફરતી છાપવાનો પ્રયાસ કર્યો.
પરિણામ તદ્દન અરાજકતા હશે. ઓપરેટિંગ સિસ્ટમ સંભવિત અંધાધૂંધી માટે ઓર્ડર લાવી શકે છે
ડિસ્ક પર પ્રિન્ટર માટે નિર્ધારિત તમામ આઉટપુટને બફર કરીને.
જ્યારે એક પ્રોગ્રામ સમાપ્ત થાય છે, ઓપરેટિંગ સિસ્ટમ કરી શકે છે
પછી ડિસ્ક ફાઇલમાંથી તેના આઉટપુટની નકલ કરો જ્યાં તેને પ્રિન્ટર માટે સંગ્રહિત કરવામાં આવ્યું છે,
જ્યારે તે જ સમયે, અન્ય પ્રોગ્રામ વધુ આઉટપુટ ઉત્પન્ન કરવાનું ચાલુ રાખી શકે છે,
એ હકીકતથી અજાણ છે કે આઉટપુટ પ્રિન્ટર પર જઈ રહ્યું નથી (હજી સુધી).
જ્યારે કોમ્પ્યુટર (અથવા નેટવર્ક)માં એક કરતા વધુ યુઝર હોય ત્યારે તેનું સંચાલન કરવાની જરૂર હોય છે
અને મેમરી, I/O ઉપકરણો અને અન્ય સંસાધનોને ત્યારથી વધુ સુરક્ષિત કરે છે
વપરાશકર્તાઓ અન્યથા એકબીજા સાથે દખલ કરી શકે છે. વધુમાં, વપરાશકર્તાઓને વારંવાર જરૂર પડે છે
માત્ર હાર્ડવેર જ નહીં પણ માહિતી (ફાઈલો, ડેટાબેઝ વગેરે) પણ શેર કરો. ટૂંક માં,
ઓપરેટિંગ સિસ્ટમનો આ દૃષ્ટિકોણ એવું માને છે કે તેનું પ્રાથમિક કાર્ય ટ્રૅક રાખવાનું છે
કયા પ્રોગ્રામ્સ કયા સંસાધનનો ઉપયોગ કરી રહ્યા છે, સંસાધન વિનંતીઓ મંજૂર કરવા, એકાઉન્ટમાં
ઉપયોગ માટે અને વિવિધ પ્રોગ્રામ્સ અને વપરાશકર્તાઓ તરફથી વિરોધાભાસી વિનંતીઓની મધ્યસ્થી કરવા માટે.

### એક વિસ્તૃત મશીન તરીકે ઓપરેટિંગ સિસ્ટમ
મશીન-લેંગ્વેજ લેવલ પર મોટાભાગના કોમ્પ્યુટરનું આર્કિટેક્ચર આદિમ અને બેડોળ છે.
પ્રોગ્રામ, ખાસ કરીને ઇનપુટ/આઉટપુટ માટે. આ મુદ્દાને વધુ નક્કર બનાવવા માટે, ધ્યાનમાં લો
આધુનિક SATA (Serial ATA) હાર્ડ ડિસ્કનો ઉપયોગ મોટાભાગના કમ્પ્યુટર્સ પર થાય છે. ડિસ્કનો ઉપયોગ કરવા માટે પ્રોગ્રામરને શું જાણવાની જરૂર છે.
ત્યારથી, ઇન્ટરફેસને ઘણી વખત સુધારવામાં આવ્યું છે અને તે પહેલા કરતાં વધુ જટિલ છે
2007. કોઈપણ સમજદાર પ્રોગ્રામર હાર્ડવેર સ્તરે આ ડિસ્ક સાથે વ્યવહાર કરવા માંગતો નથી.
તેના બદલે, ડિસ્ક ડ્રાઈવર તરીકે ઓળખાતા સોફ્ટવેરનો ટુકડો હાર્ડવેર સાથે કામ કરે છે અને ડિસ્ક બ્લોક વાંચવા અને લખવા માટે ઈન્ટરફેસ પૂરો પાડે છે,
વિગતો મેળવ્યા વિના.
ઑપરેટિંગ સિસ્ટમમાં I/O ઉપકરણોને નિયંત્રિત કરવા માટે ઘણા ડ્રાઇવરો હોય છે.
પરંતુ મોટાભાગની એપ્લિકેશનો માટે પણ આ સ્તર ઘણું ઓછું છે. આ કારણોસર, બધા
ઑપરેટિંગ સિસ્ટમ્સ ડિસ્કનો ઉપયોગ કરવા માટે એબ્સ્ટ્રેક્શનનું બીજું સ્તર પૂરું પાડે છે: ફાઇલો.
આ એબ્સ્ટ્રેક્શનનો ઉપયોગ કરીને, પ્રોગ્રામ્સ હાર્ડવેર કેવી રીતે કાર્ય કરે છે તેની અવ્યવસ્થિત વિગતો સાથે વ્યવહાર કર્યા વિના ફાઇલો બનાવી, લખી અને વાંચી શકે છે.
આ અમૂર્તતા આ બધી જટિલતાને સંચાલિત કરવાની ચાવી છે. સારા અમૂર્ત
લગભગ અશક્ય કાર્યને બે વ્યવસ્થિત કાર્યોમાં ફેરવો. પ્રથમ વ્યાખ્યાયિત છે અને
અમૂર્તનો અમલ. બીજું ઉકેલવા માટે આ અમૂર્તનો ઉપયોગ કરી રહ્યું છે
હાથમાં સમસ્યા.

### ઑપરેટિંગ સિસ્ટમ્સનો ઇતિહાસ
- **ફર્સ્ટ જનરેશન (1945-55)**: બીજા વિશ્વયુદ્ધના યુગ સુધી બેબેજના વિનાશક પ્રયાસો પછી ડિજિટલ કમ્પ્યુટર બનાવવામાં થોડી પ્રગતિ થઈ. આયોવા સ્ટેટ યુનિવર્સિટીમાં, પ્રોફેસર જ્હોન એટાનાસોફ અને તેમના સ્નાતક વિદ્યાર્થી ક્લિફોર્ડ બેરીએ બનાવ્યું જે આજે પ્રથમ ઓપરેશનલ ડિજિટલ કમ્પ્યુટર તરીકે ઓળખાય છે. બર્લિનમાં કોનરાડ ઝુસે તે જ સમયે ઇલેક્ટ્રોમિકેનિકલ રિલેનો ઉપયોગ કરીને Z3 કમ્પ્યુટરનું નિર્માણ કર્યું. માર્ક I ની રચના હાર્વર્ડ ખાતે હાવર્ડ આઈકેન દ્વારા, ઈંગ્લેન્ડમાં બ્લેચલી પાર્ક ખાતે વૈજ્ઞાનિકોની ટીમ દ્વારા કોલોસસ અને વિલિયમ મૌચલી અને તેમના ડોક્ટરલ વિદ્યાર્થી જે. પ્રેસ્પર એકર્ટ દ્વારા 1944માં યુનિવર્સિટી ઓફ પેન્સિલવેનિયામાં કરવામાં આવી હતી.

- **સેકન્ડ જનરેશન (1955-65)**: 1950 ના દાયકાના મધ્યમાં ટ્રાંઝિસ્ટરની શોધે પરિસ્થિતિમાં ધરખમ ફેરફાર કર્યો. કોમ્પ્યુટર એટલા ભરોસાપાત્ર બની ગયા કે તેઓ અમુક અર્થપૂર્ણ કામ કરવા માટે લાંબા સમય સુધી કામ કરતા રહેશે એવી ધારણા સાથે પેમેન્ટ ગ્રાહકોને ઉત્પાદન અને વેચાણ કરી શકાય. મેઈનફ્રેમ્સ, જેમ કે આ મશીનો હવે જાણીતા છે, તેમને વિશાળ, ખાસ કરીને એર-કન્ડિશન્ડ કોમ્પ્યુટર રૂમમાં બંધ રાખવામાં આવ્યા હતા, જેમાં તેનું સંચાલન કરવા માટે લાયક ઓપરેટરોની ટીમો હતી. માત્ર વિશાળ વ્યવસાયો, નોંધપાત્ર સરકારી સંસ્થાઓ અથવા સંસ્થાઓ જ કેટલાક મિલિયન ડોલરની કિંમત પરવડી શકે છે.

- **ત્રીજી પેઢી (1965-80)**: વ્યક્તિગત ટ્રાન્ઝિસ્ટરથી બનેલા સેકન્ડ જનરેશન કોમ્પ્યુટરની સરખામણીમાં, IBM 360 એ (નાના પાયે) ICs (ઇન્ટિગ્રેટેડ સર્કિટ) ને રોજગારી આપતી પ્રથમ મોટી કમ્પ્યુટર લાઇન હતી. પરિણામે, તે નોંધપાત્ર કિંમત/પ્રદર્શન લાભ ઓફર કરે છે. તે એક ત્વરિત હિટ હતી, અને અન્ય તમામ મોટા ઉત્પાદકોએ ઇન્ટરઓપરેબલ કમ્પ્યુટર્સના પરિવારની કલ્પનાને ઝડપથી સ્વીકારી લીધી. OS/360 ઓપરેટિંગ સિસ્ટમ સહિત તમામ સોફ્ટવેર, મૂળ ડિઝાઇનમાંના તમામ મોડલ્સ સાથે સુસંગત હોવા જોઈએ. તેને વિશાળ સિસ્ટમો પર ચલાવવાની હતી, જેણે ભારે ગણતરી અને હવામાનની આગાહી માટે વારંવાર 7094s અને નાની સિસ્ટમો, જે વારંવાર કાર્ડને ટેપમાં સ્થાનાંતરિત કરવા માટે 1401s ને બદલે છે. થોડા પેરિફેરલ્સ ધરાવતી બંને સિસ્ટમો અને ઘણા પેરિફેરલ સાથેની સિસ્ટમ્સ તેની સાથે સારી રીતે કાર્ય કરવા માટે જરૂરી છે. તે વ્યાવસાયિક અને શૈક્ષણિક સેટિંગ્સ બંનેમાં કાર્ય કરવાનું હતું. સૌથી ઉપર, તે આ દરેક એપ્લિકેશન માટે અસરકારક હોવું જરૂરી હતું.

- **ફોર્થ જનરેશન (1980-હાલ): પર્સનલ કમ્પ્યુટર યુગની શરૂઆત એલએસઆઈ (લાર્જ સ્કેલ ઈન્ટિગ્રેશન) સર્કિટ, સિલિકોનના ચોરસ સેન્ટીમીટર પર હજારો ટ્રાંઝિસ્ટર સાથેના પ્રોસેસર્સની રચના સાથે થઈ હતી. જોકે વ્યક્તિગત કમ્પ્યુટર્સ, જે મૂળ રીતે માઇક્રોકોમ્પ્યુટર્સ તરીકે ઓળખાય છે, તે PDP-11 વર્ગના મિનીકોમ્પ્યુટર્સથી આર્કિટેક્ચરમાં નોંધપાત્ર રીતે બદલાયું નથી, તેઓ કિંમતમાં નોંધપાત્ર રીતે અલગ હતા.

- **ફિફ્થ જનરેશન (1990-હાલ): 1940 ના દાયકાની કોમિક સ્ટ્રીપમાં ડિટેક્ટીવ ડિક ટ્રેસીએ તેની "ટુ-વે રેડિયો કાંડા ઘડિયાળ" સાથે વાતચીત કરવાનું શરૂ કર્યું ત્યારથી લોકો પોર્ટેબલ કમ્યુનિકેશન ગેજેટ માટે ઉત્સુક છે. 1946 માં, એક વાસ્તવિક મોબાઇલ ફોન તેની શરૂઆત કરી, અને તેનું વજન લગભગ 40 કિલોગ્રામ હતું. પહેલો વાસ્તવિક પોર્ટેબલ ફોન 1970ના દાયકામાં રજૂ થયો હતો અને તે લગભગ એક કિલોગ્રામ વજનનો અતિશય હલકો હતો. તેને મજાકમાં "ઈંટ" તરીકે ઓળખવામાં આવે છે. ટૂંક સમયમાં, દરેક એક માટે પોકાર કરી રહ્યો હતો.

### OS ના કાર્યો
- **સુવિધા**: OS કમ્પ્યુટરને વાપરવા માટે વધુ અનુકૂળ બનાવે છે.
- **કાર્યક્ષમતા**: એક OS કમ્પ્યુટર સિસ્ટમ સંસાધનોનો કાર્યક્ષમ ઉપયોગ કરવાની મંજૂરી આપે છે.
- **વિકાસ કરવાની ક્ષમતા**: સેવામાં દખલ કર્યા વિના એક જ સમયે અસરકારક વિકાસ, પરીક્ષણ અને નવા સિસ્ટમ કાર્યોના પરિચયને મંજૂરી આપવા માટે OSનું નિર્માણ કરવું જોઈએ.
- **થ્રુપુટ**: ઓએસનું નિર્માણ કરવું જોઈએ જેથી કરીને તે મહત્તમ થ્રુપુટ આપી શકે (એકમ સમય દીઠ કાર્યોની સંખ્યા).

### OS ની મુખ્ય કાર્યક્ષમતા
- **સંસાધન વ્યવસ્થાપન**: જ્યારે OS માં સમાંતર એક્સેસિંગ થાય છે, તેનો અર્થ એ છે કે જ્યારે બહુવિધ વપરાશકર્તાઓ સિસ્ટમને ઍક્સેસ કરી રહ્યાં હોય, ત્યારે OS રિસોર્સ મેનેજર તરીકે કામ કરે છે. તેની જવાબદારી વપરાશકર્તાને હાર્ડવેર પ્રદાન કરવાની છે. તે સિસ્ટમમાં ભાર ઘટાડે છે.
- **પ્રોસેસ મેનેજમેન્ટ**: તેમાં વિવિધ કાર્યોનો સમાવેશ થાય છે જેમ કે શેડ્યુલિંગ અને પ્રક્રિયાની સમાપ્તિ. OS એક સમયે વિવિધ કાર્યોનું સંચાલન કરે છે. અહીં CPU શેડ્યુલિંગ થાય છે એટલે કે તમામ કાર્યો શેડ્યૂલિંગ માટે ઉપયોગમાં લેવાતા ઘણા અલ્ગોરિધમ્સ દ્વારા કરવામાં આવશે.
- **સ્ટોરેજ મેનેજમેન્ટ**: સ્ટોરેજના મેનેજમેન્ટ માટે ઉપયોગમાં લેવાતી ફાઇલ સિસ્ટમ મિકેનિઝમ. NIFS, CFS, CIFS, NFS, વગેરે કેટલીક ફાઇલ સિસ્ટમ છે. તમામ ડેટા હાર્ડ ડિસ્કના વિવિધ ટ્રેકમાં સંગ્રહિત થાય છે જે તમામ સ્ટોરેજ મેનેજર દ્વારા સંચાલિત થાય છે. તેમાં હાર્ડ ડિસ્કનો સમાવેશ થતો હતો.
- **મેમરી મેનેજમેન્ટ**: પ્રાથમિક મેમરીના સંચાલનનો સંદર્ભ આપે છે. ઓપરેટિંગ સિસ્ટમે કેટલી મેમરીનો ઉપયોગ કર્યો છે અને કોના દ્વારા કરવામાં આવ્યો છે તેનો ટ્રેક રાખવાનો હોય છે. તેણે નક્કી કરવાનું છે કે કઈ પ્રક્રિયાને મેમરી સ્પેસની જરૂર છે અને કેટલી. OS એ મેમરી સ્પેસની ફાળવણી અને ડિલોકેટ પણ કરવાની હોય છે.
- **સુરક્ષા/ગોપનીયતા વ્યવસ્થાપન**: પાસવર્ડનો ઉપયોગ કરતી ઓપરેટિંગ સિસ્ટમ દ્વારા પણ ગોપનીયતા પ્રદાન કરવામાં આવે છે જેથી અનધિકૃત એપ્લિકેશન પ્રોગ્રામ્સ અથવા ડેટાને ઍક્સેસ કરી શકે નહીં. ઉદાહરણ તરીકે, Windows ડેટાની અનધિકૃત ઍક્સેસને રોકવા માટે **_Kerberos_** પ્રમાણીકરણનો ઉપયોગ કરે છે.

### ઓપરેટિંગ સિસ્ટમ્સના પ્રકાર
- **મેઈનફ્રેમ ઓએસ**:
ઉંચા છેડે મેઇનફ્રેમ માટે ઓપરેટિંગ સિસ્ટમ્સ છે, તે રૂમના કદની છે
કોમ્પ્યુટર હજુ પણ મોટા કોર્પોરેટ ડેટા સેન્ટરોમાં જોવા મળે છે. આ કોમ્પ્યુટરો અલગ પડે છે
વ્યક્તિગત કમ્પ્યુટર્સ તેમની I/O ક્ષમતાના સંદર્ભમાં. 1000 ડિસ્ક સાથે મેઇનફ્રેમ
અને લાખો ગીગાબાઇટ્સ ડેટા અસામાન્ય નથી; આ સાથે એક વ્યક્તિગત કમ્પ્યુટર
સ્પષ્ટીકરણો તેના મિત્રોની ઈર્ષ્યા હશે. મેઇનફ્રેમ્સ પણ કેટલાક બનાવે છે-
હાઇ-એન્ડ વેબ સર્વર્સ, મોટા પાયે ઇલેક્ટ્રોનિક માટે સર્વર તરીકે પુનરાગમનની વસ્તુ
વેપાર-થી-વ્યવસાય વ્યવહારો માટે કોમર્સ સાઇટ્સ અને સર્વર્સ.
મેઈનફ્રેમ માટેની ઓપરેટિંગ સિસ્ટમો પ્રોસેસિંગ તરફ ભારે લક્ષી છે
એક સાથે ઘણી નોકરીઓ, જેમાંથી મોટા ભાગનાને I/O ની પ્રચંડ માત્રાની જરૂર છે. તેઓ સામાન્ય રીતે
ત્રણ પ્રકારની સેવાઓ ઓફર કરે છે: બેચ, ટ્રાન્ઝેક્શન પ્રોસેસિંગ અને ટાઇમશેરિંગ

- **સર્વર OS**:
એક સ્તર નીચે સર્વર ઓપરેટિંગ સિસ્ટમ્સ છે. તેઓ સર્વર્સ પર ચાલે છે, જે
કાં તો ખૂબ મોટા પર્સનલ કમ્પ્યુટર્સ, વર્કસ્ટેશનો અથવા તો મેઈનફ્રેમ્સ છે. તેઓ
નેટવર્ક પર એક સાથે બહુવિધ વપરાશકર્તાઓને સેવા આપે છે અને વપરાશકર્તાઓને હાર્ડવેર શેર કરવાની મંજૂરી આપે છે
અને સોફ્ટવેર સંસાધનો. સર્વર્સ પ્રિન્ટ સેવા, ફાઇલ સેવા અથવા વેબ સેવા પ્રદાન કરી શકે છે.
ઇન્ટરનેટ પ્રદાતાઓ તેમના ગ્રાહકોને ટેકો આપવા માટે ઘણા સર્વર મશીનો ચલાવે છે
, અને વેબસાઈટ્સ વેબ પૃષ્ઠોને સંગ્રહિત કરવા અને આવનારી વિનંતીઓને હેન્ડલ કરવા માટે સર્વર્સનો ઉપયોગ કરે છે.
લાક્ષણિક સર્વર ઓપરેટિંગ સિસ્ટમો સોલારિસ, ફ્રીબીએસડી, લિનક્સ અને વિન્ડોઝ સર્વર છે
201x.

- **મલ્ટીપ્રોસેસર ઓએસ**:
મેજર-લીગ કમ્પ્યુટીંગ પાવર મેળવવાની વધુને વધુ સામાન્ય રીત એ છે કે એક જ સિસ્ટમમાં બહુવિધ CPU ને જોડવું.
તેઓ કેવી રીતે જોડાયેલા છે અને શું વહેંચાયેલ છે તેના પર આધાર રાખીને, આ સિસ્ટમોને સમાંતર કમ્પ્યુટર્સ, મલ્ટિ-કમ્પ્યુટર અથવા મલ્ટિપ્રોસેસર્સ કહેવામાં આવે છે.
તેમને ખાસ ઓપરેટિંગ સિસ્ટમ્સની જરૂર હોય છે, પરંતુ ઘણીવાર આ સર્વર ઓપરેટિંગ સિસ્ટમ્સ પર વિવિધતા હોય છે,
સંચાર, કનેક્ટિવિટી અને સુસંગતતા માટે વિશેષ સુવિધાઓ સાથે.

- **પર્સનલ કોમ્પ્યુટર ઓએસ**:
આગળની શ્રેણી વ્યક્તિગત કમ્પ્યુટર ઓપરેટિંગ સિસ્ટમ છે. આધુનિક બધા
મલ્ટિપ્રોગ્રામિંગને સપોર્ટ કરે છે, ઘણીવાર ડઝનેક પ્રોગ્રામ બુટ સમયે શરૂ થાય છે.
તેમનું કામ એક જ યુઝરને સારો સપોર્ટ આપવાનું છે. તેઓ માટે વ્યાપકપણે ઉપયોગમાં લેવાય છે
વર્ડ પ્રોસેસિંગ, સ્પ્રેડશીટ્સ, ગેમ્સ અને ઈન્ટરનેટ એક્સેસ. સામાન્ય ઉદાહરણો છે
Linux, FreeBSD, Windows 7, Windows 8, અને Appleનું OS X. પર્સનલ કમ્પ્યુટર
ઓપરેટિંગ સિસ્ટમ્સ એટલી વ્યાપક રીતે જાણીતી છે કે કદાચ થોડો પરિચય જરૂરી છે.
ઘણા લોકો એ પણ જાણતા નથી કે અન્ય પ્રકારો અસ્તિત્વમાં છે.

- **એમ્બેડેડ OS**:
એમ્બેડેડ સિસ્ટમો એવા કમ્પ્યુટર્સ પર ચાલે છે જે એવા ઉપકરણોને નિયંત્રિત કરે છે કે જેને સામાન્ય રીતે કોમ્પ્યુટર માનવામાં આવતું નથી અને વપરાશકર્તા દ્વારા ઇન્સ્ટોલ કરેલ સોફ્ટવેર સ્વીકારતા નથી.
લાક્ષણિક ઉદાહરણો માઇક્રોવેવ ઓવન, ટીવી સેટ, કાર, ડીવીડી રેકોર્ડર, પરંપરાગત છે
ફોન અને MP3 પ્લેયર. હેન્ડહેલ્ડ્સથી એમ્બેડેડ સિસ્ટમ્સને અલગ પાડતી મુખ્ય મિલકત એ નિશ્ચિતતા છે કે તેમના પર કોઈ અવિશ્વસનીય સોફ્ટવેર ક્યારેય ચાલશે નહીં.
તમે તમારા માઇક્રોવેવ ઓવનમાં નવી એપ્લિકેશનો ડાઉનલોડ કરી શકતા નથી - તમામ સોફ્ટવેર
ROM માં છે. આનો અર્થ એ છે કે એપ્લિકેશનો વચ્ચે સુરક્ષાની કોઈ જરૂર નથી,
સરળ ડિઝાઇન. સિસ્ટમો જેમ કે એમ્બેડેડ લિનક્સ, ક્યુએનએક્સ અને
VxWorks આ ડોમેનમાં લોકપ્રિય છે.

- **સ્માર્ટ કાર્ડ ઓએસ**:
સૌથી નાની ઓપરેટિંગ સિસ્ટમ ક્રેડિટ-કાર્ડ-સાઇઝના સ્માર્ટ કાર્ડ પર ચાલે છે
CPU ચિપ્સ સાથેના ઉપકરણો. તેમની પાસે ખૂબ જ ગંભીર પ્રોસેસિંગ પાવર અને મેમરી અવરોધો છે.
કેટલાક રીડરના સંપર્કો દ્વારા સંચાલિત થાય છે જેમાં તેઓ છે
દાખલ કર્યા છે, પરંતુ કોન્ટેક્ટલેસ સ્માર્ટ કાર્ડ્સ પ્રેરક રીતે સંચાલિત છે, મોટા પ્રમાણમાં મર્યાદિત કરે છે
તેઓ શું કરી શકે છે. કેટલાક ફક્ત એક જ કાર્યને હેન્ડલ કરી શકે છે, જેમ કે ઇલેક્ટ્રોનિક ચૂકવણી, પરંતુ અન્ય બહુવિધ કાર્યોને હેન્ડલ કરી શકે છે.
મોટેભાગે આ માલિકીની સિસ્ટમો છે.
કેટલાક સ્માર્ટ કાર્ડ જાવા ઓરિએન્ટેડ છે. આનો અર્થ એ કે સ્માર્ટ પર ROM
કાર્ડ જાવા વર્ચ્યુઅલ મશીન (JVM) માટે દુભાષિયા ધરાવે છે. જાવા એપ્લેટ્સ (નાના
પ્રોગ્રામ્સ) કાર્ડ પર ડાઉનલોડ થાય છે અને JVM દુભાષિયા દ્વારા અર્થઘટન કરવામાં આવે છે.
આમાંના કેટલાક કાર્ડ એક જ સમયે બહુવિધ જાવા એપ્લેટને હેન્ડલ કરી શકે છે, જે તરફ દોરી જાય છે
મલ્ટિપ્રોગ્રામિંગ અને તેમને સુનિશ્ચિત કરવાની જરૂરિયાત. જ્યારે બે કે તેથી વધુ એપ્લેટ્સ એકસાથે હાજર હોય ત્યારે સંસાધન વ્યવસ્થાપન અને સુરક્ષા પણ એક સમસ્યા બની જાય છે.
આ મુદ્દાઓ કાર્ડ પર હાજર (સામાન્ય રીતે અત્યંત આદિમ) ઓપરેટિંગ સિસ્ટમ દ્વારા નિયંત્રિત થવી જોઈએ.

## [મેમરી અને સ્ટોરેજ](Memory%20and%20Storage/readme.md)

### મેમરી
_memory_ શબ્દ એ તમારા કમ્પ્યુટરમાં ટૂંકા ગાળાના ડેટા ઍક્સેસની મંજૂરી આપતા ઘટકનો સંદર્ભ આપે છે. તમે આ ઘટકને DRAM અથવા ડાયનેમિક રેન્ડમ એક્સેસ મેમરી તરીકે ઓળખી શકો છો. તમારું કમ્પ્યુટર તેની ટૂંકા ગાળાની મેમરીમાં સંગ્રહિત ડેટાને ઍક્સેસ કરીને ઘણી કામગીરી કરે છે. આવી કામગીરીના કેટલાક ઉદાહરણોમાં દસ્તાવેજને સંપાદિત કરવા, એપ્લિકેશન લોડ કરવા અને ઈન્ટરનેટ બ્રાઉઝ કરવાનો સમાવેશ થાય છે. તમારી સિસ્ટમની ઝડપ અને કામગીરી તમારા કમ્પ્યુટર પર ઇન્સ્ટોલ કરેલી મેમરીની માત્રા પર આધારિત છે.

જો તમારી પાસે ડેસ્ક અને ફાઇલિંગ કેબિનેટ હોય, તો ડેસ્ક તમારા કમ્પ્યુટરની મેમરીનું પ્રતિનિધિત્વ કરે છે. તમારે જે વસ્તુઓનો તાત્કાલિક ઉપયોગ કરવાની જરૂર છે તે સરળ ઍક્સેસ માટે તમારા ડેસ્ક પર રાખવામાં આવે છે. જો કે, તેના કદની મર્યાદાઓને કારણે ડેસ્ક પર વધુ સંગ્રહિત કરી શકાતું નથી.

### સ્ટોરેજ
જ્યારે મેમરી એ ટૂંકા ગાળાના ડેટાના સ્થાનનો સંદર્ભ આપે છે, ત્યારે _storage_ એ તમારા કમ્પ્યુટરમાંનો એક ઘટક છે જે તમને લાંબા ગાળાના ડેટાને સંગ્રહિત અને ઍક્સેસ કરવાની મંજૂરી આપે છે. સામાન્ય રીતે, સ્ટોરેજ સોલિડ-સ્ટેટ ડ્રાઇવ અથવા હાર્ડ ડ્રાઇવના સ્વરૂપમાં આવે છે. સ્ટોરેજ તમારી એપ્લિકેશનો, ઓપરેટિંગ સિસ્ટમ અને ફાઇલોને અનિશ્ચિત સમય માટે રાખે છે. કોમ્પ્યુટરને સ્ટોરેજ સિસ્ટમમાંથી માહિતી વાંચવાની અને લખવાની જરૂર છે, તેથી સ્ટોરેજ સ્પીડ નક્કી કરે છે કે તમારી સિસ્ટમ કેટલી ઝડપથી બુટ કરી શકે છે, લોડ કરી શકે છે અને તમે જે સાચવ્યું છે તેને ઍક્સેસ કરી શકે છે.

જ્યારે ડેસ્ક કમ્પ્યુટરની મેમરીનું પ્રતિનિધિત્વ કરે છે, ત્યારે ફાઇલિંગ કેબિનેટ તમારા કમ્પ્યુટરના સ્ટોરેજનું પ્રતિનિધિત્વ કરે છે. તે એવી વસ્તુઓ ધરાવે છે જેને સાચવવાની અને સંગ્રહિત કરવાની જરૂર છે પરંતુ તાત્કાલિક ઍક્સેસ માટે જરૂરી નથી. ફાઇલિંગ કેબિનેટના કદનો અર્થ એ છે કે તે ઘણી વસ્તુઓને પકડી શકે છે.

મેમરી અને સ્ટોરેજ વચ્ચે **એક મહત્વપૂર્ણ તફાવત** એ છે કે જ્યારે કમ્પ્યુટર બંધ હોય ત્યારે મેમરી સાફ થાય છે. બીજી બાજુ, સ્ટોરેજ અકબંધ રહે છે પછી ભલે તમે તમારા કમ્પ્યુટરને કેટલી વાર બંધ કરો. તેથી, ડેસ્ક અને ફાઇલિંગ કેબિનેટ સામ્યતામાં, જ્યારે તમે ઑફિસ છોડો ત્યારે તમારા ડેસ્ક પર બાકી રહેલી કોઈપણ ફાઇલો ફેંકી દેવામાં આવશે. તમારા ફાઇલિંગ કેબિનેટમાં બધું જ રહેશે.

### વર્ચ્યુઅલ મેમરી
કોમ્પ્યુટર સિસ્ટમના હાર્દમાં મેમરી છે, તે જગ્યા જ્યાં પ્રોગ્રામ ચાલે છે અને ડેટા સંગ્રહિત થાય છે. પરંતુ જ્યારે તમે ચલાવી રહ્યાં છો તે પ્રોગ્રામ્સ અને તમે જે ડેટા સાથે કામ કરી રહ્યાં છો તે તમારા કમ્પ્યુટરની મેમરીની ભૌતિક ક્ષમતા કરતાં વધી જાય ત્યારે શું થાય છે? આ તે છે જ્યાં વર્ચ્યુઅલ મેમરી તમારા કમ્પ્યુટરની મેમરીમાં સ્માર્ટ એક્સટેન્શન તરીકે કામ કરે છે અને તેની ક્ષમતાઓને વધારે છે.

**વર્ચ્યુઅલ મેમરીની વ્યાખ્યા અને હેતુ:**

વર્ચ્યુઅલ મેમરી એ મેમરી મેનેજમેન્ટ ટેકનિક છે જે ઓપરેટિંગ સિસ્ટમ દ્વારા ભૌતિક મેમરી (RAM) ની મર્યાદાઓને દૂર કરવા માટે કાર્યરત છે. તે સોફ્ટવેર એપ્લીકેશનો માટે એક ભ્રમણા બનાવે છે કે તેમની પાસે કમ્પ્યુટર પર ભૌતિક રીતે ઇન્સ્ટોલ કરેલી મેમરી કરતાં મોટી માત્રામાં મેમરીની ઍક્સેસ છે. સારમાં, તે કમ્પ્યુટરની ભૌતિક RAM ની મર્યાદાની બહાર મેમરી સ્પેસનો ઉપયોગ કરવા માટે પ્રોગ્રામ્સને સક્ષમ કરે છે.

વર્ચ્યુઅલ મેમરીનો પ્રાથમિક ઉદ્દેશ્ય કાર્યક્ષમ મલ્ટીટાસ્કિંગ અને મોટા કાર્યક્રમોના અમલને સક્ષમ કરવાનો છે, આ બધું જ સિસ્ટમની પ્રતિભાવશીલતા જાળવી રાખીને. તે ભૌતિક RAM અને સેકન્ડરી સ્ટોરેજ ઉપકરણો, જેમ કે હાર્ડ ડ્રાઈવ અથવા SSD વચ્ચે સીમલેસ ક્રિયાપ્રતિક્રિયા બનાવીને આ હાંસલ કરે છે.

**વર્ચ્યુઅલ મેમરી કેવી રીતે ઉપલબ્ધ ભૌતિક મેમરીને વિસ્તૃત કરે છે:**

વર્ચ્યુઅલ મેમરીને એક પુલ તરીકે વિચારો કે જે તમારા કમ્પ્યુટરની RAM અને તેના સેકન્ડરી સ્ટોરેજ (ડિસ્ક ડ્રાઇવ્સ) ને જોડે છે. જ્યારે તમે પ્રોગ્રામ ચલાવો છો, ત્યારે તેના ભાગો ઝડપી ભૌતિક મેમરી (RAM) માં લોડ થાય છે. જો કે, પ્રોગ્રામના તમામ ભાગોનો તાત્કાલિક ઉપયોગ કરી શકાતો નથી.

વર્ચ્યુઅલ મેમરી પ્રોગ્રામના એવા વિભાગોને ખસેડીને આ પરિસ્થિતિનું શોષણ કરે છે જે સક્રિય રીતે ઉપયોગમાં લેવાતા નથી તેવા RAM થી ગૌણ સ્ટોરેજમાં સક્રિયપણે ઉપયોગમાં લેવાતા ભાગો માટે RAM માં વધુ જગ્યા બનાવે છે. આ પ્રક્રિયા વપરાશકર્તા અને ચાલી રહેલ પ્રોગ્રામ માટે પારદર્શક છે. જ્યારે ખસેડવામાં આવેલા ભાગોની ફરીથી જરૂર પડે છે, ત્યારે તે ફરીથી RAM માં સ્વેપ કરવામાં આવે છે, જ્યારે અન્ય ઓછા સક્રિય ભાગોને ગૌણ સ્ટોરેજમાં ખસેડવામાં આવી શકે છે.

ભૌતિક મેમરીમાં અને બહાર ડેટાનું આ ગતિશીલ સ્વેપિંગ ઓપરેટિંગ સિસ્ટમ દ્વારા સંચાલિત થાય છે. તે ઉપલબ્ધ રેમ કરતા મોટા હોય તો પણ પ્રોગ્રામ્સને ચલાવવાની મંજૂરી આપે છે, કારણ કે ઓપરેટિંગ સિસ્ટમ બુદ્ધિપૂર્વક નક્કી કરે છે કે શ્રેષ્ઠ કામગીરી માટે RAM માં કયો ડેટા હોવો જોઈએ.

સારાંશમાં, વર્ચ્યુઅલ મેમરી વર્ચ્યુઅલાઈઝેશન લેયર તરીકે કામ કરે છે જે રેમ અને સેકન્ડરી સ્ટોરેજ વચ્ચે પ્રોગ્રામના ભાગો અને ડેટાને અસ્થાયી રૂપે સ્થાનાંતરિત કરીને ઉપલબ્ધ ભૌતિક મેમરીને વિસ્તૃત કરે છે. આ પ્રક્રિયા એ સુનિશ્ચિત કરે છે કે કોમ્પ્યુટર એકસાથે મોટા કાર્યો અને અસંખ્ય પ્રોગ્રામ્સને હેન્ડલ કરી શકે છે, આ બધું કાર્યક્ષમ પ્રદર્શન અને પ્રતિભાવ જાળવી રાખીને.

## [ફાઇલ સિસ્ટમ](File%20System/readme.md)
કમ્પ્યુટિંગમાં, ફાઇલ સિસ્ટમ અથવા ફાઇલસિસ્ટમ (ઘણી વખત સંક્ષિપ્તમાં fs) એ એક પદ્ધતિ અને ડેટા માળખું છે જેનો ઉપયોગ ઓપરેટિંગ સિસ્ટમ ડેટા કેવી રીતે સંગ્રહિત અને પુનઃપ્રાપ્ત કરવામાં આવે છે તે નિયંત્રિત કરવા માટે કરે છે. ફાઇલ સિસ્ટમ વિના, સ્ટોરેજ માધ્યમમાં મૂકવામાં આવેલ ડેટા એ ડેટાનો એક મોટો ભાગ હશે જેમાં એક ડેટાનો ટુકડો ક્યાં અટક્યો અને બીજો શરૂ થયો અથવા જ્યારે તેને પુનઃપ્રાપ્ત કરવાનો સમય હતો ત્યારે ડેટાનો કોઈ ભાગ ક્યાં સ્થિત હતો તે કહેવાની કોઈ રીત નથી. ડેટાને ટુકડાઓમાં વિભાજિત કરીને અને દરેક ભાગને નામ આપીને, ડેટા સરળતાથી અલગ અને ઓળખી શકાય છે. પેપર-આધારિત ડેટા મેનેજમેન્ટ સિસ્ટમનું નામ કેવી રીતે રાખવામાં આવે છે તેના પરથી તેનું નામ લેતા, દરેક ડેટા જૂથને "ફાઇલ" કહેવામાં આવે છે. ડેટાના જૂથો અને તેમના નામોનું સંચાલન કરવા માટે વપરાતા માળખા અને તર્ક નિયમોને "ફાઇલ સિસ્ટમ" કહેવામાં આવે છે.

ત્યાં ઘણી પ્રકારની ફાઇલ સિસ્ટમો છે, જેમાં દરેક અનન્ય માળખું અને તર્ક, ઝડપના ગુણધર્મો, લવચીકતા, સુરક્ષા, કદ અને વધુ છે. કેટલીક ફાઇલ સિસ્ટમો ચોક્કસ એપ્લિકેશનો માટે ઉપયોગમાં લેવા માટે ડિઝાઇન કરવામાં આવી છે. ઉદાહરણ તરીકે, ISO 9660 ફાઇલ સિસ્ટમ ખાસ કરીને ઓપ્ટિકલ ડિસ્ક માટે ડિઝાઇન કરવામાં આવી છે.

ફાઇલ સિસ્ટમનો ઉપયોગ વિવિધ માધ્યમોનો ઉપયોગ કરીને ઘણા પ્રકારના સંગ્રહ ઉપકરણો પર કરી શકાય છે. 2019 સુધીમાં, હાર્ડ ડિસ્ક ડ્રાઈવો મુખ્ય સંગ્રહ ઉપકરણો રહી છે અને નજીકના ભવિષ્ય માટે તે જ રહેવાનો અંદાજ છે. અન્ય પ્રકારના માધ્યમોનો ઉપયોગ થાય છે જેમાં SSD, ચુંબકીય ટેપ અને ઓપ્ટિકલ ડિસ્કનો સમાવેશ થાય છે. કેટલાક કિસ્સાઓમાં, જેમ કે tmpfs સાથે, કમ્પ્યુટરની મુખ્ય મેમરી (રેન્ડમ-એક્સેસ મેમરી, RAM) ટૂંકા ગાળાના ઉપયોગ માટે કામચલાઉ ફાઇલ સિસ્ટમ બનાવે છે.

કેટલીક ફાઇલ સિસ્ટમોનો ઉપયોગ સ્થાનિક ડેટા સ્ટોરેજ ઉપકરણો પર થાય છે; અન્ય નેટવર્ક પ્રોટોકોલ (ઉદાહરણ તરીકે, NFS, SMB, અથવા 9P ક્લાયન્ટ્સ) દ્વારા ફાઇલ ઍક્સેસ પ્રદાન કરે છે. કેટલીક ફાઇલ સિસ્ટમો "વર્ચ્યુઅલ" હોય છે, એટલે કે પૂરી પાડવામાં આવેલ "ફાઈલો" (જેને વર્ચ્યુઅલ ફાઈલો કહેવાય છે) વિનંતી પર ગણતરી કરવામાં આવે છે (જેમ કે procfs અને sysfs) અથવા બેકિંગ સ્ટોર તરીકે ઉપયોગમાં લેવાતી અલગ ફાઇલ સિસ્ટમમાં માત્ર મેપિંગ છે. ફાઇલ સિસ્ટમ ફાઇલોની સામગ્રી અને તે ફાઇલો વિશેના મેટાડેટા બંનેની ઍક્સેસનું સંચાલન કરે છે. તે સ્ટોરેજ સ્પેસ ગોઠવવા માટે જવાબદાર છે; ભૌતિક સંગ્રહ માધ્યમના સંદર્ભમાં વિશ્વસનીયતા, કાર્યક્ષમતા અને ટ્યુનિંગ એ મહત્વપૂર્ણ ડિઝાઇન વિચારણા છે.

### ફાઇલ સિસ્ટમ કેવી રીતે કામ કરે છે
ફાઇલ સિસ્ટમ ડેટાનો સંગ્રહ કરે છે અને તેનું આયોજન કરે છે અને તેને સ્ટોરેજ ડિવાઇસમાં સમાવિષ્ટ તમામ ડેટા માટે ઇન્ડેક્સના પ્રકાર તરીકે વિચારી શકાય છે. આ ઉપકરણોમાં હાર્ડ ડ્રાઇવ્સ, ઓપ્ટિકલ ડ્રાઇવ્સ અને ફ્લેશ ડ્રાઇવ્સ શામેલ હોઈ શકે છે.

ફાઈલ સિસ્ટમો નામમાં અક્ષરોની મહત્તમ સંખ્યા, કયા અક્ષરોનો ઉપયોગ કરી શકાય અને કેટલીક સિસ્ટમોમાં, ફાઈલ નામનો પ્રત્યય કેટલો લાંબો હોઈ શકે તે સહિત, ફાઈલોના નામકરણ માટેના નિયમોનો ઉલ્લેખ કરે છે. ઘણી ફાઇલ સિસ્ટમોમાં, ફાઇલના નામ કેસ-સંવેદનશીલ હોતા નથી.

ફાઇલની સાથે જ, ફાઇલ સિસ્ટમમાં મેટાડેટાની ડિરેક્ટરીમાં ફાઇલનું કદ અને તેના લક્ષણો, સ્થાન અને વંશવેલો જેવી માહિતી હોય છે. મેટાડેટા ડ્રાઇવ પર ઉપલબ્ધ સ્ટોરેજના ફ્રી બ્લોક્સ અને કેટલી જગ્યા ઉપલબ્ધ છે તે પણ ઓળખી શકે છે.

ફાઇલ સિસ્ટમમાં ડિરેક્ટરીઓની રચના દ્વારા ફાઇલના પાથને સ્પષ્ટ કરવા માટેનું ફોર્મેટ પણ શામેલ છે. ફાઇલને ડિરેક્ટરીમાં - અથવા Windows OS માં ફોલ્ડરમાં - અથવા ટ્રી સ્ટ્રક્ચરમાં ઇચ્છિત સ્થાન પર સબડિરેક્ટરીમાં મૂકવામાં આવે છે. પીસી અને મોબાઇલ ઓએસમાં ફાઇલ સિસ્ટમ્સ હોય છે જેમાં ફાઇલોને હાયરાર્કિકલ ટ્રી સ્ટ્રક્ચરમાં મૂકવામાં આવે છે.

સંગ્રહ માધ્યમ પર ફાઈલો અને ડિરેક્ટરીઓ બનાવવામાં આવે તે પહેલાં, પાર્ટીશનો મુકવા જોઈએ. પાર્ટીશન એ હાર્ડ ડિસ્ક અથવા અન્ય સ્ટોરેજનો વિસ્તાર છે જે OS અલગથી મેનેજ કરે છે. પ્રાથમિક પાર્ટીશનમાં એક ફાઇલ સિસ્ટમ સમાયેલ છે, અને કેટલાક OS એક ડિસ્ક પર બહુવિધ પાર્ટીશનો માટે પરવાનગી આપે છે. આ સ્થિતિમાં, જો એક ફાઈલ સિસ્ટમ દૂષિત થઈ જાય, તો અલગ પાર્ટીશનમાંનો ડેટા સુરક્ષિત રહેશે.

### ફાઇલ સિસ્ટમના પ્રકારો
ત્યાં ઘણી પ્રકારની ફાઇલ સિસ્ટમો છે, જે બધી વિવિધ લોજિકલ સ્ટ્રક્ચર્સ અને ગુણધર્મો સાથે છે, જેમ કે ઝડપ અને કદ. ફાઇલ સિસ્ટમનો પ્રકાર OS અને તે OS ની જરૂરિયાતો દ્વારા અલગ હોઈ શકે છે. માઈક્રોસોફ્ટ વિન્ડોઝ, મેક ઓએસ એક્સ અને લિનક્સ એ ત્રણ સૌથી સામાન્ય પીસી ઓપરેટિંગ સિસ્ટમ છે. મોબાઇલ ઓએસમાં Apple iOS અને Google Androidનો સમાવેશ થાય છે.

મુખ્ય ફાઇલ સિસ્ટમમાં નીચેનાનો સમાવેશ થાય છે:

- ફાઈલ એલોકેશન ટેબલ (FAT) Microsoft Windows OS દ્વારા સપોર્ટેડ છે. FAT ને સરળ અને ભરોસાપાત્ર ગણવામાં આવે છે અને લેગસી ફાઇલ સિસ્ટમ્સ પછી મોડેલ કરવામાં આવે છે. FAT 1977 માં ફ્લોપી ડિસ્ક માટે ડિઝાઇન કરવામાં આવી હતી પરંતુ પછીથી તેને હાર્ડ ડિસ્ક માટે સ્વીકારવામાં આવી હતી. મોટાભાગના વર્તમાન OS સાથે કાર્યક્ષમ અને સુસંગત હોવા છતાં, FAT વધુ આધુનિક ફાઇલ સિસ્ટમ્સના પ્રદર્શન અને માપનીયતા સાથે મેળ ખાતું નથી.

- ગ્લોબલ ફાઇલ સિસ્ટમ (GFS) એ Linux OS માટે ફાઇલ સિસ્ટમ છે, અને તે એક શેર્ડ ડિસ્ક ફાઇલ સિસ્ટમ છે. GFS વહેંચાયેલ બ્લોક સ્ટોરેજની સીધી ઍક્સેસ પ્રદાન કરે છે અને સ્થાનિક ફાઇલ સિસ્ટમ તરીકે ઉપયોગ કરી શકાય છે.

- GFS2 એ મૂળ GFS માં સમાવિષ્ટ ન હોય તેવા લક્ષણો સાથેનું અપડેટેડ વર્ઝન છે, જેમ કે અપડેટેડ મેટાડેટા સિસ્ટમ. GNU જનરલ પબ્લિક લાઇસન્સ શરતો હેઠળ, GFS અને GFS2 ફાઇલ સિસ્ટમ્સ બંને મફત સોફ્ટવેર તરીકે ઉપલબ્ધ છે.

- હાયરાર્કિકલ ફાઇલ સિસ્ટમ (HFS) મેક ઓપરેટિંગ સિસ્ટમ્સ સાથે ઉપયોગ માટે વિકસાવવામાં આવી હતી. HFS ને Mac OS સ્ટાન્ડર્ડ પણ કહી શકાય, Mac OS Extended દ્વારા સફળ. મૂળરૂપે 1985માં ફ્લોપી અને હાર્ડ ડિસ્ક માટે રજૂ કરવામાં આવ્યું હતું, HFS એ મૂળ મેકિન્ટોશ ફાઇલ સિસ્ટમનું સ્થાન લીધું હતું. તેનો ઉપયોગ CD-ROM પર પણ થઈ શકે છે.

- NT ફાઇલ સિસ્ટમ -- જેને ન્યૂ ટેક્નોલોજી ફાઇલ સિસ્ટમ (NTFS) તરીકે પણ ઓળખવામાં આવે છે -- તે Windows NT 3.1 OS થી આગળના વિન્ડોઝ ઉત્પાદનો માટે ડિફોલ્ટ ફાઇલ સિસ્ટમ છે. અગાઉની FAT ફાઇલ સિસ્ટમના સુધારાઓમાં બહેતર મેટાડેટા સપોર્ટ, પ્રદર્શન અને ડિસ્ક સ્પેસનો ઉપયોગ શામેલ છે. એનટીએફએસ એ ફ્રી, ઓપન સોર્સ એનટીએફએસ ડ્રાઈવર દ્વારા Linux OS માં પણ સપોર્ટેડ છે. Mac OSes પાસે NTFS માટે માત્ર વાંચવા માટેનો આધાર છે.

- યુનિવર્સલ ડિસ્ક ફોર્મેટ (UDF) એ ઓપ્ટિકલ મીડિયા અને ડીવીડી માટે વિક્રેતા-તટસ્થ ફાઇલ સિસ્ટમ છે. UDF એ ISO 9660 ફાઇલ સિસ્ટમનું સ્થાન લે છે અને DVD ફોરમ દ્વારા પસંદ કરાયેલ ડીવીડી વિડિયો અને ઑડિયો માટેની અધિકૃત ફાઇલ સિસ્ટમ છે.

## [ક્લાઉડ કમ્પ્યુટિંગ](Cloud%20Computing/Readme.md)
ક્લાઉડ કમ્પ્યુટિંગ એ ઇન્ટરનેટ પર માહિતી અને એપ્લિકેશનને ઍક્સેસ કરવાની ક્ષમતા છે. ક્લાઉડ કમ્પ્યુટિંગ વપરાશકર્તાઓને ઇન્ટરનેટ કનેક્શન સાથે કોઈપણ સ્થાનથી એપ્લિકેશન અને ડેટાને ઍક્સેસ કરવાની મંજૂરી આપે છે.

ક્લાઉડ કમ્પ્યુટિંગ એ ઇન્ટરનેટ-આધારિત કમ્પ્યુટિંગનો એક પ્રકાર છે જે માંગ પર કમ્પ્યુટર અને અન્ય ઉપકરણોને વહેંચાયેલ કમ્પ્યુટર પ્રોસેસિંગ સંસાધનો અને ડેટા પ્રદાન કરે છે.

તે રૂપરેખાંકિત કમ્પ્યુટિંગ સંસાધનો (દા.ત. નેટવર્ક્સ, સર્વર્સ, સ્ટોરેજ, એપ્લીકેશન્સ અને સેવાઓ) ના વહેંચાયેલ પૂલ માટે સર્વવ્યાપક, અનુકૂળ, માંગ પર નેટવર્ક ઍક્સેસને સક્ષમ કરવા માટેનું એક મોડેલ છે જે ન્યૂનતમ સંચાલન પ્રયત્નો અથવા સેવા સાથે ઝડપથી જોગવાઈ અને રિલીઝ કરી શકાય છે. પ્રદાતાની ક્રિયાપ્રતિક્રિયા.
 
 ## ક્લાઉડ કમ્પ્યુટિંગના ટોચના ફાયદા
 
ક્લાઉડ કમ્પ્યુટિંગ એ IT સંસાધનો વિશે વ્યવસાયો કેવી રીતે વિચારે છે તેમાંથી એક મોટું પરિવર્તન છે. સંસ્થાઓ ક્લાઉડ કમ્પ્યુટિંગ સેવાઓ તરફ વળે છે તેના સાત સામાન્ય કારણો અહીં છે:


ખર્ચ
ક્લાઉડ કમ્પ્યુટિંગ હાર્ડવેર અને સૉફ્ટવેર ખરીદવા અને ઑન-સાઇટ ડેટા સેન્ટર સેટ કરવા અને ચલાવવાના મૂડી ખર્ચને દૂર કરે છે - સર્વર્સના રેક્સ, પાવર અને કૂલિંગ માટે રાઉન્ડ-ધ-ક્લોક વીજળી અને ઇન્ફ્રાસ્ટ્રક્ચરનું સંચાલન કરવા માટે IT નિષ્ણાતો. તે ઝડપથી ઉમેરે છે.


ઝડપ
મોટાભાગની ક્લાઉડ કમ્પ્યુટિંગ સેવાઓ સ્વ-સેવા અને માંગ પર પૂરી પાડવામાં આવે છે, તેથી ગણતરીના સંસાધનોની વિશાળ માત્રા પણ મિનિટોમાં જોગવાઈ કરી શકાય છે, સામાન્ય રીતે માત્ર થોડી માઉસ ક્લિક્સ સાથે, વ્યવસાયોને ઘણી રાહત આપે છે અને ક્ષમતા આયોજનના દબાણને દૂર કરે છે.


વૈશ્વિક સ્કેલ
ક્લાઉડ કમ્પ્યુટિંગ સેવાઓના ફાયદાઓમાં સ્થિતિસ્થાપક રીતે માપવાની ક્ષમતાનો સમાવેશ થાય છે. ક્લાઉડ સ્પીકમાં, તેનો અર્થ એ છે કે યોગ્ય માત્રામાં IT સંસાધનો-ઉદાહરણ તરીકે, વધુ કે ઓછા કમ્પ્યુટિંગ પાવર, સ્ટોરેજ અને બેન્ડવિડ્થ-જરૂરિયાત હોય ત્યારે અને યોગ્ય ભૌગોલિક સ્થાનથી પહોંચાડવી.


ઉત્પાદકતા
ઑન-સાઇટ ડેટા સેન્ટરોને સામાન્ય રીતે ઘણાં "રેકિંગ અને સ્ટેકીંગ"ની જરૂર પડે છે - હાર્ડવેર સેટઅપ, સોફ્ટવેર પેચિંગ અને અન્ય સમય માંગી લેનારા IT મેનેજમેન્ટ કામો. ક્લાઉડ કમ્પ્યુટિંગ આમાંના ઘણા કાર્યોની જરૂરિયાતને દૂર કરે છે, તેથી IT ટીમો વધુ મહત્વપૂર્ણ વ્યવસાય લક્ષ્યોને પ્રાપ્ત કરવા માટે સમય પસાર કરી શકે છે.

પ્રદર્શન
સૌથી મોટી ક્લાઉડ કમ્પ્યુટિંગ સેવાઓ સુરક્ષિત ડેટા સેન્ટર્સના વિશ્વવ્યાપી નેટવર્ક પર ચાલે છે, જે ઝડપી અને કાર્યક્ષમ કમ્પ્યુટિંગ હાર્ડવેરની નવીનતમ પેઢીમાં નિયમિતપણે અપગ્રેડ થાય છે. આ એક જ કોર્પોરેટ ડેટા સેન્ટર પર ઘણા લાભો પ્રદાન કરે છે, જેમાં એપ્લિકેશન માટે નેટવર્ક લેટન્સીમાં ઘટાડો અને સ્કેલની મોટી અર્થવ્યવસ્થાનો સમાવેશ થાય છે.


વિશ્વસનીયતા
ક્લાઉડ કમ્પ્યુટિંગ ડેટા બેકઅપ, આપત્તિ પુનઃપ્રાપ્તિ અને વ્યવસાય સાતત્યને સરળ અને ઓછા ખર્ચાળ બનાવે છે કારણ કે ક્લાઉડ પ્રદાતાના નેટવર્ક પર બહુવિધ રીડન્ડન્ટ સાઇટ્સ પર ડેટા પ્રતિબિંબિત કરી શકાય છે.


સુરક્ષા
ઘણા ક્લાઉડ પ્રદાતાઓ નીતિઓ, ટેક્નોલોજીઓ અને નિયંત્રણોનો વ્યાપક સેટ ઑફર કરે છે જે એકંદરે તમારી સુરક્ષા સ્થિતિને મજબૂત બનાવે છે, તમારા ડેટા, એપ્લિકેશનો અને ઇન્ફ્રાસ્ટ્રક્ચરને સંભવિત જોખમોથી સુરક્ષિત કરવામાં મદદ કરે છે.

### ક્લાઉડ કમ્પ્યુટિંગ સેવાઓના પ્રકાર
- [ઇન્ફ્રાસ્ટ્રક્ચર એઝ એ ​​સર્વિસ (IaaS)](Cloud%20Computing/Readme.md#infrastructure-as-a-service-iaas)
- [સેવા તરીકે પ્લેટફોર્મ (PaaS)](Cloud%20Computing/Readme.md#platform-as-a-service-paas)
- [સોફ્ટવેર એઝ એ ​​સર્વિસ (સાસ)](Cloud%20Computing/Readme.md#software-as-a-service-saas)

## [મશીન લર્નિંગ]()
મશીન લર્નિંગ એ કમ્પ્યુટરને શીખવા માટે શીખવવાની પ્રથા છે. આવનારા ડેટા પર ચુકાદો આપવા માટે આ ખ્યાલ પેટર્ન ઓળખ, તેમજ અનુમાનિત અલ્ગોરિધમ્સના અન્ય સ્વરૂપોનો ઉપયોગ કરે છે. આ ક્ષેત્ર કૃત્રિમ બુદ્ધિમત્તા અને કોમ્પ્યુટેશનલ આંકડાઓ સાથે ગાઢ રીતે સંબંધિત છે.

### મશીન લર્નિંગની ત્રણ પેટા કેટેગરી છે:

### નિરીક્ષણ કરેલ મશીન લર્નિંગ
આમાં, મશીન લર્નિંગ મોડલ્સને લેબલવાળા ડેટા સેટ સાથે તાલીમ આપવામાં આવે છે, જે મોડલને સમય સાથે વધુ સચોટ રીતે શીખવા અને વિકાસ કરવાની મંજૂરી આપે છે. ઉદાહરણ તરીકે, એક અલ્ગોરિધમને શ્વાન અને અન્ય વસ્તુઓના ચિત્રો સાથે પ્રશિક્ષિત કરવામાં આવશે, જે બધાને મનુષ્યો દ્વારા લેબલ કરવામાં આવ્યા છે, અને મશીન તેના પોતાના પર કૂતરાઓના ચિત્રોને ઓળખવાની રીતો શીખશે. સુપરવાઇઝ્ડ મશીન લર્નિંગ એ આજે ​​ઉપયોગમાં લેવાતો સૌથી સામાન્ય પ્રકાર છે.

નિરીક્ષિત શિક્ષણની પ્રાયોગિક એપ્લિકેશનો -
1. **બાયોઇન્ફોર્મેટિક્સ:** બાયોઇન્ફોર્મેટિક્સ એ અભ્યાસ છે કે કેવી રીતે વ્યક્તિઓ જૈવિક જ્ઞાન જેમ કે ફિંગરપ્રિન્ટ્સ, આંખની રચના, કાનની નળીઓ વગેરે જાળવી રાખે છે. મોબાઈલ ફોન હવે આપણા જૈવિક ડેટાને સમજવા માટે અને પછી સિસ્ટમ સુરક્ષા વધારવા માટે અમને ચકાસવા માટે પૂરતા હોંશિયાર છે.
2. **વાણી ઓળખ:** તે પ્રોગ્રામનો પ્રકાર છે જ્યાં તમે તમારો અવાજ પ્રોગ્રામ સુધી પહોંચાડી શકો છો અને તે તમને ઓળખશે. સૌથી વધુ જાણીતા વાસ્તવિક-વિશ્વ ગેજેટ્સ એ ડિજિટલ સહાયકો છે જેમ કે Google સહાયક અથવા સિરી, જે ફક્ત તમારા અવાજથી જ શબ્દનો પ્રતિસાદ આપે છે.
3. **સ્પામ શોધ:** આ સાધનનો ઉપયોગ કાલ્પનિક અથવા મશીન-આધારિત સંચારને મોકલવામાં આવતા અટકાવવા માટે થાય છે. Gmail માં એક અલ્ગોરિધમનો સમાવેશ થાય છે જે અસંખ્ય ખોટા શબ્દો શીખે છે. વનપ્લસ મેસેજીસ એપ યુઝરને એ સ્પષ્ટ કરવા કહે છે કે કયા શબ્દો પ્રતિબંધિત હોવા જોઈએ અને કીવર્ડ એપમાંથી આવા ટેક્સ્ટને અટકાવશે.
4. **દ્રષ્ટિ માટે ઑબ્જેક્ટ રેકગ્નિશન:** જ્યારે તમારે કંઈપણ વ્યાખ્યાયિત કરવું હોય ત્યારે આ પ્રકારના સોફ્ટવેરનો ઉપયોગ કરવામાં આવે છે. તમારી પાસે એક મોટો ડેટાસેટ છે જેનો ઉપયોગ તમે અલ્ગોરિધમને તાલીમ આપવા માટે કરો છો, અને તે આનો ઉપયોગ કરીને નવા ઑબ્જેક્ટને ઓળખી શકે છે.

### અસુરક્ષિત મશીન લર્નિંગ
અનસુપરવાઇઝ્ડ મશીન લર્નિંગમાં, પ્રોગ્રામ લેબલ વગરના ડેટામાં પેટર્ન શોધે છે. દેખરેખ વિનાનું મશીન લર્નિંગ એવા દાખલાઓ અથવા વલણો શોધી શકે છે જે લોકો સ્પષ્ટપણે શોધી રહ્યાં નથી. ઉદાહરણ તરીકે, અસુરક્ષિત મશીન લર્નિંગ પ્રોગ્રામ ઓનલાઈન વેચાણ ડેટા જોઈ શકે છે અને ખરીદી કરતા વિવિધ પ્રકારના ગ્રાહકોને ઓળખી શકે છે.

અસુરક્ષિત શિક્ષણની પ્રાયોગિક એપ્લિકેશનો
1. **ક્લસ્ટરિંગ:** ક્લસ્ટરિંગ એ ડેટાને અલગ-અલગ જૂથોમાં વર્ગીકૃત કરવાની પ્રક્રિયા છે. જ્યારે આપણે ક્લસ્ટરો વિશેની તમામ વિગતો જાણતા નથી, ત્યારે અમે તેમને ક્લસ્ટર કરવા માટે બિનનિરીક્ષણ કરેલ શિક્ષણનો ઉપયોગ કરી શકીએ છીએ. અસુપરવાઇઝ્ડ લર્નિંગનો ઉપયોગ એવા ડેટાનું પૃથ્થકરણ અને આયોજન કરવા માટે થાય છે કે જેમાં પ્રી-લેબલવાળા વર્ગો અથવા વર્ગ ગુણધર્મો નથી. ક્લસ્ટરિંગ કંપનીઓને તેમના ડેટાને વધુ અસરકારક રીતે હેન્ડલ કરવામાં મદદ કરી શકે છે.
ધારો કે તમારી પાસે YouTube ચેનલ છે. તમારી પાસે તમારા સબ્સ્ક્રાઇબર્સ પર ઘણી બધી માહિતી હોઈ શકે છે. જો તમે સમાન સબ્સ્ક્રાઇબર્સ શોધવા માંગતા હો, તો તમારે ક્લસ્ટરિંગ તકનીકનો ઉપયોગ કરવાની જરૂર પડશે.
2. **વિઝ્યુલાઇઝેશન:** માહિતી પ્રસ્તુત કરવા માટે આકૃતિઓ, ફોટા, આલેખ, ચાર્ટ વગેરે બનાવવાની પ્રક્રિયાને વિઝ્યુલાઇઝેશન તરીકે ઓળખવામાં આવે છે. આ વ્યૂહરચના અમલમાં મૂકવા માટે અસુરક્ષિત મશીન લર્નિંગનો ઉપયોગ કરી શકાય છે.
ધારો કે તમે ટૂર્નામેન્ટમાં તમારી ટીમના પ્રદર્શનને લગતી માહિતી સાથે ક્રિકેટ કોચ છો. તમે મેચના તમામ આંકડા ઝડપથી શોધી શકો છો. તમે લેબલ વગરના અને જટિલ ડેટાને વિઝ્યુલાઇઝેશન અલ્ગોરિધમમાં પાસ કરી શકો છો.
3. **વિસંગતતા શોધ:** વિસંગતતા શોધ એ અસામાન્ય વસ્તુઓ, ઘટનાઓ અથવા અવલોકનોની શોધ છે જે નિયમિત ડેટામાંથી મોટા પ્રમાણમાં વિચલિત થઈને શંકા પેદા કરે છે. આ પરિસ્થિતિમાં, સિસ્ટમને મોટી સંખ્યામાં લાક્ષણિક કેસ સાથે પ્રોગ્રામ કરવામાં આવે છે. પરિણામે, જ્યારે તે કોઈ અણધારી ઘટના શોધે છે, ત્યારે તે નક્કી કરી શકે છે કે તે વિસંગતતા છે કે નહીં.
ક્રેડિટ કાર્ડ ફ્રોડ ડિટેક્શન આનું સારું ઉદાહરણ છે. આ સમસ્યાને હવે દેખરેખ વિનાના મશીન લર્નિંગ વિસંગતતા શોધ અભિગમોનો ઉપયોગ કરીને સંબોધવામાં આવી રહી છે. છેતરપિંડી ટાળવા માટે, સિસ્ટમ અનપેક્ષિત ક્રેડિટ કાર્ડ વ્યવહારોને ઓળખે છે.

### અર્ધ-નિરીક્ષણ કરેલ મશીન લર્નિંગ
નિરીક્ષિત શિક્ષણનો ગેરલાભ એ છે કે તેને ML નિષ્ણાતો અથવા ડેટા વૈજ્ઞાનિકો દ્વારા હાથથી લેબલિંગની જરૂર પડે છે અને પ્રક્રિયા કરવા માટે ઊંચી કિંમતની જરૂર પડે છે. દેખરેખ વિનાના શિક્ષણમાં તેની એપ્લિકેશનો માટે મર્યાદિત સ્પેક્ટ્રમ પણ છે. નિરીક્ષિત શિક્ષણ અને અસુપરવાઇઝ્ડ લર્નિંગ એલ્ગોરિધમ્સની આ ખામીઓને દૂર કરવા માટે, અર્ધ-નિરીક્ષિત શિક્ષણની વિભાવના રજૂ કરવામાં આવી છે. સામાન્ય રીતે, આ સંયોજનમાં લેબલ થયેલ ડેટાની ખૂબ જ નાની માત્રા અને લેબલ વગરના ડેટાની મોટી માત્રા હોય છે. તેમાં સામેલ મૂળભૂત પ્રક્રિયા એ છે કે સૌપ્રથમ, પ્રોગ્રામર અસુપરવાઇઝ્ડ લર્નિંગ અલ્ગોરિધમનો ઉપયોગ કરીને સમાન ડેટાને ક્લસ્ટર કરશે અને પછી બાકીના લેબલ વગરના ડેટાને લેબલ કરવા માટે હાલના લેબલવાળા ડેટાનો ઉપયોગ કરશે.

અર્ધ-નિરીક્ષણ કરેલ શિક્ષણની વ્યવહારુ એપ્લિકેશનો -
1. **સ્પીચ એનાલિસિસ:** ઓડિયો ફાઈલોનું લેબલીંગ ખૂબ જ સઘન કાર્ય હોવાથી, અર્ધ-નિરીક્ષિત શિક્ષણ એ આ સમસ્યાને ઉકેલવા માટે ખૂબ જ કુદરતી અભિગમ છે.
2. **ઇન્ટરનેટ સામગ્રી:** વર્ગીકરણ: દરેક વેબપેજને લેબલ કરવું એ એક અવ્યવહારુ અને અવ્યવહારુ પ્રક્રિયા છે અને આ રીતે અર્ધ-નિરીક્ષિત લર્નિંગ અલ્ગોરિધમ્સનો ઉપયોગ કરે છે. Google શોધ અલ્ગોરિધમ પણ આપેલ ક્વેરી માટે વેબપેજની સુસંગતતાને ક્રમ આપવા માટે અર્ધ-નિરીક્ષણ કરેલ શિક્ષણના વિવિધ પ્રકારનો ઉપયોગ કરે છે.
3. **પ્રોટીન સિક્વન્સ વર્ગીકરણ:** ડીએનએ સેર સામાન્ય રીતે ખૂબ મોટી હોવાથી, અર્ધ-નિરીક્ષિત શિક્ષણનો ઉદય આ ક્ષેત્રમાં નિકટવર્તી રહ્યો છે.

### મજબૂતીકરણ મશીન શિક્ષણ
આ પુરસ્કાર પ્રણાલી સ્થાપિત કરીને શ્રેષ્ઠ પગલાં લેવા માટે અજમાયશ અને ભૂલ દ્વારા મશીનોને તાલીમ આપે છે. રિઇન્ફોર્સમેન્ટ લર્નિંગ મૉડલોને ગેમ રમવા માટે તાલીમ આપી શકે છે અથવા મશીનને યોગ્ય નિર્ણયો લે છે ત્યારે તે કહીને ડ્રાઇવિંગ કરવાની તાલીમ આપી શકે છે, જે તેને સમય જતાં શીખવામાં મદદ કરે છે કે તેણે કઈ ક્રિયાઓ કરવી જોઈએ.

રિઇન્ફોર્સમેન્ટ લર્નિંગના વ્યવહારુ ઉપયોગો -
1. **ઉત્પાદન પ્રણાલીઓ**
   દા.ત. Google Cloud AutoML, Facebook Horizon, Recommendation, advertisement, search
2. **ઓટોનોમસ ડ્રાઇવિંગ**
3. **બિઝનેસ મેનેજમેન્ટ**
   દા.ત. વાહન રૂટીંગની સમસ્યાનું નિરાકરણ, ઈ-કોમર્સમાં કપટપૂર્ણ વર્તન, ગ્રાહકની ક્રિયાપ્રતિક્રિયાઓમાંથી સમવર્તી મજબૂતીકરણ શીખવું
4. **સુઝાવ આપનાર સિસ્ટમો**
   દા.ત. શોધ, ભલામણ અને ઑનલાઇન જાહેરાત માટે
   
### મશીન લર્નિંગ અન્ય કેટલાક આર્ટિફિશિયલ ઇન્ટેલિજન્સ સબફિલ્ડ્સ સાથે પણ સંકળાયેલું છે:

### કુદરતી ભાષા પ્રક્રિયા

નેચરલ લેંગ્વેજ પ્રોસેસિંગ એ મશીન લર્નિંગનું એક ક્ષેત્ર છે જેમાં મશીનો સામાન્ય રીતે કમ્પ્યુટરને પ્રોગ્રામ કરવા માટે ઉપયોગમાં લેવાતા ડેટા અને નંબરોને બદલે માનવો દ્વારા બોલાતી અને લખેલી કુદરતી ભાષાને સમજવાનું શીખે છે. આનાથી મશીનો ભાષાને ઓળખી શકે છે, તેને સમજી શકે છે અને તેનો પ્રતિસાદ આપી શકે છે, સાથે સાથે નવું લખાણ બનાવી શકે છે અને ભાષાઓ વચ્ચે અનુવાદ કરી શકે છે. નેચરલ લેંગ્વેજ પ્રોસેસિંગ ચેટબોટ્સ અને સિરી અથવા એલેક્સા જેવા ડિજિટલ સહાયકો જેવી પરિચિત તકનીકને સક્ષમ કરે છે.

NLP ની પ્રાયોગિક એપ્લિકેશનો:
1. **પ્રશ્નનો જવાબ:** પ્રશ્નના જવાબો એ બિલ્ડીંગ સિસ્ટમ્સ પર ધ્યાન કેન્દ્રિત કરે છે જે કુદરતી ભાષામાં મનુષ્ય દ્વારા પૂછવામાં આવેલા પ્રશ્નોના આપમેળે જવાબ આપે છે.
2. **સ્પામ શોધ:** સ્પામ શોધનો ઉપયોગ વપરાશકર્તાના ઇનબોક્સમાં આવતા અનિચ્છનીય ઈ-મેઈલ શોધવા માટે થાય છે.
3. **સેન્ટિમેન્ટ એનાલિસિસ:** સેન્ટિમેન્ટ એનાલિસિસને ઓપિનિયન માઇનિંગ તરીકે પણ ઓળખવામાં આવે છે. તેનો ઉપયોગ વેબ પર મોકલનારના વલણ, વર્તન અને ભાવનાત્મક સ્થિતિનું વિશ્લેષણ કરવા માટે થાય છે. આ એપ્લિકેશન NLP (નેચરલ લેંગ્વેજ પ્રોસેસિંગ) અને આંકડાઓના સંયોજન દ્વારા ટેક્સ્ટને મૂલ્યો (સકારાત્મક, નકારાત્મક અથવા કુદરતી) સોંપીને અને સંદર્ભના મૂડ (ખુશ, ઉદાસી, ગુસ્સો, વગેરે) ને ઓળખીને અમલમાં મૂકવામાં આવે છે.
4. **મશીન ટ્રાન્સલેશન:** મશીન ટ્રાન્સલેશનનો ઉપયોગ ટેક્સ્ટ અથવા વાણીને એક પ્રાકૃતિક ભાષામાંથી બીજી કુદરતી ભાષામાં અનુવાદ કરવા માટે થાય છે. દા.ત. ગૂગલ અનુવાદ
5. **જોડણી સુધારણા:** માઈક્રોસોફ્ટ કોર્પોરેશન સ્પેલિંગ સુધારણા માટે એમએસ-વર્ડ અને પાવરપોઈન્ટ જેવા વર્ડ પ્રોસેસર સોફ્ટવેર પ્રદાન કરે છે.

### ન્યુરલ નેટવર્ક્સ

ન્યુરલ નેટવર્ક એ સામાન્ય રીતે ઉપયોગમાં લેવાતા, મશીન લર્નિંગ અલ્ગોરિધમનો ચોક્કસ વર્ગ છે. કૃત્રિમ ન્યુરલ નેટવર્ક્સ માનવ મગજ પર આધારિત છે, જેમાં હજારો અથવા લાખો પ્રોસેસિંગ નોડ્સ એકબીજા સાથે જોડાયેલા છે અને સ્તરોમાં ગોઠવાયેલા છે.

કૃત્રિમ ન્યુરલ નેટવર્કમાં, કોષો અથવા ગાંઠો જોડાયેલા હોય છે, દરેક કોષની પ્રક્રિયા ઇનપુટ્સ સાથે થાય છે અને આઉટપુટ ઉત્પન્ન કરે છે જે અન્ય ચેતાકોષોને મોકલવામાં આવે છે. લેબલ થયેલ ડેટા ગાંઠો અથવા કોષો દ્વારા ફરે છે, જેમાં દરેક કોષ એક અલગ કાર્ય કરે છે. ચિત્રમાં બિલાડી છે કે નહીં તે ઓળખવા માટે પ્રશિક્ષિત ન્યુરલ નેટવર્કમાં, વિવિધ ગાંઠો માહિતીનું મૂલ્યાંકન કરશે અને આઉટપુટ પર પહોંચશે જે દર્શાવે છે કે ચિત્રમાં બિલાડી છે કે કેમ.

ન્યુરલ નેટવર્ક્સની પ્રાયોગિક એપ્લિકેશન્સ:
1. **સ્ટૉક માર્કેટ અનુમાન:** રીઅલ-ટાઇમમાં સફળ સ્ટોક અનુમાન કરવા માટે, મલ્ટિલેયર પરસેપ્ટ્રોન MLP (ફીડફોરવર્ડ આર્ટિફિશિયલ ઇન્ટેલિજન્સ અલ્ગોરિધમનો વર્ગ) નો ઉપયોગ કરવામાં આવે છે. MLP નોડ્સના બહુવિધ સ્તરોનો સમાવેશ કરે છે, અને આ દરેક સ્તરો અનુગામી ગાંઠો સાથે સંપૂર્ણ રીતે જોડાયેલા છે. MLP મોડલ બનાવવા માટે સ્ટોકનું ભૂતકાળનું પ્રદર્શન, વાર્ષિક વળતર અને બિન-નફાકારક ગુણોત્તર ધ્યાનમાં લેવામાં આવે છે.
2. **સોશિયલ મીડિયા:** મલ્ટિ-લેયર પરસેપ્ટ્રન્સ સોશિયલ મીડિયાના વલણોની આગાહી કરે છે. તે વિવિધ તાલીમ પદ્ધતિઓનો ઉપયોગ કરે છે જેમ કે મીન એબ્સોલ્યુટ એરર (MAE), રૂટ મીન સ્ક્વેર્ડ એરર (RMSE), અને મીન સ્ક્વેર્ડ એરર (MSE). MLP ઘણા પરિબળોને ધ્યાનમાં લે છે જેમ કે વપરાશકર્તાના મનપસંદ Instagram પૃષ્ઠો, બુકમાર્ક કરેલી પસંદગીઓ વગેરે. સોશિયલ મીડિયા નેટવર્ક દ્વારા વ્યક્તિઓના વર્તનનું વિશ્લેષણ કર્યા પછી, ડેટાને લોકોની ખર્ચની આદતો સાથે લિંક કરી શકાય છે. MLP ANN નો ઉપયોગ સોશિયલ મીડિયા એપ્લિકેશન્સમાંથી ડેટાને ખાણ કરવા માટે થાય છે.
3. **એરોસ્પેસ:** એરોસ્પેસ એન્જીનીયરીંગ એ એક વિસ્તૃત શબ્દ છે જે અવકાશયાન અને વિમાનના વિકાસને આવરી લે છે. ફોલ્ટ નિદાન, ઉચ્ચ-પ્રદર્શન ઓટો-પાયલોટિંગ, એરક્રાફ્ટ કંટ્રોલ સિસ્ટમ્સને સુરક્ષિત કરવું અને કી ડાયનેમિક સિમ્યુલેશનનું મોડેલિંગ એ કેટલાક મુખ્ય ક્ષેત્રો છે જે ન્યુરલ નેટવર્ક્સે કબજે કર્યા છે. સમય વિલંબ બિન-રેખીય સમય ગતિશીલ સિસ્ટમોના મોડેલિંગ માટે ન્યુરલ નેટવર્કનો ઉપયોગ કરી શકાય છે.

### ઊંડું શિક્ષણ

ડીપ લર્નિંગ નેટવર્ક્સ ઘણા સ્તરો સાથે ન્યુરલ નેટવર્ક છે. સ્તરીય નેટવર્ક વ્યાપક માત્રામાં ડેટા પર પ્રક્રિયા કરી શકે છે અને નેટવર્કમાં દરેક લિંકનું "વજન" નક્કી કરી શકે છે — ઉદાહરણ તરીકે, ઇમેજ રેકગ્નિશન સિસ્ટમમાં, ન્યુરલ નેટવર્કના કેટલાક સ્તરો ચહેરાના વ્યક્તિગત લક્ષણો, જેમ કે આંખો, નાક, શોધી શકે છે. અથવા મોં, જ્યારે અન્ય સ્તર એ કહી શકશે કે શું તે લક્ષણો ચહેરાને સૂચવે છે તે રીતે દેખાય છે.

ડીપ લર્નિંગના વ્યવહારુ ઉપયોગો:
1. **ઓટોમેટિક ટેક્સ્ટ જનરેશન –** ટેક્સ્ટનો કોર્પસ શીખવામાં આવે છે, અને આ મોડેલમાંથી, શબ્દ-બાય-શબ્દ અથવા અક્ષર-દર-પાત્ર દ્વારા નવું લખાણ જનરેટ થાય છે. પછી આ મોડેલ જોડણી, વિરામચિહ્ન અને વાક્યો કેવી રીતે બનાવવું તે શીખવામાં સક્ષમ છે અથવા તે શૈલીને પણ કેપ્ચર કરી શકે છે.
2. **આરોગ્ય સંભાળ –** વિવિધ રોગોનું નિદાન કરવામાં અને તેની સારવાર કરવામાં મદદ કરે છે.
3. **ઓટોમેટિક મશીન ટ્રાન્સલેશન –** એક ભાષાના અમુક શબ્દો, વાક્યો અથવા શબ્દસમૂહો બીજી ભાષામાં રૂપાંતરિત થાય છે (ડીપ લર્નિંગ ટેક્સ્ટ અને ઈમેજોના ક્ષેત્રોમાં ઉચ્ચ પરિણામો પ્રાપ્ત કરી રહ્યું છે).
4. **ઇમેજ રેકગ્નિશન –** ઇમેજમાં લોકો અને ઑબ્જેક્ટ્સને ઓળખે છે અને ઓળખે છે તેમજ સામગ્રી અને સંદર્ભને સમજે છે. આ વિસ્તાર પહેલેથી જ ગેમિંગ, રિટેલ, ટુરિઝમ વગેરેમાં ઉપયોગમાં લેવાય છે.
5. **ભૂકંપની આગાહી કરવી –** કમ્પ્યુટરને વિસ્કોઇલાસ્ટિક ગણતરીઓ કરવા શીખવે છે, જેનો ઉપયોગ ભૂકંપની આગાહી કરવા માટે થાય છે.

## [વેબ ટેકનોલોજી](Web%20Technology/WebTechnology.md#web-technology)
વેબ ટેક્નોલોજી એ વિવિધ સાધનો અને તકનીકોનો ઉલ્લેખ કરે છે જેનો ઉપયોગ ઇન્ટરનેટ પર વિવિધ પ્રકારના ઉપકરણો વચ્ચે સંચારની પ્રક્રિયામાં થાય છે. વેબ બ્રાઉઝરનો ઉપયોગ વેબ પૃષ્ઠોને ઍક્સેસ કરવા માટે થાય છે. વેબ બ્રાઉઝર્સને એવા પ્રોગ્રામ્સ તરીકે વ્યાખ્યાયિત કરી શકાય છે જે ઇન્ટરનેટ પર ટેક્સ્ટ, ડેટા, ચિત્રો, એનિમેશન અને વિડિયો પ્રદર્શિત કરે છે. વેબ બ્રાઉઝર્સ દ્વારા પૂરા પાડવામાં આવેલ સોફ્ટવેર ઈન્ટરફેસનો ઉપયોગ કરીને વર્લ્ડ વાઈડ વેબ પર હાયપરલિંક કરેલ સંસાધનોને ઍક્સેસ કરી શકાય છે.
### વેબ ટેકનોલોજીને નીચેના વિભાગોમાં વર્ગીકૃત કરી શકાય છે:
- વર્લ્ડ વાઈડ વેબ (WWW)
વર્લ્ડ વાઇડ વેબ ઘણી વિવિધ તકનીકો પર આધારિત છે: વેબ બ્રાઉઝર્સ, હાઇપરટેક્સ્ટ માર્કઅપ લેંગ્વેજ (HTML), અને હાઇપરટેક્સ્ટ ટ્રાન્સફર પ્રોટોકોલ (HTTP).
- વેબ બ્રાઉઝર
વેબ બ્રાઉઝર એ www (વર્લ્ડ વાઈડ વેબ) નું અન્વેષણ કરવા માટેનું એક એપ્લિકેશન સોફ્ટવેર છે. તે સર્વર અને ક્લાયન્ટ વચ્ચે ઇન્ટરફેસ પ્રદાન કરે છે અને વેબ દસ્તાવેજો અને સેવાઓ માટે સર્વરને વિનંતી કરે છે.
- વેબ સર્વર
વેબ સર્વર એ એક પ્રોગ્રામ છે જે વપરાશકર્તાઓની નેટવર્ક વિનંતીઓ પર પ્રક્રિયા કરે છે અને તેમને વેબ પૃષ્ઠો બનાવતી ફાઇલો સાથે સેવા આપે છે. આ વિનિમય હાયપરટેક્સ્ટ ટ્રાન્સફર પ્રોટોકોલ (HTTP) નો ઉપયોગ કરીને થાય છે.
- વેબ પેજીસ
વેબપેજ એ એક ડિજિટલ દસ્તાવેજ છે જે વર્લ્ડ વાઈડ વેબ સાથે જોડાયેલ છે અને વેબ બ્રાઉઝર ધરાવતા ઈન્ટરનેટ સાથે જોડાયેલ કોઈપણ વ્યક્તિ જોઈ શકે છે.
- વેબ વિકાસ
વેબ ડેવલપમેન્ટ એ વેબસાઇટનું નિર્માણ, નિર્માણ અને જાળવણીનો સંદર્ભ આપે છે. તેમાં વેબ ડિઝાઇન, વેબ પબ્લિશિંગ, વેબ પ્રોગ્રામિંગ અને ડેટાબેઝ મેનેજમેન્ટ જેવા પાસાઓનો સમાવેશ થાય છે. તે એક એપ્લિકેશનની રચના છે જે ઇન્ટરનેટ પર કામ કરે છે, એટલે કે, વેબસાઇટ્સ.
### વેબ ડેવલપમેન્ટને બે રીતે વર્ગીકૃત કરી શકાય છે:
### આગળ નો વિકાસ
વેબસાઇટનો ભાગ જ્યાં વપરાશકર્તા સીધો સંપર્ક કરે છે તેને ફ્રન્ટ એન્ડ કહેવામાં આવે છે. તેને એપ્લિકેશનની 'ક્લાયન્ટ બાજુ' તરીકે પણ ઓળખવામાં આવે છે.
### બેકએન્ડ ડેવલપમેન્ટ
બેકએન્ડ એ વેબસાઇટની સર્વર બાજુ છે. તે વેબસાઇટનો એક ભાગ છે જેને વપરાશકર્તાઓ જોઈ શકતા નથી અને તેની સાથે ક્રિયાપ્રતિક્રિયા કરી શકતા નથી. તે સૉફ્ટવેરનો એક ભાગ છે જે વપરાશકર્તાઓ સાથે સીધા સંપર્કમાં આવતો નથી. તેનો ઉપયોગ ડેટા સ્ટોર કરવા અને ગોઠવવા માટે થાય છે.

# [નેટવર્કિંગ](Networking/readme.md#networking)
કોમ્પ્યુટર નેટવર્ક એ નેટવર્ક નોડ્સ પર સ્થિત અથવા પ્રદાન કરેલ સંસાધનોને વહેંચતા કમ્પ્યુટરનો સમૂહ છે. કમ્પ્યુટર્સ એકબીજા સાથે વાતચીત કરવા માટે ડિજિટલ ઇન્ટરકનેક્શન્સ પર સામાન્ય સંચાર પ્રોટોકોલનો ઉપયોગ કરે છે. આ ઇન્ટરકનેક્શન્સ ભૌતિક રીતે વાયર્ડ, ઓપ્ટિકલ અને વાયરલેસ રેડિયો-ફ્રિકવન્સી પદ્ધતિઓ પર આધારિત ટેલિકોમ્યુનિકેશન નેટવર્ક તકનીકોથી બનેલા છે જે વિવિધ નેટવર્ક ટોપોલોજીમાં ગોઠવી શકાય છે.

કોમ્પ્યુટર નેટવર્કના નોડ્સમાં પર્સનલ કોમ્પ્યુટર, સર્વર્સ, નેટવર્કીંગ હાર્ડવેર અથવા અન્ય વિશિષ્ટ અથવા સામાન્ય હેતુવાળા હોસ્ટનો સમાવેશ થઈ શકે છે. તેઓ નેટવર્ક સરનામાં દ્વારા ઓળખાય છે અને તેમના હોસ્ટનામો હોઈ શકે છે. યજમાનનામો નોડ્સ માટે યાદગાર લેબલ તરીકે સેવા આપે છે, પ્રારંભિક સોંપણી પછી ભાગ્યે જ બદલાય છે. નેટવર્ક એડ્રેસો ઈન્ટરનેટ પ્રોટોકોલ જેવા કોમ્યુનિકેશન પ્રોટોકોલ દ્વારા નોડ્સને શોધવા અને ઓળખવા માટે સેવા આપે છે.

કમ્પ્યુટર નેટવર્કને ઘણા માપદંડો દ્વારા વર્ગીકૃત કરી શકાય છે, જેમાં સિગ્નલો વહન કરવા માટે વપરાતા ટ્રાન્સમિશન માધ્યમ, બેન્ડવિડ્થ, નેટવર્ક ટ્રાફિકને ગોઠવવા માટે સંચાર પ્રોટોકોલ, નેટવર્કનું કદ, ટોપોલોજી, ટ્રાફિક કંટ્રોલ મિકેનિઝમ અને સંસ્થાકીય ઉદ્દેશ્યનો સમાવેશ થાય છે.

## નેટવર્કીંગના પ્રકારો
કમ્પ્યુટર નેટવર્કિંગના બે પ્રાથમિક પ્રકારો છે:
- વાયર્ડ નેટવર્કિંગ: વાયર્ડ નેટવર્કિંગ માટે નોડ્સ વચ્ચે પરિવહન માટે ભૌતિક માધ્યમનો ઉપયોગ જરૂરી છે. કોપર-આધારિત ઇથરનેટ કેબલિંગ, તેની ઓછી કિંમત અને ટકાઉપણુંને કારણે લોકપ્રિય છે, તેનો ઉપયોગ સામાન્ય રીતે વ્યવસાયો અને ઘરોમાં ડિજિટલ સંચાર માટે થાય છે. વૈકલ્પિક રીતે, ઓપ્ટિકલ ફાઈબરનો ઉપયોગ વધુ અંતર પર અને ઝડપી ઝડપે ડેટાને પરિવહન કરવા માટે થાય છે, પરંતુ તેમાં ઘણા ટ્રેડઓફ્સ છે, જેમાં ઊંચા ખર્ચ અને વધુ નાજુક ઘટકોનો સમાવેશ થાય છે.
- વાયરલેસ નેટવર્કિંગ: વાયરલેસ નેટવર્કિંગ ડેટાને હવામાં પરિવહન કરવા માટે રેડિયો તરંગોનો ઉપયોગ કરે છે, ઉપકરણોને કોઈપણ કેબલિંગ વિના નેટવર્ક સાથે કનેક્ટ થવા સક્ષમ બનાવે છે. વાયરલેસ LAN એ વાયરલેસ નેટવર્કિંગનું સૌથી જાણીતું અને વ્યાપકપણે ઉપયોગમાં લેવાતું સ્વરૂપ છે. અન્ય વિકલ્પોમાં માઇક્રોવેવ, સેટેલાઇટ, સેલ્યુલર અને બ્લૂટૂથનો સમાવેશ થાય છે.
## OSI મોડલ
OSI નો અર્થ **ઓપન સિસ્ટમ્સ ઇન્ટરકનેક્શન** છે. તે ISO – **આંતરરાષ્ટ્રીય ઓર્ગેનાઈઝેશન ફોર સ્ટાન્ડર્ડાઈઝેશન**’ દ્વારા વર્ષ 1984માં વિકસાવવામાં આવ્યું હતું. તે 7-સ્તરનું આર્કિટેક્ચર છે જેમાં પ્રત્યેક સ્તર ચોક્કસ કાર્યક્ષમતા ધરાવે છે. આ તમામ સાત સ્તરો સમગ્ર વિશ્વમાં એક વ્યક્તિથી બીજામાં ડેટા ટ્રાન્સમિટ કરવા માટે સહયોગથી કામ કરે છે.

### **1\. ભૌતિક સ્તર (સ્તર 1):**

OSI સંદર્ભ મોડેલનું સૌથી નીચું સ્તર ભૌતિક સ્તર છે. તે ઉપકરણો વચ્ચેના વાસ્તવિક ભૌતિક જોડાણ માટે જવાબદાર છે. ભૌતિક સ્તર **બિટ્સના સ્વરૂપમાં માહિતી ધરાવે છે.** તે વ્યક્તિગત બિટ્સને એક નોડથી બીજામાં ટ્રાન્સમિટ કરવા માટે જવાબદાર છે. ડેટા પ્રાપ્ત કરતી વખતે, આ સ્તર પ્રાપ્ત સિગ્નલ મેળવશે અને તેને 0s અને 1s માં રૂપાંતરિત કરશે અને તેમને ડેટા લિંક સ્તર પર મોકલશે, જે ફ્રેમને ફરીથી એકસાથે મૂકશે.

![](Networking/OSI%20Model/img/computer-network-osi-model-layers-bits.png)

ભૌતિક સ્તરના કાર્યો નીચે મુજબ છે:

1. **બિટ સિંક્રનાઇઝેશન:** ભૌતિક સ્તર ઘડિયાળ પ્રદાન કરીને બિટ્સનું સિંક્રનાઇઝેશન પ્રદાન કરે છે. આ ઘડિયાળ પ્રેષક અને પ્રાપ્તકર્તા બંનેને નિયંત્રિત કરે છે આમ બીટ સ્તરે સિંક્રનાઇઝેશન પ્રદાન કરે છે.
2. **બિટ રેટ કંટ્રોલ:** ભૌતિક સ્તર ટ્રાન્સમિશન રેટને પણ વ્યાખ્યાયિત કરે છે, એટલે કે, પ્રતિ સેકન્ડે મોકલવામાં આવતા બિટ્સની સંખ્યા.
3. **ભૌતિક ટોપોલોજી:** ભૌતિક સ્તર સ્પષ્ટ કરે છે કે નેટવર્કમાં વિવિધ ઉપકરણો/નોડ્સ કેવી રીતે ગોઠવાય છે, એટલે કે, બસ, સ્ટાર અથવા મેશ ટોપોલોજી.
4. **ટ્રાન્સમિશન મોડ:** ભૌતિક સ્તર એ પણ વ્યાખ્યાયિત કરે છે કે બે કનેક્ટેડ ઉપકરણો વચ્ચે ડેટા કેવી રીતે વહે છે. સિમ્પલેક્સ, હાફ-ડુપ્લેક્સ અને ફુલ-ડુપ્લેક્સ જેવા વિવિધ ટ્રાન્સમિશન મોડ્સ શક્ય છે.

### **2\. ડેટા લિંક લેયર (DLL) (લેયર 2):**

ડેટા લિંક સ્તર સંદેશના નોડ-ટુ-નોડ ડિલિવરી માટે જવાબદાર છે. આ સ્તરનું મુખ્ય કાર્ય એ ખાતરી કરવાનું છે કે ભૌતિક સ્તર પર એક નોડથી બીજા નોડમાં ડેટા ટ્રાન્સફર ભૂલ-મુક્ત છે. જ્યારે કોઈ પેકેટ નેટવર્કમાં આવે છે, ત્યારે તેના MAC એડ્રેસનો ઉપયોગ કરીને તેને હોસ્ટને ટ્રાન્સમિટ કરવાની જવાબદારી DLLની છે.
ડેટા લિંક લેયર બે પેટા સ્તરોમાં વિભાજિત થયેલ છે:

1. લોજિકલ લિંક કંટ્રોલ (LLC)
2. મીડિયા એક્સેસ કંટ્રોલ (MAC)

NIC(નેટવર્ક ઈન્ટરફેસ કાર્ડ) ના ફ્રેમ સાઈઝના આધારે નેટવર્ક લેયરમાંથી પ્રાપ્ત પેકેટને આગળ ફ્રેમમાં વિભાજિત કરવામાં આવે છે. DLL હેડરમાં પ્રેષક અને પ્રાપ્તકર્તાના MAC સરનામાંને પણ સમાવે છે.

રીસીવરનું MAC સરનામું એઆરપી (એડ્રેસ રિઝોલ્યુશન પ્રોટોકોલ) વિનંતીને વાયર પર મૂકીને મેળવવામાં આવે છે જેમાં પૂછવામાં આવે છે, "તે IP સરનામું કોની પાસે છે?" અને ડેસ્ટિનેશન હોસ્ટ તેના MAC એડ્રેસ સાથે જવાબ આપશે.

![](Networking/OSI%20Model/img/computer-network-osi-model-layers-framing.png)

ડેટા લિંક લેયરના કાર્યો છે:

1. **ફ્રેમિંગ:** ફ્રેમિંગ એ ડેટા લિંક લેયરનું કાર્ય છે. તે પ્રેષકને બીટ્સના સમૂહને પ્રસારિત કરવાનો માર્ગ પૂરો પાડે છે જે પ્રાપ્તકર્તા માટે અર્થપૂર્ણ છે. ફ્રેમની શરૂઆત અને અંતમાં ખાસ બીટ પેટર્ન જોડીને આ પરિપૂર્ણ કરી શકાય છે.
2. **ભૌતિક સંબોધન:** ફ્રેમ બનાવ્યા પછી, ડેટા લિંક લેયર દરેક ફ્રેમના હેડરમાં પ્રેષક અને/અથવા પ્રાપ્તકર્તાના ભૌતિક સરનામાં (MAC સરનામાં) ઉમેરે છે.
3. **ભૂલ નિયંત્રણ:** ડેટા લિંક લેયર ભૂલ નિયંત્રણની પદ્ધતિ પ્રદાન કરે છે જેમાં તે ક્ષતિગ્રસ્ત અથવા ખોવાયેલી ફ્રેમને શોધી અને ફરીથી પ્રસારિત કરે છે.
4. **ફ્લો કંટ્રોલ:** ડેટા રેટ બંને બાજુએ સ્થિર હોવો જોઈએ, નહીં તો ડેટા બગડી શકે છે; આમ, ફ્લો કંટ્રોલ ડેટાના જથ્થાનું સંકલન કરે છે જે સ્વીકૃતિ પ્રાપ્ત કરતા પહેલા મોકલી શકાય છે.
5. **એક્સેસ કંટ્રોલ:** જ્યારે એક સંચાર ચેનલ બહુવિધ ઉપકરણો દ્વારા શેર કરવામાં આવે છે, ત્યારે ડેટા લિંક લેયરનું MAC સબ-લેયર એ નક્કી કરવામાં મદદ કરે છે કે આપેલ સમયે ચેનલ પર કયા ઉપકરણનું નિયંત્રણ છે.

### **3\. નેટવર્ક લેયર (લેયર 3):**

નેટવર્ક લેયર વિવિધ નેટવર્ક્સમાં સ્થિત એક હોસ્ટથી બીજા હોસ્ટમાં ડેટાના ટ્રાન્સમિશન માટે કામ કરે છે. તે પેકેટ રૂટીંગનું પણ ધ્યાન રાખે છે, એટલે કે, ઉપલબ્ધ રૂટની સંખ્યામાંથી પેકેટને પ્રસારિત કરવા માટેના ટૂંકા માર્ગની પસંદગી. પ્રેષક અને પ્રાપ્તકર્તાના IP સરનામાઓ નેટવર્ક સ્તર દ્વારા હેડરમાં મૂકવામાં આવે છે.

નેટવર્ક સ્તરના કાર્યો છે:

1. **રૂટીંગ:** નેટવર્ક લેયર પ્રોટોકોલ નિર્ધારિત કરે છે કે સ્ત્રોતથી ગંતવ્ય સુધી કયો માર્ગ યોગ્ય છે. નેટવર્ક સ્તરનું આ કાર્ય રૂટીંગ તરીકે ઓળખાય છે.
2. **લોજિકલ એડ્રેસિંગ:** ઈન્ટરનેટવર્ક પર દરેક ઉપકરણને વિશિષ્ટ રીતે ઓળખવા માટે, નેટવર્ક લેયર એડ્રેસિંગ સ્કીમને વ્યાખ્યાયિત કરે છે. પ્રેષક અને પ્રાપ્તકર્તાના IP સરનામાઓ નેટવર્ક સ્તર દ્વારા હેડરમાં મૂકવામાં આવે છે. આવા સરનામું દરેક ઉપકરણને અનન્ય અને સાર્વત્રિક રીતે અલગ પાડે છે.

# [ઇન્ટરનેટ](Internet/readme.md#internet)
ઇન્ટરનેટ એ ઇન્ટરકનેક્ટેડ કમ્પ્યુટર નેટવર્ક્સની વૈશ્વિક સિસ્ટમ છે જે વિશ્વભરના અબજો વપરાશકર્તાઓને સેવા આપવા માટે માનક ઇન્ટરનેટ પ્રોટોકોલ સ્યુટ ([TCP/IP](Networking/readme.md#tcptransmission-control-protocol)) નો ઉપયોગ કરે છે. તે નેટવર્ક્સનું નેટવર્ક છે જેમાં લાખો ખાનગી, જાહેર, શૈક્ષણિક, વ્યાપાર અને સ્થાનિકથી વૈશ્વિક અવકાશના સરકારી નેટવર્કનો સમાવેશ થાય છે જે ઈલેક્ટ્રોનિક, વાયરલેસ અને ઓપ્ટિકલ નેટવર્કિંગ ટેક્નોલોજીની વ્યાપક શ્રેણી દ્વારા જોડાયેલા છે. ઈન્ટરનેટ માહિતી સંસાધનો અને સેવાઓની વ્યાપક શ્રેણી ધરાવે છે, જેમ કે ઇન્ટરલિંક્ડ હાઈપરટેક્સ્ટ દસ્તાવેજો અને વર્લ્ડ વાઈડ વેબ ([WWW](Internet/readme.md#world-wide-web-www)) અને સપોર્ટ કરવા માટેનું ઈન્ફ્રાસ્ટ્રક્ચર ઇમેઇલ.

## [વર્લ્ડ વાઈડ વેબ (WWW)](Internet/readme.md#world-wide-web-www)
વર્લ્ડ વાઇડ વેબ (WWW) એ એક માહિતી જગ્યા છે જ્યાં દસ્તાવેજો અને અન્ય વેબ સંસાધનોને યુનિફોર્મ રિસોર્સ લોકેટર (URLs) દ્વારા ઓળખવામાં આવે છે, જે હાઇપરટેક્સ્ટ લિંક્સ દ્વારા એકબીજા સાથે જોડાયેલા છે અને ઇન્ટરનેટ દ્વારા ઍક્સેસિબલ છે. અંગ્રેજ વૈજ્ઞાનિક ટિમ બર્નર્સ-લીએ 1989માં વર્લ્ડ વાઈડ વેબની શોધ કરી હતી. તેમણે સ્વિટ્ઝર્લૅન્ડમાં CERN ખાતે નોકરી કરતી વખતે 1990માં પહેલું વેબ બ્રાઉઝર લખ્યું હતું. બ્રાઉઝર 1991 માં CERN ની બહાર બહાર પાડવામાં આવ્યું હતું, પ્રથમ જાન્યુઆરી 1991 માં શરૂ થતી અન્ય સંશોધન સંસ્થાઓ માટે અને ઓગસ્ટ 1991 માં ઇન્ટરનેટ પર સામાન્ય લોકો માટે.

## [ઇન્ટરનેટ પ્રોટોકોલ (IP)](Internet/readme.md#internet-protocol-ip)
ઈન્ટરનેટ પ્રોટોકોલ (IP) એ પ્રોટોકોલ અથવા નિયમોનો સમૂહ છે, જે ડેટાના પેકેટોને રૂટીંગ કરવા અને સંબોધવા માટે છે જેથી તેઓ સમગ્ર નેટવર્ક પર મુસાફરી કરી શકે અને યોગ્ય ગંતવ્ય પર પહોંચી શકે. ઈન્ટરનેટ પર પસાર થતો ડેટા પેકેટ તરીકે ઓળખાતા નાના ટુકડાઓમાં વિભાજિત થાય છે.

## [DBMS]()

ડેટાબેઝ શું છે?
-------------------

ડેટાબેઝ એ સંબંધિત ડેટાનો સંગ્રહ છે જે વાસ્તવિક દુનિયાના અમુક પાસાને રજૂ કરે છે. ડેટાબેઝ સિસ્ટમ ચોક્કસ કાર્ય માટે ડેટા સાથે બિલ્ટ અને પોપ્યુલેટ કરવા માટે ડિઝાઇન કરવામાં આવી છે.

DBMS શું છે?
-------------

**ડેટાબેઝ મેનેજમેન્ટ સિસ્ટમ (DBMS)** એ યોગ્ય સુરક્ષા પગલાંને ધ્યાનમાં રાખીને વપરાશકર્તાઓના ડેટાને સંગ્રહિત કરવા અને પુનઃપ્રાપ્ત કરવા માટેનું સોફ્ટવેર છે. તે પ્રોગ્રામ્સના જૂથનો સમાવેશ કરે છે જે ડેટાબેઝને મેનિપ્યુલેટ કરે છે. DBMS એપ્લિકેશનમાંથી ડેટા માટેની વિનંતી સ્વીકારે છે અને ઓપરેટિંગ સિસ્ટમને ચોક્કસ ડેટા પ્રદાન કરવા માટે સૂચના આપે છે. મોટી સિસ્ટમમાં, DBMS વપરાશકર્તાઓ અને અન્ય તૃતીય-પક્ષ સોફ્ટવેરને સંગ્રહિત કરવામાં અને ડેટા પુનઃપ્રાપ્ત કરવામાં મદદ કરે છે.

DBMS વપરાશકર્તાઓને તેમની જરૂરિયાતો અનુસાર તેમના ડેટાબેઝ બનાવવાની મંજૂરી આપે છે. "DBMS" શબ્દમાં ડેટાબેઝ અને અન્ય એપ્લિકેશન પ્રોગ્રામનો ઉપયોગ શામેલ છે. તે ડેટા અને સોફ્ટવેર એપ્લિકેશન વચ્ચે ઈન્ટરફેસ પૂરો પાડે છે.

DBMS નું ઉદાહરણ
-----------------

ચાલો યુનિવર્સિટી ડેટાબેઝનું એક સરળ ઉદાહરણ જોઈએ. આ ડેટાબેઝ યુનિવર્સિટી વાતાવરણમાં વિદ્યાર્થીઓ, અભ્યાસક્રમો અને ગ્રેડ સંબંધિત માહિતી જાળવી રાખે છે. ડેટાબેઝ પાંચ ફાઇલોમાં ગોઠવાયેલ છે:

* સ્ટુડન્ટ ફાઈલ દરેક વિદ્યાર્થીનો ડેટા સ્ટોર કરે છે
* COURSE ફાઇલ સ્ટોર્સમાં દરેક કોર્સનો ડેટા હોય છે.
* વિભાગ ચોક્કસ અભ્યાસક્રમમાં વિભાગો વિશેની માહિતી સંગ્રહિત કરે છે.
* GRADE ફાઇલ વિવિધ વિભાગોમાં વિદ્યાર્થીઓ મેળવેલા ગ્રેડને સંગ્રહિત કરે છે
* TUTOR ફાઇલમાં દરેક પ્રોફેસર વિશેની માહિતી હોય છે.

DBMS ને વ્યાખ્યાયિત કરવા માટે:

* આપણે દરેક રેકોર્ડમાં સંગ્રહિત કરવા માટેના વિવિધ પ્રકારના ડેટા તત્વોને વ્યાખ્યાયિત કરીને દરેક ફાઇલના રેકોર્ડનું માળખું સ્પષ્ટ કરવાની જરૂર છે.
* અમે ડેટા આઇટમના મૂલ્યોને દર્શાવવા માટે કોડિંગ સ્કીમનો પણ ઉપયોગ કરી શકીએ છીએ.
* મૂળભૂત રીતે, તમારા ડેટાબેઝમાં વિવિધ કોષ્ટકો વચ્ચે વ્યાખ્યાયિત વિદેશી કી સાથે પાંચ કોષ્ટકો હશે.

ડીબીએમએસનો ઇતિહાસ
---------------

અહીં ઇતિહાસમાંથી મહત્વપૂર્ણ સીમાચિહ્નો છે:

* 1960 - ચાર્લ્સ બેચમેને પ્રથમ DBMS સિસ્ટમ ડિઝાઇન કરી
* 1970 - કોડે IBM ની ઇન્ફર્મેશન મેનેજમેન્ટ સિસ્ટમ (IMS) રજૂ કરી
* 1976- પીટર ચેને એન્ટિટી-રિલેશનશિપ મોડલની રચના અને વ્યાખ્યા કરી, જેને ER મોડલ તરીકે પણ ઓળખવામાં આવે છે.
* 1980 - રિલેશનલ મોડલ વ્યાપકપણે સ્વીકૃત ડેટાબેઝ ઘટક બની ગયું
* 1985- ઑબ્જેક્ટ-ઓરિએન્ટેડ DBMS વિકસે છે.
* 1990- રિલેશનલ ડીબીએમએસમાં ઑબ્જેક્ટ ઓરિએન્ટેશનનો સમાવેશ.
* 1991- માઈક્રોસોફ્ટ MS એક્સેસ મોકલે છે, એક વ્યક્તિગત DBMS જે અન્ય તમામ વ્યક્તિગત DBMS ઉત્પાદનોને વિસ્થાપિત કરે છે.
* 1995: પ્રથમ ઈન્ટરનેટ ડેટાબેઝ એપ્લિકેશન
* 1997: ડેટાબેઝ પ્રોસેસિંગ માટે XML લાગુ. ઘણા વિક્રેતાઓ XML ને DBMS ઉત્પાદનોમાં એકીકૃત કરવાનું શરૂ કરે છે.

DBMS ની લાક્ષણિકતાઓ
----------------------------------------

અહીં ડેટાબેઝ મેનેજમેન્ટ સિસ્ટમની લાક્ષણિકતાઓ અને ગુણધર્મો છે:

* સુરક્ષા પૂરી પાડે છે અને રીડન્ડન્સી દૂર કરે છે
* ડેટાબેઝ સિસ્ટમની પ્રકૃતિનું સ્વ-વર્ણન
* પ્રોગ્રામ્સ અને ડેટા એબ્સ્ટ્રેક્શન વચ્ચેનું ઇન્સ્યુલેશન
* ડેટાના બહુવિધ દૃશ્યોનો આધાર
* ડેટા શેરિંગ અને મલ્ટિ-યુઝર ટ્રાન્ઝેક્શન પ્રોસેસિંગ
* ડેટાબેઝ મેનેજમેન્ટ સોફ્ટવેર સંસ્થાઓ અને તેમની વચ્ચેના સંબંધોને કોષ્ટકો બનાવવાની મંજૂરી આપે છે.
* તે ACID ખ્યાલ (અણુ, સુસંગતતા, અલગતા અને ટકાઉપણું) ને અનુસરે છે.
* DBMS મલ્ટિ-યુઝર એન્વાયર્નમેન્ટને સપોર્ટ કરે છે જે યુઝર્સને ડેટા એક્સેસ કરવા અને સમાંતર રીતે મેનીપ્યુલેટ કરવાની મંજૂરી આપે છે.

લોકપ્રિય DBMS સોફ્ટવેર
----------------------------------

અહીં કેટલીક લોકપ્રિય DBMS સિસ્ટમ્સની સૂચિ છે:

* MySQL
* માઈક્રોસોફ્ટ એક્સેસ
* ઓરેકલ
* PostgreSQL
* dBASE
* ફોક્સપ્રો
* SQLite
* IBM DB2
* લીબરઓફીસ બેઝ
* મારિયાડીબી
* માઇક્રોસોફ્ટ એસક્યુએલ સર્વર વગેરે.

## [ક્રિપ્ટોગ્રાફી](Cryptography/readme.md#cryptography)
ક્રિપ્ટોગ્રાફી એ ડેટા અને કોમ્યુનિકેશનને સુરક્ષિત કરવાની ટેકનિક છે. તે કોડના ઉપયોગ દ્વારા માહિતી અને સંદેશાવ્યવહારને સુરક્ષિત કરવાની એક પદ્ધતિ છે જેથી ફક્ત તે જ લોકો તેને વાંચી અને પ્રક્રિયા કરી શકે જેમના માટે માહિતીનો હેતુ છે. ક્રિપ્ટોગ્રાફીનો ઉપયોગ પરિવહનમાં, આરામમાં અને ઉપયોગમાં ડેટાને સુરક્ષિત કરવા માટે થાય છે. ઉપસર્ગ _crypt_ નો અર્થ છે "છુપાયેલ" અથવા "ગુપ્ત", અને પ્રત્યય _graphy_ નો અર્થ "લેખન" થાય છે.

### ક્રિપ્ટોગ્રાફીના પ્રકાર
સંકેતલિપીના બે પ્રકાર છે:
1. [સપ્રમાણ સંકેતલિપી](Cryptography/readme.md#symmetric-cryptography)
2. [અસમમેટ્રિક ક્રિપ્ટોગ્રાફી](Cryptography/readme.md#asymmetric-cryptography)

### [ક્રિપ્ટો કરન્સી](Cryptography/CryptoCurrency/readme.md#crypto-currency)
ક્રિપ્ટોકરન્સી એ એક ડિજિટલ ચલણ છે જેમાં એનક્રિપ્શન તકનીકોનો ઉપયોગ ચલણના એકમોના ઉત્પાદનને નિયંત્રિત કરવા અને ભંડોળના ટ્રાન્સફરની ચકાસણી કરવા માટે કરવામાં આવે છે, જે કેન્દ્રીય બેંકથી સ્વતંત્ર રીતે કાર્ય કરે છે. ક્રિપ્ટોકરન્સી કેન્દ્રીકૃત ડિજિટલ ચલણ અને કેન્દ્રીય બેંકિંગ સિસ્ટમના વિરોધમાં વિકેન્દ્રિત નિયંત્રણનો ઉપયોગ કરે છે. દરેક ક્રિપ્ટોકરન્સીનું વિકેન્દ્રિત નિયંત્રણ ડિસ્ટ્રિબ્યુટેડ લેજર ટેકનોલોજી દ્વારા કામ કરે છે, ખાસ કરીને બ્લોકચેન, જે જાહેર નાણાકીય વ્યવહાર ડેટાબેઝ તરીકે કામ કરે છે. ક્રિપ્ટોકરન્સીનું વ્યાખ્યાયિત લક્ષણ, અને દલીલપૂર્વક તેનું સૌથી પ્રિય આકર્ષણ, તેની કાર્બનિક પ્રકૃતિ છે; તે કોઈપણ કેન્દ્રીય સત્તા દ્વારા જારી કરવામાં આવતું નથી, જે તેને સૈદ્ધાંતિક રીતે સરકારી હસ્તક્ષેપ અથવા હેરાફેરી માટે પ્રતિરક્ષા આપે છે.

## ક્રિપ્ટો કરન્સીના પ્રકાર નીચે મુજબ છે:
1. [કાર્યનો પુરાવો](Cryptography/CryptoCurrency/ProofOfWork/readme.md#proof-of-work)
2. [સ્ટેકનો પુરાવો](Cryptography/CryptoCurrency/ProofOfStake/readme.md#proof-of-stake)


### _સૌથી વધુ લોકપ્રિય ક્રિપ્ટો કરન્સી નીચે મુજબ છે:-
1. [Bitcoin](Cryptography/CryptoCurrency/ProofOfWork/Bitcoin/readme.md#bitcoin)
2. [Ethereum](Cryptography/CryptoCurrency/ProofOfStake/Ethereum/readme.md#ethereum)
3. [Litecoin](Cryptography/CryptoCurrency/ProofOfWork/Litecoin/readme.md#litecoin)
4. [Cardano](Cryptography/CryptoCurrency/ProofOfStake/Cardano/readme.md#cardano)
5. [Dogecoin](Cryptography/CryptoCurrency/ProofOfWork/Dogecoin/readme.md#dogecoin)



## ગણતરીનો સિદ્ધાંત
સૈદ્ધાંતિક કોમ્પ્યુટર વિજ્ઞાન અને ગણિતમાં, ગણતરીનો સિદ્ધાંત એ શાખા છે જે એલ્ગોરિધમનો ઉપયોગ કરીને ગણતરીના મોડેલ પર કઈ સમસ્યાઓ હલ કરી શકાય છે, તે કેટલી અસરકારક રીતે ઉકેલી શકાય છે અથવા કઈ ડિગ્રી સુધી (દા.ત., અંદાજિત ઉકેલો વિરુદ્ધ ચોક્કસ ઉકેલો). આ ક્ષેત્રને ત્રણ મુખ્ય શાખાઓમાં વિભાજિત કરવામાં આવે છે: ઓટોમેટા થિયરી અને ઔપચારિક ભાષાઓ, કોમ્પ્યુટીબિલિટી થિયરી અને કોમ્પ્યુટેશનલ કોમ્પ્લેક્સિટી થિયરી, જે પ્રશ્ન દ્વારા જોડાયેલા છે: "કોમ્પ્યુટરની મૂળભૂત ક્ષમતાઓ અને મર્યાદાઓ શું છે?".

### ઓટોમેટા થિયરી
ઓટોમેટા થિયરી એ અમૂર્ત મશીનો અને ઓટોમેટાનો અભ્યાસ છે, તેમજ તેમની મદદથી ઉકેલી શકાય તેવી કોમ્પ્યુટેશનલ સમસ્યાઓ છે. તે સૈદ્ધાંતિક કમ્પ્યુટર વિજ્ઞાનમાં એક સિદ્ધાંત છે. ઓટોમેટા શબ્દ ગ્રીક શબ્દ αὐτόματος પરથી આવ્યો છે, જેનો અર્થ થાય છે "સ્વ-અભિનય, સ્વ-ઇચ્છા, સ્વ-ગતિ". ઓટોમેટન (બહુવચનમાં ઓટોમેટા) એ એક અમૂર્ત સ્વ-સંચાલિત કમ્પ્યુટિંગ ઉપકરણ છે જે ઑપરેશનના પૂર્વનિર્ધારિત ક્રમને આપમેળે અનુસરે છે. મર્યાદિત સંખ્યામાં રાજ્યો સાથેના ઓટોમેટનને ફિનાઈટ ઓટોમેટન (FA) અથવા ફિનાઈટ-સ્ટેટ મશીન (FSM) કહેવામાં આવે છે. જમણી બાજુની આકૃતિ મર્યાદિત-સ્થિતિ મશીનને દર્શાવે છે, જે ઓટોમેટનનો જાણીતો પ્રકાર છે. આ ઓટોમેટનમાં રાજ્યો (વર્તુળો દ્વારા આકૃતિમાં રજૂ) અને સંક્રમણો (તીર દ્વારા રજૂ) નો સમાવેશ થાય છે. જેમ જેમ ઓટોમેટન ઇનપુટનું પ્રતીક જુએ છે, તે તેના સંક્રમણ કાર્ય અનુસાર, અન્ય રાજ્યમાં સંક્રમણ (અથવા કૂદકો) કરે છે, જે અગાઉની સ્થિતિ અને વર્તમાન ઇનપુટ પ્રતીકને તેની દલીલો તરીકે લે છે.

### ઔપચારિક ભાષાઓ
તર્કશાસ્ત્ર, ગણિત, કોમ્પ્યુટર વિજ્ઞાન અને ભાષાશાસ્ત્રમાં, ઔપચારિક ભાષામાં એવા શબ્દોનો સમાવેશ થાય છે કે જેના અક્ષરો મૂળાક્ષરોમાંથી લેવામાં આવ્યા હોય અને નિયમોના ચોક્કસ સમૂહ અનુસાર સારી રીતે રચાયેલા હોય.

ઔપચારિક ભાષાના મૂળાક્ષરોમાં પ્રતીકો, અક્ષરો અથવા ટોકન્સનો સમાવેશ થાય છે જે ભાષાના શબ્દમાળાઓ સાથે જોડાય છે.[1] આ મૂળાક્ષરોના પ્રતીકોમાંથી સંકલિત દરેક શબ્દમાળાને શબ્દ કહેવામાં આવે છે, અને જે શબ્દો કોઈ ચોક્કસ ઔપચારિક ભાષાના હોય છે તેને કેટલીકવાર સારી રીતે રચાયેલા શબ્દો અથવા સારી રીતે રચાયેલા સૂત્રો કહેવામાં આવે છે. ઔપચારિક ભાષાને ઔપચારિક વ્યાકરણનો ઉપયોગ કરીને વ્યાખ્યાયિત કરવામાં આવે છે, જેમ કે નિયમિત વ્યાકરણ અથવા સંદર્ભ-મુક્ત વ્યાકરણ, જેમાં તેના રચના નિયમોનો સમાવેશ થાય છે.

કોમ્પ્યુટર વિજ્ઞાનમાં, ઔપચારિક ભાષાઓનો ઉપયોગ પ્રોગ્રામિંગ ભાષાઓના વ્યાકરણને વ્યાખ્યાયિત કરવા માટેના આધાર તરીકે થાય છે અને પ્રાકૃતિક ભાષાઓના સબસેટના ઔપચારિક સંસ્કરણો જેમાં ભાષાના શબ્દો ચોક્કસ અર્થો અથવા સિમેન્ટિક્સ સાથે સંકળાયેલા ખ્યાલોનું પ્રતિનિધિત્વ કરે છે. કોમ્પ્યુટેશનલ જટિલતા સિદ્ધાંતમાં, નિર્ણય સમસ્યાઓ સામાન્ય રીતે ઔપચારિક ભાષાઓ તરીકે વ્યાખ્યાયિત કરવામાં આવે છે અને જટિલતા વર્ગોને ઔપચારિક ભાષાઓના સમૂહ તરીકે વ્યાખ્યાયિત કરવામાં આવે છે જે મર્યાદિત કોમ્પ્યુટેશનલ પાવર સાથે મશીનો દ્વારા વિશ્લેષિત કરી શકાય છે. તર્કશાસ્ત્ર અને ગણિતના પાયામાં, ઔપચારિક ભાષાઓનો ઉપયોગ સ્વયંસિદ્ધ પ્રણાલીઓના વાક્યરચનાનું પ્રતિનિધિત્વ કરવા માટે થાય છે, અને ગાણિતિક ઔપચારિકતા એ ફિલસૂફી છે કે તમામ ગણિતને આ રીતે ઔપચારિક ભાષાઓના સિન્ટેક્ટિક મેનીપ્યુલેશનમાં ઘટાડી શકાય છે.

### કોમ્પ્યુટીબિલિટી થિયરી
કોમ્પ્યુટીબિલિટી થિયરી, જેને રિકર્ઝન થિયરી તરીકે પણ ઓળખવામાં આવે છે, તે ગાણિતિક તર્કશાસ્ત્ર, કોમ્પ્યુટર વિજ્ઞાન અને ગણતરીના સિદ્ધાંતની એક શાખા છે જેનો ઉદ્દભવ 1930ના દાયકામાં ગણતરીપાત્ર કાર્યો અને ટ્યુરિંગ ડિગ્રીના અભ્યાસ સાથે થયો હતો. ત્યારથી આ ક્ષેત્ર સામાન્યકૃત ગણતરીક્ષમતા અને વ્યાખ્યાયિતતાના અભ્યાસને સમાવવા માટે વિસ્તરણ પામ્યું છે. આ વિસ્તારોમાં, કોમ્પ્યુટીબિલિટી સિદ્ધાંત સાબિતી સિદ્ધાંત અને અસરકારક વર્ણનાત્મક સમૂહ સિદ્ધાંત સાથે ઓવરલેપ થાય છે.

### કોમ્પ્યુટેશનલ જટિલતા સિદ્ધાંત
સૈદ્ધાંતિક કોમ્પ્યુટર વિજ્ઞાન અને ગણિતમાં, કોમ્પ્યુટેશનલ જટિલતા સિદ્ધાંત કોમ્પ્યુટેશનલ સમસ્યાઓને તેમના સંસાધન વપરાશ અનુસાર વર્ગીકૃત કરવા અને આ વર્ગોને એકબીજા સાથે સંબંધિત કરવા પર ધ્યાન કેન્દ્રિત કરે છે. કોમ્પ્યુટેશનલ પ્રોબ્લેમ એ કોમ્પ્યુટર દ્વારા હલ કરવામાં આવેલ કાર્ય છે. ગણતરીની સમસ્યા ગાણિતિક પગલાંની યાંત્રિક એપ્લિકેશન દ્વારા ઉકેલી શકાય છે, જેમ કે અલ્ગોરિધમ.

સમસ્યાને સ્વાભાવિક રીતે મુશ્કેલ ગણવામાં આવે છે જો તેના ઉકેલ માટે નોંધપાત્ર સંસાધનોની જરૂર હોય, ભલે ગમે તે અલ્ગોરિધમનો ઉપયોગ કરવામાં આવે. થિયરી આ સમસ્યાઓનો અભ્યાસ કરવા માટે ગણતરીના ગાણિતિક મોડલ રજૂ કરીને અને તેમની કોમ્પ્યુટેશનલ જટિલતાને પરિમાણ આપીને આ અંતર્જ્ઞાનને ઔપચારિક બનાવે છે, એટલે કે, તેમને ઉકેલવા માટે જરૂરી સંસાધનોની સંખ્યા, જેમ કે સમય અને સંગ્રહ. જટિલતાના અન્ય માપદંડોનો પણ ઉપયોગ થાય છે, જેમ કે સંચારની માત્રા (સંચાર જટિલતામાં વપરાય છે), સર્કિટમાં ગેટની સંખ્યા (સર્કિટ જટિલતામાં વપરાય છે), અને પ્રોસેસર્સની સંખ્યા (સમાંતર કમ્પ્યુટિંગમાં વપરાય છે). કોમ્પ્યુટેશનલ કોમ્પ્લેક્સિટી થિયરીની એક ભૂમિકા એ છે કે કમ્પ્યુટર શું કરી શકે અને શું ન કરી શકે તેની વ્યવહારિક મર્યાદા નક્કી કરવી. P વિરુદ્ધ NP સમસ્યા, સાત સહસ્ત્રાબ્દી પુરસ્કાર સમસ્યાઓમાંથી એક, કોમ્પ્યુટેશનલ જટિલતાના ક્ષેત્રને સમર્પિત છે.[1]

સૈદ્ધાંતિક કમ્પ્યુટર વિજ્ઞાનમાં નજીકથી સંબંધિત ક્ષેત્રો એલ્ગોરિધમ્સ અને કોમ્પ્યુટીબિલિટી સિદ્ધાંતનું વિશ્લેષણ છે. અલ્ગોરિધમ્સના વિશ્લેષણ અને કોમ્પ્યુટેશનલ કોમ્પ્લેક્સિટી થિયરી વચ્ચેનો મુખ્ય તફાવત એ છે કે પહેલાનો કોઈ ચોક્કસ અલ્ગોરિધમ દ્વારા સમસ્યાને ઉકેલવા માટે જરૂરી સંસાધનોની સંખ્યાનું વિશ્લેષણ કરવા માટે સમર્પિત છે, જ્યારે બાદમાં ઉપયોગમાં લઈ શકાય તેવા તમામ સંભવિત અલ્ગોરિધમ્સ વિશે વધુ સામાન્ય પ્રશ્ન પૂછે છે. સમાન સમસ્યા હલ કરવા માટે. વધુ સ્પષ્ટ રીતે, કોમ્પ્યુટેશનલ કોમ્પ્લેક્સિટી થિયરી એવી સમસ્યાઓનું વર્ગીકરણ કરવાનો પ્રયાસ કરે છે કે જે યોગ્ય રીતે પ્રતિબંધિત સંસાધનો સાથે ઉકેલી શકાય કે ન કરી શકાય. બદલામાં, ઉપલબ્ધ સંસાધનો પર નિયંત્રણો લાદવા એ કોમ્પ્યુટેશનલ જટિલતાને કોમ્પ્યુટેબલ થિયરીથી અલગ પાડે છે: પછીનો સિદ્ધાંત પૂછે છે કે કયા પ્રકારની સમસ્યાઓ, સૈદ્ધાંતિક રીતે, અલ્ગોરિધમિક રીતે ઉકેલી શકાય છે.

 
## ફાળો આપનારા

<!-- ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->
<table>
  <tbody>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="http://safayat.me"><img src="https://avatars.githubusercontent.com/u/80335059?v=4?s=50" width="50px;" alt="Sifat"/><br /><sub><b>Sifat</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=shhossain" title="Code">💻</a> <a href="#content-shhossain" title="Content">🖋</a> <a href="https://github.com/shhossain/computer_science/commits?author=shhossain" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Sabine91"><img src="https://avatars.githubusercontent.com/u/96158726?v=4?s=50" width="50px;" alt="Yuvraj Chauhan"/><br /><sub><b>Yuvraj Chauhan</b></sub></a><br /><a href="#content-Sabine91" title="Content">🖋</a> <a href="https://github.com/shhossain/computer_science/commits?author=Sabine91" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Rajesh144142"><img src="https://avatars.githubusercontent.com/u/82487522?v=4?s=50" width="50px;" alt="Rajesh kumar halder"/><br /><sub><b>Rajesh kumar halder</b></sub></a><br /><a href="#content-Rajesh144142" title="Content">🖋</a> <a href="https://github.com/shhossain/computer_science/commits?author=Rajesh144142" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=Rajesh144142" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://ishanmondal.me"><img src="https://avatars.githubusercontent.com/u/76674591?v=4?s=50" width="50px;" alt="Ishan Mondal"/><br /><sub><b>Ishan Mondal</b></sub></a><br /><a href="#content-ishan-im" title="Content">🖋</a> <a href="https://github.com/shhossain/computer_science/commits?author=ishan-im" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Apoorva08102000"><img src="https://avatars.githubusercontent.com/u/91753868?v=4?s=50" width="50px;" alt="Apoorva08102000"/><br /><sub><b>Apoorva08102000</b></sub></a><br /><a href="#content-Apoorva08102000" title="Content">🖋</a> <a href="https://github.com/shhossain/computer_science/commits?author=Apoorva08102000" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/apoorva1823000"><img src="https://avatars.githubusercontent.com/u/71769587?v=4?s=50" width="50px;" alt="Apoorva .S. Mehta"/><br /><sub><b>Apoorva .S. Mehta</b></sub></a><br /><a href="#content-apoorva1823000" title="Content">🖋</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/utopian-coder"><img src="https://avatars.githubusercontent.com/u/66299782?v=4?s=50" width="50px;" alt="Imran Biswas"/><br /><sub><b>Imran Biswas</b></sub></a><br /><a href="#content-utopian-coder" title="Content">🖋</a> <a href="https://github.com/shhossain/computer_science/commits?author=utopian-coder" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=utopian-coder" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/subrata-9999"><img src="https://avatars.githubusercontent.com/u/109057053?v=4?s=50" width="50px;" alt="Subrata Pramanik"/><br /><sub><b>Subrata Pramanik</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=subrata-9999" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=subrata-9999" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://br.linkedin.com/in/samuelbratifavarin"><img src="https://avatars.githubusercontent.com/u/17628602?v=4?s=50" width="50px;" alt="Samuel Favarin"/><br /><sub><b>Samuel Favarin</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=SamuelBFavarin" title="Documentation">📖</a> <a href="https://github.com/shhossain/computer_science/commits?author=SamuelBFavarin" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/sahooabhipsa10"><img src="https://avatars.githubusercontent.com/u/99355886?v=4?s=50" width="50px;" alt="sahooabhipsa10"/><br /><sub><b>sahooabhipsa10</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=sahooabhipsa10" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Sahilrao09"><img src="https://avatars.githubusercontent.com/u/88286056?v=4?s=50" width="50px;" alt="Sahil Rao"/><br /><sub><b>Sahil Rao</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Sahilrao09" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Code-N-Bug"><img src="https://avatars.githubusercontent.com/u/103832013?v=4?s=50" width="50px;" alt="K K Chowdhury"/><br /><sub><b>K K Chowdhury</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Code-N-Bug" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=Code-N-Bug" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://manas6699.github.io/portfolio-website3.0/"><img src="https://avatars.githubusercontent.com/u/78929050?v=4?s=50" width="50px;" alt="Manas Baroi"/><br /><sub><b>Manas Baroi</b></sub></a><br /><a href="#example-manas6699" title="Examples">💡</a> <a href="https://github.com/shhossain/computer_science/commits?author=manas6699" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/kanaujiyaaditi"><img src="https://avatars.githubusercontent.com/u/94130073?v=4?s=50" width="50px;" alt="Aditi"/><br /><sub><b>Aditi</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=kanaujiyaaditi" title="Documentation">📖</a> <a href="#content-kanaujiyaaditi" title="Content">🖋</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Talib-Hossain"><img src="https://avatars.githubusercontent.com/u/83373885?v=4?s=50" width="50px;" alt="Syed Talib Hossain"/><br /><sub><b>Syed Talib Hossain</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Talib-Hossain" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/JaiMehrotra02"><img src="https://avatars.githubusercontent.com/u/94130223?v=4?s=50" width="50px;" alt="Jai Mehrotra"/><br /><sub><b>Jai Mehrotra</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=JaiMehrotra02" title="Documentation">📖</a> <a href="https://github.com/shhossain/computer_science/commits?author=JaiMehrotra02" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ShuvamBag"><img src="https://avatars.githubusercontent.com/u/82321197?v=4?s=50" width="50px;" alt="Shuvam Bag"/><br /><sub><b>Shuvam Bag</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ShuvamBag" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=ShuvamBag" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/AbhijitTurate"><img src="https://avatars.githubusercontent.com/u/46615905?v=4?s=50" width="50px;" alt="Abhijit Turate"/><br /><sub><b>Abhijit Turate</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=AbhijitTurate" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=AbhijitTurate" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Jayesh2812"><img src="https://avatars.githubusercontent.com/u/52153715?v=4?s=50" width="50px;" alt="Jayesh Deorukhkar"/><br /><sub><b>Jayesh Deorukhkar</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Jayesh2812" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/SohamDey80"><img src="https://avatars.githubusercontent.com/u/93932583?v=4?s=50" width="50px;" alt="JC Shankar"/><br /><sub><b>JC Shankar</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=SohamDey80" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=SohamDey80" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Subrata-Pramanik"><img src="https://avatars.githubusercontent.com/u/86642230?v=4?s=50" width="50px;" alt="Subrata Pramanik"/><br /><sub><b>Subrata Pramanik</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Subrata-Pramanik" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=Subrata-Pramanik" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/imams12"><img src="https://avatars.githubusercontent.com/u/59444865?v=4?s=50" width="50px;" alt="Imam Suyuti"/><br /><sub><b>Imam Suyuti</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=imams12" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/rahulmangla28"><img src="https://avatars.githubusercontent.com/u/93324315?v=4?s=50" width="50px;" alt="genius_koder"/><br /><sub><b>genius_koder</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=rahulmangla28" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://www.altafshaikh.ml"><img src="https://avatars.githubusercontent.com/u/26015187?v=4?s=50" width="50px;" alt="Altaf Shaikh"/><br /><sub><b>Altaf Shaikh</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=altafshaikh" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/rajdeepdas2000"><img src="https://avatars.githubusercontent.com/u/53941109?v=4?s=50" width="50px;" alt="Rajdeep Das"/><br /><sub><b>Rajdeep Das</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=rajdeepdas2000" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/its-red-eagle"><img src="https://avatars.githubusercontent.com/u/77643994?v=4?s=50" width="50px;" alt="Vikash Patel"/><br /><sub><b>Vikash Patel</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=its-red-eagle" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/alwenpy"><img src="https://avatars.githubusercontent.com/u/94129388?v=4?s=50" width="50px;" alt="Arvind Srivastav"/><br /><sub><b>Arvind Srivastav</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=alwenpy" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Naprila"><img src="https://avatars.githubusercontent.com/u/85901005?v=4?s=50" width="50px;" alt="Manish Kr Prasad"/><br /><sub><b>Manish Kr Prasad</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Naprila" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://linktr.ee/mohit_kushwaha"><img src="https://avatars.githubusercontent.com/u/73400792?v=4?s=50" width="50px;" alt="MOHIT KUMAR KUSHWAHA"/><br /><sub><b>MOHIT KUMAR KUSHWAHA</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=KimtVak8143" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/DryHitman"><img src="https://avatars.githubusercontent.com/u/116108787?v=4?s=50" width="50px;" alt="DryHitman"/><br /><sub><b>DryHitman</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=DryHitman" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/harshkulkarni17"><img src="https://avatars.githubusercontent.com/u/72391096?v=4?s=50" width="50px;" alt="Harsh Kulkarni"/><br /><sub><b>Harsh Kulkarni</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=harshkulkarni17" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ATREAY"><img src="https://avatars.githubusercontent.com/u/66585295?v=4?s=50" width="50px;" alt="Atreay  Kukanur"/><br /><sub><b>Atreay  Kukanur</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ATREAY" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://sreeharan.github.io"><img src="https://avatars.githubusercontent.com/u/62993067?v=4?s=50" width="50px;" alt="Sree Haran"/><br /><sub><b>Sree Haran</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=SreeHaran" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://www.linkedin.com/in/auro-saswat-raj-d05m07y2003/"><img src="https://avatars.githubusercontent.com/u/83534307?v=4?s=50" width="50px;" alt="Auro Saswat Raj"/><br /><sub><b>Auro Saswat Raj</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=geeky-auro" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Aiyan-Faras"><img src="https://avatars.githubusercontent.com/u/55203889?v=4?s=50" width="50px;" alt="Aiyan Faras"/><br /><sub><b>Aiyan Faras</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Aiyan-Faras" title="Documentation">📖</a> <a href="https://github.com/shhossain/computer_science/commits?author=Aiyan-Faras" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/PriyanshiDavid"><img src="https://avatars.githubusercontent.com/u/71930453?v=4?s=50" width="50px;" alt="Priyanshi David"/><br /><sub><b>Priyanshi David</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=PriyanshiDavid" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ishancode-dev"><img src="https://avatars.githubusercontent.com/u/115942220?v=4?s=50" width="50px;" alt="Ishan Mondal"/><br /><sub><b>Ishan Mondal</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ishancode-dev" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://expy.bio/NikhilShrivastava"><img src="https://avatars.githubusercontent.com/u/20610444?v=4?s=50" width="50px;" alt="Nikhil Shrivastava"/><br /><sub><b>Nikhil Shrivastava</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=NikhilShrivastava" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/deepshikha2708"><img src="https://avatars.githubusercontent.com/u/80972038?v=4?s=50" width="50px;" alt="deepshikha2708"/><br /><sub><b>deepshikha2708</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=deepshikha2708" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/rishiwardhan"><img src="https://avatars.githubusercontent.com/u/88772100?v=4?s=50" width="50px;" alt="L.RISHIWARDHAN"/><br /><sub><b>L.RISHIWARDHAN</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=rishiwardhan" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/DevTMK"><img src="https://avatars.githubusercontent.com/u/47377566?v=4?s=50" width="50px;" alt="Rahul RK"/><br /><sub><b>Rahul RK</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=DevTMK" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://www.linkedin.com/company/nscc-ggv/"><img src="https://avatars.githubusercontent.com/u/82573863?v=4?s=50" width="50px;" alt="Nishant Wankhade"/><br /><sub><b>Nishant Wankhade</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=NishantWankhade" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/pritika163"><img src="https://avatars.githubusercontent.com/u/102177744?v=4?s=50" width="50px;" alt="pritika163"/><br /><sub><b>pritika163</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=pritika163" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/AnjumanHasan"><img src="https://avatars.githubusercontent.com/u/82674743?v=4?s=50" width="50px;" alt="Anjuman Hasan"/><br /><sub><b>Anjuman Hasan</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=AnjumanHasan" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://linktr.ee/asthavarshney"><img src="https://avatars.githubusercontent.com/u/97240696?v=4?s=50" width="50px;" alt="Astha Varshney "/><br /><sub><b>Astha Varshney </b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Asthavarshneyy" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Gcettbdeveloper"><img src="https://avatars.githubusercontent.com/u/114204175?v=4?s=50" width="50px;" alt="Gcettbdeveloper"/><br /><sub><b>Gcettbdeveloper</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Gcettbdeveloper" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://elston-website.web.app"><img src="https://avatars.githubusercontent.com/u/66341506?v=4?s=50" width="50px;" alt="Elston Tan"/><br /><sub><b>Elston Tan</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Elstuhn" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ShivanshDengla"><img src="https://avatars.githubusercontent.com/u/66008449?v=4?s=50" width="50px;" alt="Shivansh Dengla"/><br /><sub><b>Shivansh Dengla</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ShivanshDengla" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://www.tetricz.com"><img src="https://avatars.githubusercontent.com/u/49681400?v=4?s=50" width="50px;" alt="David Daniels"/><br /><sub><b>David Daniels</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Tetricz" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ayushverma14"><img src="https://avatars.githubusercontent.com/u/65187507?v=4?s=50" width="50px;" alt="ayushverma14"/><br /><sub><b>ayushverma14</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ayushverma14" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://kontentkreator.tech"><img src="https://avatars.githubusercontent.com/u/70800059?v=4?s=50" width="50px;" alt="Pratik Rai"/><br /><sub><b>Pratik Rai</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=pratikkumar399" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/yash-ch"><img src="https://avatars.githubusercontent.com/u/66888087?v=4?s=50" width="50px;" alt="Yash"/><br /><sub><b>Yash</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=yash-ch" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/pranavyatnalkar"><img src="https://avatars.githubusercontent.com/u/84735288?v=4?s=50" width="50px;" alt="pranavyatnalkar"/><br /><sub><b>pranavyatnalkar</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=pranavyatnalkar" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/jeremiaaxel"><img src="https://avatars.githubusercontent.com/u/57858415?v=4?s=50" width="50px;" alt="Jeremia Axel"/><br /><sub><b>Jeremia Axel</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=jeremiaaxel" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://in.linkedin.com/in/akhil-soni-9827181a1"><img src="https://avatars.githubusercontent.com/u/58397226?v=4?s=50" width="50px;" alt="Akhil Soni"/><br /><sub><b>Akhil Soni</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=akhil-maker" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/DevZahraShahid"><img src="https://avatars.githubusercontent.com/u/111266434?v=4?s=50" width="50px;" alt="Zahra Shahid"/><br /><sub><b>Zahra Shahid</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=DevZahraShahid" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Mihir20K"><img src="https://avatars.githubusercontent.com/u/112269999?v=4?s=50" width="50px;" alt="Mihir20K"/><br /><sub><b>Mihir20K</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Mihir20K" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/computerwala"><img src="https://avatars.githubusercontent.com/u/30777038?v=4?s=50" width="50px;" alt="Aman"/><br /><sub><b>Aman</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=computerwala" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/mauriallegrettiswnat"><img src="https://avatars.githubusercontent.com/u/71467262?v=4?s=50" width="50px;" alt="Mauricio Allegretti"/><br /><sub><b>Mauricio Allegretti</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=mauriallegrettiswnat" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Bruno-Vasconcellos-Betella"><img src="https://avatars.githubusercontent.com/u/57138664?v=4?s=50" width="50px;" alt="Bruno-Vasconcellos-Betella"/><br /><sub><b>Bruno-Vasconcellos-Betella</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Bruno-Vasconcellos-Betella" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://itdadakan.site"><img src="https://avatars.githubusercontent.com/u/62456215?v=4?s=50" width="50px;" alt="Febi Arifin"/><br /><sub><b>Febi Arifin</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=febiarifin" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/dinesh9-ai"><img src="https://avatars.githubusercontent.com/u/63300423?v=4?s=50" width="50px;" alt="Dineshwar Doddapaneni"/><br /><sub><b>Dineshwar Doddapaneni</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=dinesh9-ai" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Dheerajsoni93"><img src="https://avatars.githubusercontent.com/u/82114565?v=4?s=50" width="50px;" alt="Dheeraj_Soni"/><br /><sub><b>Dheeraj_Soni</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Dheerajsoni93" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://www.linkedin.com/in/ojash-kushwaha-791770185"><img src="https://avatars.githubusercontent.com/u/96474959?v=4?s=50" width="50px;" alt="Ojash Kushwaha"/><br /><sub><b>Ojash Kushwaha</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=OjashKush" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Sleep-lover"><img src="https://avatars.githubusercontent.com/u/82304155?v=4?s=50" width="50px;" alt="Laleet Borse"/><br /><sub><b>Laleet Borse</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Sleep-lover" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Wahaj-Raza"><img src="https://avatars.githubusercontent.com/u/103155321?v=4?s=50" width="50px;" alt="Wahaj Raza"/><br /><sub><b>Wahaj Raza</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Wahaj-Raza" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/WahajRaza1"><img src="https://avatars.githubusercontent.com/u/90937190?v=4?s=50" width="50px;" alt="WahajRaza1"/><br /><sub><b>WahajRaza1</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=WahajRaza1" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://ravencolevol.github.io"><img src="https://avatars.githubusercontent.com/u/44892121?v=4?s=50" width="50px;" alt="Ravi Lamkoti"/><br /><sub><b>Ravi Lamkoti</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=RavenColEvol" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/UperscuzziSchoolAcc"><img src="https://avatars.githubusercontent.com/u/111448336?v=4?s=50" width="50px;" alt="The One and Only Uper"/><br /><sub><b>The One and Only Uper</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=UperscuzziSchoolAcc" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/AdarshBajpai67"><img src="https://avatars.githubusercontent.com/u/95476086?v=4?s=50" width="50px;" alt="AdarshBajpai67"/><br /><sub><b>AdarshBajpai67</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=AdarshBajpai67" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://deepakkharah.me"><img src="https://avatars.githubusercontent.com/u/42672761?v=4?s=50" width="50px;" alt="Deepak Kharah"/><br /><sub><b>Deepak Kharah</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Deepak-Kharah" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/sairohit360"><img src="https://avatars.githubusercontent.com/u/55144209?v=4?s=50" width="50px;" alt="sairohit360"/><br /><sub><b>sairohit360</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=sairohit360" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/sairohitzl"><img src="https://avatars.githubusercontent.com/u/86225259?v=4?s=50" width="50px;" alt="sairohitzl"/><br /><sub><b>sairohitzl</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=sairohitzl" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/RavalJinit"><img src="https://avatars.githubusercontent.com/u/72157334?v=4?s=50" width="50px;" alt="Raval Jinit"/><br /><sub><b>Raval Jinit</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=RavalJinit" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Vovka1759"><img src="https://avatars.githubusercontent.com/u/75867274?v=4?s=50" width="50px;" alt="Vovka1759"/><br /><sub><b>Vovka1759</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Vovka1759" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Nijin-P-S"><img src="https://avatars.githubusercontent.com/u/101330853?v=4?s=50" width="50px;" alt="Nijin"/><br /><sub><b>Nijin</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Nijin-P-S" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/avinilcode"><img src="https://avatars.githubusercontent.com/u/111761529?v=4?s=50" width="50px;" alt="Avinil Bedarkar"/><br /><sub><b>Avinil Bedarkar</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=avinilcode" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/FercueNat"><img src="https://avatars.githubusercontent.com/u/113535859?v=4?s=50" width="50px;" alt="FercueNat"/><br /><sub><b>FercueNat</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=FercueNat" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://khareyash05.github.io/home/"><img src="https://avatars.githubusercontent.com/u/60147732?v=4?s=50" width="50px;" alt="Yash Khare"/><br /><sub><b>Yash Khare</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=khareyash05" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ayushanand16"><img src="https://avatars.githubusercontent.com/u/96689639?v=4?s=50" width="50px;" alt="Ayush Anand"/><br /><sub><b>Ayush Anand</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ayushanand16" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/DharmaWarrior"><img src="https://avatars.githubusercontent.com/u/97218268?v=4?s=50" width="50px;" alt="DharmaWarrior"/><br /><sub><b>DharmaWarrior</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=DharmaWarrior" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://linktr.ee/hitarthraval"><img src="https://avatars.githubusercontent.com/u/62943532?v=4?s=50" width="50px;" alt="Hitarth Raval"/><br /><sub><b>Hitarth Raval</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=hitarthraval" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/WiemBorchani"><img src="https://avatars.githubusercontent.com/u/52404192?v=4?s=50" width="50px;" alt="Wiem Borchani "/><br /><sub><b>Wiem Borchani </b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=WiemBorchani" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Kambo2320"><img src="https://avatars.githubusercontent.com/u/98479408?v=4?s=50" width="50px;" alt="Kamden Burke"/><br /><sub><b>Kamden Burke</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Kambo2320" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/denschiro"><img src="https://avatars.githubusercontent.com/u/6161324?v=4?s=50" width="50px;" alt="denschiro"/><br /><sub><b>denschiro</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=denschiro" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/nishat48"><img src="https://avatars.githubusercontent.com/u/109063023?v=4?s=50" width="50px;" alt="Nishat"/><br /><sub><b>Nishat</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=nishat48" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/mdfaizanahmed786"><img src="https://avatars.githubusercontent.com/u/85175130?v=4?s=50" width="50px;" alt="Mohammed Faizan Ahmed"/><br /><sub><b>Mohammed Faizan Ahmed</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=mdfaizanahmed786" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/manish831"><img src="https://avatars.githubusercontent.com/u/74316266?v=4?s=50" width="50px;" alt="Manish Agrahari"/><br /><sub><b>Manish Agrahari</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=manish831" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/lokesh-katari"><img src="https://avatars.githubusercontent.com/u/111894942?v=4?s=50" width="50px;" alt="Katari Lokeswara rao"/><br /><sub><b>Katari Lokeswara rao</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=lokesh-katari" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://g.dev/ZahraShahid"><img src="https://avatars.githubusercontent.com/u/65255043?v=4?s=50" width="50px;" alt="Zahra Shahid"/><br /><sub><b>Zahra Shahid</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ZahraShahid" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/glenntu15"><img src="https://avatars.githubusercontent.com/u/10324492?v=4?s=50" width="50px;" alt="Glenn Turner"/><br /><sub><b>Glenn Turner</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=glenntu15" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/vinayak9303"><img src="https://avatars.githubusercontent.com/u/55548976?v=4?s=50" width="50px;" alt="Vinayak godse"/><br /><sub><b>Vinayak godse</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=vinayak9303" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Satyajeetbh"><img src="https://avatars.githubusercontent.com/u/88246318?v=4?s=50" width="50px;" alt="Satyajeetbh"/><br /><sub><b>Satyajeetbh</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Satyajeetbh" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/P-Dhruva-Teja"><img src="https://avatars.githubusercontent.com/u/81409709?v=4?s=50" width="50px;" alt="Paidipelly Dhruvateja"/><br /><sub><b>Paidipelly Dhruvateja</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=P-Dhruva-Teja" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/helloausrine"><img src="https://avatars.githubusercontent.com/u/30316810?v=4?s=50" width="50px;" alt="helloausrine"/><br /><sub><b>helloausrine</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=helloausrine" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/SourabhJoshi209"><img src="https://avatars.githubusercontent.com/u/69594540?v=4?s=50" width="50px;" alt="SourabhJoshi209"/><br /><sub><b>SourabhJoshi209</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=SourabhJoshi209" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://bio.link/stefantaitano"><img src="https://avatars.githubusercontent.com/u/85418632?v=4?s=50" width="50px;" alt="Stefan Taitano"/><br /><sub><b>Stefan Taitano</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=codewithfan" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://linkedin.com/in/anmspro"><img src="https://avatars.githubusercontent.com/u/33668152?v=4?s=50" width="50px;" alt="Abu Noman Md. Sakib"/><br /><sub><b>Abu Noman Md. Sakib</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=anmspro" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://skyrunner360.pythonanywhere.com"><img src="https://avatars.githubusercontent.com/u/44318840?v=4?s=50" width="50px;" alt="Rishi Mathur"/><br /><sub><b>Rishi Mathur</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=skyrunner360" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Atharv-Nalwade"><img src="https://avatars.githubusercontent.com/u/98139553?v=4?s=50" width="50px;" alt="Darky001"/><br /><sub><b>Darky001</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Atharv-Nalwade" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Retr0Sushi"><img src="https://avatars.githubusercontent.com/u/110653014?v=4?s=50" width="50px;" alt="himanshu"/><br /><sub><b>himanshu</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Retr0Sushi" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/kusumita29"><img src="https://avatars.githubusercontent.com/u/99873488?v=4?s=50" width="50px;" alt="Kusumita Ghose"/><br /><sub><b>Kusumita Ghose</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=kusumita29" title="Documentation">📖</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Yash1107"><img src="https://avatars.githubusercontent.com/u/76468153?v=4?s=50" width="50px;" alt="Yashvi Patel"/><br /><sub><b>Yashvi Patel</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Yash1107" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ArshadAriff"><img src="https://avatars.githubusercontent.com/u/113685884?v=4?s=50" width="50px;" alt="ArshadAriff"/><br /><sub><b>ArshadAriff</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ArshadAriff" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/ishashukla183"><img src="https://avatars.githubusercontent.com/u/93022787?v=4?s=50" width="50px;" alt="ishashukla183"/><br /><sub><b>ishashukla183</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=ishashukla183" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/jhuynh06"><img src="https://avatars.githubusercontent.com/u/111946833?v=4?s=50" width="50px;" alt="jhuynh06"/><br /><sub><b>jhuynh06</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/issues?q=author%3Ajhuynh06" title="Bug reports">🐛</a> <a href="https://github.com/shhossain/computer_science/commits?author=jhuynh06" title="Tests">⚠️</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://asche.tech"><img src="https://avatars.githubusercontent.com/u/2975712?v=4?s=50" width="50px;" alt="Andrew Asche"/><br /><sub><b>Andrew Asche</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=andrewasche" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="http://nateonmission.github.io"><img src="https://avatars.githubusercontent.com/u/37854313?v=4?s=50" width="50px;" alt="J. Nathan Allen"/><br /><sub><b>J. Nathan Allen</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/issues?q=author%3Anateonmission" title="Bug reports">🐛</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Sayed-Afnan-Khazi"><img src="https://avatars.githubusercontent.com/u/83779299?v=4?s=50" width="50px;" alt="Sayed Afnan Khazi"/><br /><sub><b>Sayed Afnan Khazi</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Sayed-Afnan-Khazi" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Technic143"><img src="https://avatars.githubusercontent.com/u/117275755?v=4?s=50" width="50px;" alt="Technic143"/><br /><sub><b>Technic143</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Technic143" title="Documentation">📖</a> <a href="https://github.com/shhossain/computer_science/issues?q=author%3ATechnic143" title="Bug reports">🐛</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/snowflake1201"><img src="https://avatars.githubusercontent.com/u/56119216?v=4?s=50" width="50px;" alt="Pin Yuan Wang"/><br /><sub><b>Pin Yuan Wang</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=snowflake1201" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/BogdanOtava"><img src="https://avatars.githubusercontent.com/u/103674688?v=4?s=50" width="50px;" alt="Bogdan Otava"/><br /><sub><b>Bogdan Otava</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=BogdanOtava" title="Code">💻</a> <a href="https://github.com/shhossain/computer_science/commits?author=BogdanOtava" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Vedeesh6"><img src="https://avatars.githubusercontent.com/u/88491153?v=4?s=50" width="50px;" alt="Vedeesh Dwivedi"/><br /><sub><b>Vedeesh Dwivedi</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/issues?q=author%3AVedeesh6" title="Bug reports">🐛</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/TsiG-404"><img src="https://avatars.githubusercontent.com/u/74056836?v=4?s=50" width="50px;" alt="Tsig"/><br /><sub><b>Tsig</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=TsiG-404" title="Code">💻</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://brandonawan.github.io/Resume/"><img src="https://avatars.githubusercontent.com/u/74030681?v=4?s=50" width="50px;" alt="Brandon Awan"/><br /><sub><b>Brandon Awan</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Brandonawan" title="Documentation">📖</a> <a href="https://github.com/shhossain/computer_science/issues?q=author%3ABrandonawan" title="Bug reports">🐛</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Evy04"><img src="https://avatars.githubusercontent.com/u/84919650?v=4?s=50" width="50px;" alt="Sanya Madre"/><br /><sub><b>Sanya Madre</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=Evy04" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/steventohme"><img src="https://avatars.githubusercontent.com/u/56594084?v=4?s=50" width="50px;" alt="Steven"/><br /><sub><b>Steven</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=steventohme" title="Documentation">📖</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://www.linkedin.com/in/garrett-crowley-a0b931126/"><img src="https://avatars.githubusercontent.com/u/86014840?v=4?s=50" width="50px;" alt="Garrett Crowley"/><br /><sub><b>Garrett Crowley</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/commits?author=crowleyg" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Francesco601"><img src="https://avatars.githubusercontent.com/u/130352141?v=4?s=50" width="50px;" alt="Francesco Franco"/><br /><sub><b>Francesco Franco</b></sub></a><br /><a href="https://github.com/shhossain/computer_science/issues?q=author%3AFrancesco601" title="Bug reports">🐛</a> <a href="https://github.com/shhossain/computer_science/commits?author=Francesco601" title="Code">💻</a></td>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/aclittle096"><img src="https://avatars.githubusercontent.com/u/43685369?v=4?s=50" width="50px;" alt="Alexander Little"/><br /><sub><b>Alexander Little</b></sub></a><br /><a href="#content-aclittle096" title="Content">🖋</a></td>
    </tr>
    <tr>
      <td align="center" valign="top" width="16.66%"><a href="https://github.com/Wandererr01"><img src="https://avatars.githubusercontent.com/u/129178279?v=4?s=50" width="50px;" alt="Subham Maji"/><br /><sub><b>Subham Maji</b></sub></a><br /><a href="#content-Wandererr01" title="Content">🖋</a></td>
    </tr>
  </tbody>
</table>

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->
<!-- prettier-ignore-start -->
<!-- markdownlint-disable -->

<!-- markdownlint-restore -->
<!-- prettier-ignore-end -->

<!-- ALL-CONTRIBUTORS-LIST:END -->
<!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section -->

[![All Contributors](https://img.shields.io/badge/all_contributors-104-orange.svg?style=flat-square)](#contributors)
<!-- ALL-CONTRIBUTORS-BADGE:END -->
