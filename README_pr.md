<h1 align="center">علوم رایانه</h1>
<h4 align="center">
    <p>
        <b>انگلیسی</b> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_it.md">ایتالیایی</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_es.md">اسپانیولی</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_fr.md">فرانسوی</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_bn.md">بنگالی</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_ta.md">تامیلی</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_guj.md">گجراتی</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_pt.md">پرتغالی</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_hi.md">هندی</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_te.md">تلوگو</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_ro.md">رومانیایی</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_ar.md">عربی</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_np.md">نپالی</a> |
        <a href="https://github.com/shhossain/computer_science/blob/main/README_cn.md">چینی ساده</a>
    </p>
</h4>

## راهنمای مشارکت
اگر به مشارکت در این پروژه علاقه مند هستید، لطفا لحظه ای برای بررسی [CONTRIBUTING.md](https://github.com/shhossain/computer_science/blob/main/CONTRIBUTING.md) برای دستورالعمل‌های جزئیات چگونگی شروع مشارکت خود مصرف کنید. مشارکت شما بسیار قدردانی خواهد شد!

<!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section -->
[![همه مشارکت‌کنندگان](https://img.shields.io/badge/all_contributors-160-orange.svg?style=flat-square)](#contributors-)
<!-- ALL-CONTRIBUTORS-BADGE:END -->

## فهرست مواضع

- [مقدمه](#introduction)
- [رایانه الکترونیکی](#electronic-computer)
- [منطق بولی](#boolean-logic)
- [مدارهای رقمی](#digital-circuits)
- [سیستم‌های عددی](#number-systems)
- [واحد پردازش مرکزی (CPU)](#central-processing-unit-cpu)
- [ثبت‌ها، کش و RAM](#registers-cache-and-ram)
- [دستورات و برنامه](#instructions-and-program)
- [زبان‌های برنامه‌نویسی](#programming-languages)
- [نوع‌های داده](#data-types)
- [دستورات و تابعات](#statements-and-functions)
- [ساختارهای داده](#data-structures)
- [الگوریتم‌ها](#algorithms)
- [آلان تورینگ](#alan-turing)
- [مهندسی نرم‌افزار](#software-engineering)
- [علم داده](#data-science)
- [مدارهای مجتمع](#integrated-circuits)
- [برنامه‌نویسی متمرکز بر شیء](#object-oriented-programming)
- [برنامه‌نویسی توصیفی](#functional-programming)
- [سیستم‌های عملیاتی](#operating-systems)
- [حافظه و ذخیره‌سازی](#memory-and-storage)
- [سیستم فایل](#file-system)
- [ابر محاسبه](#cloud-computing)
- [یادگیری ماشین](#machine-learning)
- [فناوری وب](#web-technology)
- [شبکه](#networking)
- [اینترنت](#internet)
- [سیستم مدیریت پایگان داده (DBMS)](#dbms)
- [رمزنگاری](#cryptography)
- [نظریه محاسبه](#theory-of-computation)
- [دوامعملیات (DevOps)](#devops)

## مقدمه
علوم رایانه مطالعه کامپیوترها و رایانه‌کردن و کاربردهای نظری و عملی آنها است. علوم رایانه اصول ریاضیات، مهندسی و منطق را به دامنه واسعی از مشکلات اعمال می‌کند. این مشکلات شامل فرمولاسیون الگوریتم، توسعه نرم‌افزار/سخت‌افزار و هوش مصنوعی می‌شود.

## [رایانه الکترونیکی](Electronic%20Computer/readme.md)
کامپیوتر دستگاهی است که برای انجام عملیات ریاضی، منطقی یا پردازش داده با سرعت بالا طراحی شده است. این یک ماشین الکترونیکی برنامه‌ریزی شده است که می‌تواند اطلاعات را به صورت مؤثر تجمیع، ذخیره، همبستگی و پردازش کند.

## [منطق بولی](Boolean%20Logic/readme.md)
منطق بولی شاخه‌ای از ریاضیات است که متمرکز بر مقادیر حقیقت، از جمله حقیقی و کذبی است. این با یک سیستم دویی عمل می‌کند که در آن 0 نماد کذب و 1 نماد حقیقت است. این سیستم به عنوان جبر بولی معروف است و اولین بار توسط جورج بول در سال 1854 معرفی شد.

### ہاراکترهای معمول منطق بولی
| ہاراکتر | نام |               توضیح               |
| :------: | :--: | :-------------------------------------: |
|    !     | NOT  | نقیضه کردن (معکوس) مقدار عملوند   |
|    &&    | AND  | بازمی‌گردانده حقیقت اگر هر دو عملوند حقیقی باشد. |
|   ∥   |  OR  | بازمی‌گردانده حقیقت اگر حداقل یک عملوند حقیقی باشد. |

### عملگرهای منطق بولی که دانستن آنها خوب است
| عملگر | نام |               توضیح               |
| :------: | :--: | :-------------------------------------: |
|    ()    | پارانتزیس     |   اجازه می‌دهد که کلمات کلیدی را گروه‌بندی نماید و ترتیب جستجوی این عبارات‌ها را کنترل نماید.    |
|    “”    | نقل قول | عبارات دقیق را نشان می‌دهد. |
|   *      |  ستاره       | نتایجی با واریاسیون کلمات کلیدی مورد نظر را نشان می‌دهد. |
|   ⊕     |  XOR            | حقیقت را بازمی‌گرداند اگر عملوندها متفاوت باشند |
|   ⊝      |  NOR            | بازمی‌گردانده حقیقت اگر تمام عملوندها کذب باشند. |
|   ⊜      |  NAND           | بازمی‌گردانده کذب تنها اگر مقادیر هر دو ورودی آن حقیقت باشد. |

## [مدارهای رقمی](Digital%20Circuits/readme.md)
مدارهای رقمی با سیگنال‌های بولی (یک و صفر) سروکار دارند. این مدارها بنیادی‌ترین بلوک‌های سازنده یک رایانه هستند. آنها اجزاء و مدارهای مورد استفاده برای ساخت واحدهای پردازش و واحدهای حافظه مورد نیاز به یک سیستم رایانه‌ای هستند.

### جداول حقیقت
جداول حقیقت جداول ریاضی هستند که در طراحی مدارهای منطق و رقمی به کار می‌روند. آنها در طراحی مدارهای پیچیده می‌توانند بسیار مفید باشند.

جداول حقیقت یک ستون برای هر ورودی و یک ستون نهایی برای نمایش نتایج ممکن عملیات منطقی مورد نظر دارند.

### انواع مدارهای رقمی
دو نوع مدار رقمی وجود دارد: ترکیبی و ترتیبی

- **مدارهای ترکیبی**: در این نوع مدارهای رقمی، خروجی بر ورودی آن در لحظه وابسته است. این نوع مدار ثابت با ورودی خود مانده است.
- **مدارهای ترتیبی**: در این نوع مدار خروجی همتوانه با ورودی امروز و هم با ورودی قبلی مورد نیاز باشد.

## [سیستم‌های عددی](Number%20System/readme.md#number-systems)
سیستم‌های عددی سیستم‌های ریاضی برای بیان اعداد هستند. یک سیستم عددی از یک مجموعه نماد است که برای نمایش اعداد استفاده می‌شود و از مجموعه‌ای قوانین برای دستکاری این نمادها شامل می‌شود.

### [انواع سیستم‌های عددی](Number%20System/readme.md#types-of-number-systems)
- [سیستم عددی موضعی](Number%20System/readme.md#positional-numeral-system)
- [سیستم نشانه‌گذاری عددی](Number%20System/readme.md#sign-value-notation-system)

### [سیستم‌های عددی موضعی رایج](Number%20System/readme.md#common-positional-number-systems)
- [دویی](Number%20System/readme.md#binary)
- [هشتگانی](Number%20System/readme.md#octal)
- [دهدهی](Number%20System/readme.md#decimal)
- [شانزدهگانی](Number%20System/readme.md#hexadecimal)

### اهمیت سیستم دویی
سیستم دویی یک سیستم عددی پایه 2 است که توسط گوتفرید لایب‌نیتس ابداع شد و شامل تنها دو رقم: 0 و 1 است. این سیستم پایه تمام کدهای دویی است که برای رمزگذاری داده‌های دیجیتال، از جمله دستورالعمل‌های پردازنده کامپیوتر، استفاده می‌شود. در سیستم دویی، ارقام حالت‌ها را نشان می‌دهند: 0 به معنای "خاموش" و 1 به معنای "روشن" است.

در ترانزیستورها، "0" نشانگر عدم جریان برق است، در حالی که "1" نشان‌دهنده جریان برق است. این نمایش فیزیکی اعداد به کامپیوترها امکان انجام محاسبات و عملیات را به‌طور مؤثر می‌دهد.

سیستم دویی همچنان زبان اصلی کامپیوترها است و به دلایل کلیدی زیر در الکترونیک و سخت‌افزار استفاده می‌شود:

- سادگی و کارایی: سیستم دویی طراحی زیبا و ساده‌ای دارد.
- تشخیص سیگنال: استفاده از 0 و 1 در سیستم دویی تشخیص این‌که آیا یک سیگنال الکتریکی خاموش (کاذب) یا روشن (حقیقی) است، را آسان می‌کند.
- مقاومت در برابر تداخل: با داشتن تنها دو حالت متمایز، سیگنال‌های دویی کمتر در معرض تداخل الکتریکی قرار می‌گیرند.
- ترجمه مغناطیسی: قطب‌های مثبت و منفی رسانه‌های مغناطیسی به راحتی به دویی تبدیل می‌شوند.
- کارایی مدارهای منطقی: سیستم دویی مؤثرترین سیستم برای کنترل مدارهای منطقی است.

## [واحد پردازش مرکزی (CPU)](CPU/readme.md#central-processing-unitcpu)
واحد پردازش مرکزی (CPU) مهمترین بخش هر رایانه است. CPU سیگنال‌هایی را برای کنترل بخش‌های دیگر رایانه ارسال می‌کند، تقریباً مانند این‌که مغز بدن را کنترل می‌کند. CPU یک ماشین الکترونیکی است که بر روی لیستی از کارهای کامپیوتری، به نام دستورات، کار می‌کند. آن لیست دستورات را می‌خواند و هر یک را به ترتیب اجرا می‌کند. لیستی از دستوراتی که CPU می‌تواند اجرا کند یک برنامه کامپیوتری است. یک CPU می‌تواند چند دستور را به‌طور هم‌زمان بر روی بخش‌هایی که "هسته" نامیده می‌شوند، پردازش کند. یک CPU با چهار هسته ممکن است چهار برنامه را به‌طور هم‌زمان پردازش کند. خود CPU از سه بخش اصلی تشکیل شده است. آنها عبارتند از:
1. [واحد حافظه یا ذخیره‌سازی](CPU/readme.md#memory-or-storage-unit)
2. [واحد کنترل](CPU/readme.md#control-unit)
3. [واحد حساب و منطق (ALU)](CPU/readme.md#arithmetic-and-logic-unit-alu)

## [ثبت‌ها، کش و RAM](/Registers%20Cache%20and%20RAM)

### [ثبت](/Registers%20Cache%20and%20RAM/readme.md#register)
ثبت‌ها مقادیر کوچکی از حافظه با سرعت بالا هستند که درون CPU قرار دارند. ثبت‌ها مجموعه‌ای از "فلیپ‌فلاپ"ها هستند (یک مدار که برای ذخیره 1 بیت حافظه استفاده می‌شود). آنها توسط پردازنده برای ذخیره مقادیر کوچک داده‌ای که در حین پردازش نیاز است استفاده می‌شوند. یک CPU ممکن است چندین مجموعه از ثبت‌ها داشته باشد که به آنها "هسته" گفته می‌شود. ثبت‌ها همچنین در عملیات حسابی و منطقی کمک می‌کنند.

عملیات حسابی محاسبات ریاضی هستند که توسط CPU بر روی داده‌های عددی ذخیره‌شده در ثبت‌ها انجام می‌شوند. این عملیات شامل جمع، تفریق، ضرب و تقسیم است. عملیات منطقی محاسبات بولی هستند که توسط CPU بر روی داده‌های دویی ذخیره‌شده در ثبت‌ها انجام می‌شوند. این عملیات شامل مقایسه‌ها (مثلاً تست این‌که آیا دو مقدار برابر هستند) و عملیات منطقی (مثلاً AND، OR، NOT) است.

ثبت‌ها برای انجام این عملیات ضروری هستند زیرا به CPU امکان می‌دهند که مقادیر کوچک داده را به‌سرعت دسترسی و دستکاری کند. با ذخیره داده‌هایی که به‌طور مکرر مورد دسترسی قرار می‌گیرند در ثبت‌ها، CPU می‌تواند از فرایند کندتر بازیابی داده از حافظه جلوگیری کند.

مقادیر بزرگتر داده ممکن است در کش (که "کش" تلفظ می‌شود) ذخیره شوند، یک حافظه بسیار سریع که بر روی همان مدار مجتمع به عنوان ثبت‌ها قرار دارد. کش برای داده‌هایی که به‌طور مکرر در حین اجرای برنامه مورد دسترسی قرار می‌گیرند استفاده می‌شود. حتی مقادیر بزرگتر داده ممکن است در RAM ذخیره شوند. RAM مخفف حافظه دسترسی تصادفی است که نوعی حافظه است که داده‌ها و دستوراتی که از ذخیره‌سازی دیسک منتقل شده‌اند تا زمانی که پردازنده به آنها نیاز داشته باشد را نگه می‌دارد.

### [کش](/Registers%20Cache%20and%20RAM/readme.md#cache)
حافظه کش یک مؤلفه رایانه‌ای مبتنی بر تراشه است که بازیابی داده‌ها از حافظه رایانه را کارآمدتر می‌کند. این حافظه به عنوان یک ناحیه ذخیره‌سازی موقت عمل می‌کند تا پردازنده رایانه بتواند به راحتی داده‌ها را بازیابی کند. این ناحیه ذخیره‌سازی موقت که به نام کش شناخته می‌شود، بیشتر از منبع حافظه اصلی رایانه، که معمولاً نوعی DRAM است، در دسترس پردازنده است.

حافظه کش گاهی به عنوان حافظه CPU (واحد پردازش مرکزی) نامیده می‌شود زیرا به طور معمول مستقیماً در تراشه CPU ادغام می‌شود یا بر روی تراشه جداگانه‌ای قرار می‌گیرد که یک باس جداگانه با CPU دارد. بنابراین، این حافظه بیشتر در دسترس پردازنده است و می‌تواند کارایی را افزایش دهد زیرا به صورت فیزیکی به پردازنده نزدیک است.

برای نزدیک بودن به پردازنده، حافظه کش باید بسیار کوچکتر از حافظه اصلی باشد. بنابراین، فضای ذخیره‌سازی کمتری دارد. همچنین این حافظه گرانتر از حافظه اصلی است زیرا تراشه‌ای پیچیده‌تر است که عملکرد بالاتری دارد.

آنچه که در اندازه و قیمت فدا می‌کند، در سرعت جبران می‌کند. حافظه کش 10 تا 100 برابر سریعتر از RAM عمل می‌کند و تنها چند نانوثانیه برای پاسخ به درخواست CPU نیاز دارد.

نام سخت‌افزار واقعی که برای حافظه کش استفاده می‌شود حافظه استاتیک با دسترسی تصادفی (SRAM) است. نام سخت‌افزاری که در حافظه اصلی رایانه استفاده می‌شود حافظه پویا با دسترسی تصادفی (DRAM) است.

حافظه کش نباید با اصطلاح گسترده‌تر کش اشتباه گرفته شود. کش‌ها ذخیره‌سازهای موقتی داده هستند که می‌توانند هم در سخت‌افزار و هم در نرم‌افزار وجود داشته باشند. حافظه کش به مؤلفه سخت‌افزاری خاصی اشاره دارد که به رایانه‌ها امکان می‌دهد کش‌ها را در سطوح مختلف شبکه ایجاد کنند. کش یک سخت‌افزار یا نرم‌افزار است که برای ذخیره موقت چیزی، معمولاً داده، در یک محیط محاسباتی استفاده می‌شود.


### [RAM](/Registers%20Cache%20and%20RAM/readme.md#ram)
RAM (حافظه دسترسی تصادفی) شکلی از حافظه رایانه است که می‌توان آن را به هر ترتیب خواند و تغییر داد، که معمولاً برای ذخیره داده‌های کاری و کد ماشین استفاده می‌شود. یک دستگاه حافظه دسترسی تصادفی امکان خواندن یا نوشتن اقلام داده را تقریباً در همان مقدار زمان، صرف‌نظر از مکان فیزیکی داده در داخل حافظه، فراهم می‌کند، برخلاف سایر رسانه‌های ذخیره‌سازی داده با دسترسی مستقیم (مانند هارد دیسک‌ها، CD-RWها، DVD-RWها و نوارهای مغناطیسی قدیمی و حافظه درامی)، که زمان مورد نیاز برای خواندن و نوشتن اقلام داده به طور قابل توجهی بسته به مکان‌های فیزیکی آنها بر روی رسانه ضبط متفاوت است، به دلیل محدودیت‌های مکانیکی مانند سرعت چرخش رسانه و حرکت بازو.


## [دستورات و برنامه](Not-Added)
در علوم رایانه، دستور یک عملیات واحد پردازنده است که توسط مجموعه دستورات پردازنده تعریف شده است. یک برنامه رایانه‌ای لیستی از دستورات است که به رایانه می‌گوید چه کاری انجام دهد. هر کاری که یک رایانه انجام می‌دهد با استفاده از یک برنامه رایانه‌ای انجام می‌شود. برنامه‌هایی که در حافظه رایانه ذخیره می‌شوند ("برنامه‌ریزی داخلی") به رایانه امکان می‌دهند که کارها را یکی پس از دیگری انجام دهد، حتی با وقفه‌هایی در بین آنها.

## [زبان‌های برنامه‌نویسی](/Programming_Languages/readme.md)
زبان برنامه‌نویسی هر مجموعه‌ای از قوانین است که رشته‌ها، یا عناصر برنامه گرافیکی در مورد زبان‌های برنامه‌نویسی تصویری، را به انواع مختلف خروجی کد ماشین تبدیل می‌کند. زبان‌های برنامه‌نویسی یکی از انواع زبان‌های رایانه‌ای هستند که در برنامه‌نویسی رایانه‌ای برای پیاده‌سازی الگوریتم‌ها استفاده می‌شوند.

زبان‌های برنامه‌نویسی معمولاً به دو دسته کلی تقسیم می‌شوند:
1. زبان‌های سطح بالا از نحوی مشابه زبان انگلیسی استفاده می‌کنند. کد منبع با استفاده از کامپایلر یا مفسر به کد ماشین قابل فهم تبدیل می‌شود. جاوا و پایتون نمونه‌هایی از زبان‌های برنامه‌نویسی سطح بالا هستند. این زبان‌ها معمولاً کندتر از زبان‌های سطح پایین هستند، اما استفاده از آنها آسان‌تر است.
2. زبان‌های برنامه‌نویسی سطح پایین بیشتر با سخت‌افزار کار می‌کنند و کنترل بیشتری بر آن دارند. آنها مستقیماً با سخت‌افزار تعامل دارند. دو نمونه رایج از زبان‌های سطح پایین زبان ماشین و زبان اسمبلی هستند. این زبان‌ها معمولاً سریعتر از زبان‌های سطح بالا هستند، اما این سرعت با هزینه دشواری زیاد و عدم خوانایی به دست می‌آید.

### [پارادایم‌های برنامه‌نویسی](/Programming_Languages/readme.md#Programming+Paradigms)
چندین *پارادایم برنامه‌نویسی* مختلف وجود دارد. پارادایم‌های برنامه‌نویسی روش‌ها یا سبک‌های مختلفی هستند که یک برنامه یا زبان برنامه‌نویسی خاص می‌تواند بر اساس آن سازماندهی شود. هر پارادایم شامل ساختارها، ویژگی‌ها و نظرات خاصی است که درباره نحوه حل مشکلات رایج برنامه‌نویسی وجود دارد.

پارادایم‌های برنامه‌نویسی *زبان‌ها یا ابزارها* نیستند. شما نمی‌توانید با یک پارادایم چیزی "بسازید". آنها بیشتر شبیه مجموعه‌ای از ایده‌آل‌ها و راهنماهایی هستند که بسیاری از مردم بر روی آنها توافق کرده‌اند، آنها را دنبال کرده و گسترش داده‌اند. زبان‌های برنامه‌نویسی همیشه به یک پارادایم خاص وابسته نیستند. *زبان‌هایی* وجود دارند که با یک پارادایم خاص ساخته شده‌اند و ویژگی‌هایی دارند که این نوع برنامه‌نویسی را بیش از دیگران تسهیل می‌کند (هسکل و برنامه‌نویسی تابعی مثال خوبی است). اما همچنین زبان‌های "چندپارادایمی" نیز وجود دارند که در آن می‌توانید کد خود را برای تطبیق با یک پارادایم خاص یا دیگر تطبیق دهید (جاوااسکریپت و پایتون نمونه‌های خوبی هستند).


## [نوع‌های داده](Data%20Types/readme.md#data-types)
نوع داده، در برنامه‌نویسی، طبقه‌بندی است که مشخص می‌کند چه نوع مقداری یک متغیر دارد و چه نوع عملیات ریاضی، رابطه‌ای یا منطقی می‌تواند بدون ایجاد خطا بر روی آن اعمال شود.

### [نوع‌های داده ابتدایی](Data%20Types/readme.md#primitive-data-types)
نوع‌های داده ابتدایی پایه‌ای‌ترین نوع‌های داده در یک زبان برنامه‌نویسی هستند. آنها بلوک‌های سازنده نوع‌های داده پیچیده‌تر هستند. نوع‌های داده ابتدایی توسط زبان برنامه‌نویسی از پیش تعریف شده و با یک کلمه کلیدی رزرو شده نامگذاری می‌شوند.

### [نوع‌های داده ابتدایی رایج](Data%20Types/readme.md#common-primitive-data-types)
- [صحیح](Data%20Types/readme.md#integer)
- [اعشاری](Data%20Types/readme.md#float)
- [بولی](Data%20Types/readme.md#boolean)
- [کاراکتر](Data%20Types/readme.md#character)
- [رشته](Data%20Types/readme.md#string)

### [نوع‌های داده غیرابتدایی](Data%20Types/readme.md#non-primitive-data-types)
نوع‌های داده غیرابتدایی به عنوان نوع‌های داده مرجع نیز شناخته می‌شوند. آنها توسط برنامه‌نویس ایجاد می‌شوند و توسط زبان برنامه‌نویسی تعریف نشده‌اند. نوع‌های داده غیرابتدایی به عنوان نوع‌های داده ترکیبی نیز شناخته می‌شوند زیرا از سایر نوع‌ها تشکیل شده‌اند.

### [نوع‌های داده غیرابتدایی رایج](Data%20Types/readme.md#common-non-primitive-data-types)
- [آرایه](Data%20Types/readme.md#array)
- [ساختار](Data%20Types/readme.md#struct)
- [اتحاد](Data%20Types/readme.md#union)
- [اشاره‌گر](Data%20Types/readme.md#pointer)
- [تابع](Data%20Types/readme.md#function)
- [کلاس](Data%20Types/readme.md#class)

## [دستورات و توابع](Statements%20and%20Functions/readme.md)
در برنامه‌نویسی رایانه‌ای، دستور یک واحد نحوی از یک زبان برنامه‌نویسی امری است که بیانگر یک عملی است که باید انجام شود. برنامه‌ای که در چنین زبانی نوشته می‌شود از توالی یک یا چند دستور تشکیل شده است. یک دستور ممکن است دارای اجزای داخلی باشد (مانند عبارات).
دو نوع اصلی دستور در هر زبان برنامه‌نویسی وجود دارد که برای ساختن منطق یک کد ضروری است.

1. [دستورات شرطی](Statements%20and%20Functions/readme.md#conditional-statements)

دو نوع دستور شرطی اصلی وجود دارد:
- if
- if-else
- switch case


2. [حلقه‌ها](Statements%20and%20Functions/readme.md#loops)

سه نوع حلقه اصلی وجود دارد:
- حلقه for
- حلقه while
- حلقه do-while (یک نوع از حلقه while)
- حلقه do-until

------------
 
 یک تابع بلوکی از دستورات است که یک وظیفه خاص را انجام می‌دهد. توابع داده‌ها را قبول می‌کنند، آنها را پردازش کرده و یک نتیجه را برمی‌گردانند یا اجرا می‌کنند. توابع عمدتاً برای حمایت از مفهوم قابلیت استفاده مجدد نوشته می‌شوند. پس از نوشتن یک تابع، می‌توان به راحتی آن را فراخوانی کرد بدون نیاز به تکرار همان کد.

زبان‌های برنامه‌نویسی مختلف از نحوهای متفاوتی برای نوشتن توابع استفاده می‌کنند.

بیشتر درباره توابع [اینجا](Statements%20and%20Functions/readme.md#functions) بخوانید.


## [ساختارهای داده](Data%20Structures/readme.md)
در علوم رایانه، یک ساختار داده فرمت سازماندهی، مدیریت و ذخیره‌سازی داده است که امکان دسترسی و تغییر کارآمد را فراهم می‌کند. دقیق‌تر بگوییم، یک ساختار داده مجموعه‌ای از مقادیر داده، روابط بین آنها و توابع یا عملیاتی است که می‌توان روی داده اعمال کرد.

### انواع ساختارهای داده
- [آرایه](Data%20Structures/readme.md#array)
- [لیست پیوندی](Data%20Structures/readme.md#linkedlist)
- [پشته](Data%20Structures/readme.md#stack)
- [صف](Data%20Structures/readme.md#queue)
- [جدول هش](Data%20Structures/readme.md#hashtable)
- [هیپ](Data%20Structures/readme.md#heap)
- [درخت](Data%20Structures/readme.md#tree)
- [گراف](Data%20Structures/readme.md#graph)

## [الگوریتم‌ها](Algorithms/readme.md)
الگوریتم‌ها مجموعه‌ای از مراحل لازم برای انجام محاسبات هستند. آنها در قلب آنچه دستگاه‌های ما انجام می‌دهند، قرار دارند و این مفهوم جدیدی نیست. از زمان توسعه خود ریاضیات، الگوریتم‌ها برای کمک به ما در انجام کارها به‌طور کارآمدتر مورد نیاز بوده‌اند، اما امروز می‌خواهیم به چند مشکل محاسباتی مدرن مانند مرتب‌سازی و جستجوی گراف نگاهی بیندازیم و نشان دهیم چگونه آنها را کارآمدتر کرده‌ایم تا بتوانید به راحتی بلیت‌های ارزان پیدا کنید یا مسیرهای نقشه به وینترفیل یا رستوران یا چیز دیگری را پیدا کنید.

### [پیچیدگی زمانی](Algorithms/Time%20Complexity/readme.md)
پیچیدگی زمانی یک الگوریتم تخمین می‌زند که چقدر زمان الگوریتم برای یک ورودی استفاده خواهد کرد. ایده این است که کارایی را به صورت یک تابع که پارامتر آن اندازه ورودی است، نمایش دهیم. با محاسبه پیچیدگی زمانی، می‌توانیم تعیین کنیم آیا الگوریتم به اندازه کافی سریع است یا خیر، بدون این که آن را پیاده‌سازی کنیم.

### [پیچیدگی فضایی](Algorithms/Space%20Complexity/readme.md)
پیچیدگی فضایی به مقدار کل فضای حافظه‌ای که یک الگوریتم/برنامه استفاده می‌کند، از جمله فضای مقادیر ورودی برای اجرا، اشاره دارد. محاسبه فضای اشغال شده توسط متغیرها در یک الگوریتم/برنامه برای تعیین پیچیدگی فضایی لازم است.

### [مرتب‌سازی](Algorithms/Sorting/readme.md)
مرتب‌سازی فرایند مرتب‌سازی لیستی از آیتم‌ها به ترتیب خاص است. به عنوان مثال، اگر لیستی از نام‌ها داشتید، ممکن است بخواهید آنها را به ترتیب حروف الفبا مرتب کنید. یا اگر لیستی از اعداد داشتید، ممکن است بخواهید آنها را به ترتیب از کوچک‌ترین به بزرگ‌ترین قرار دهید. مرتب‌سازی یک وظیفه رایج است و می‌توان آن را به روش‌های مختلفی انجام داد.

### [جستجو](Algorithms/Searching/readme.md)
جستجو یک الگوریتم برای پیدا کردن یک عنصر هدف خاص در یک ظرف است. الگوریتم‌های جستجو برای بررسی یک عنصر یا بازیابی یک عنصر از هر ساختار داده که در آن ذخیره شده است، طراحی شده‌اند.

### [الگوریتم‌های مبتنی بر رشته](Algorithms/String%20Based%20Algorithms/readme.md)
رشته‌ها یکی از پرکاربردترین و مهم‌ترین ساختارهای داده در برنامه‌نویسی هستند، این مخزن شامل تعدادی از الگوریتم‌های پرکاربرد است که به بهبود زمان جستجوی سریع‌تر و بهبود کد ما کمک می‌کنند.

### [جستجوی گراف](Algorithms/Graph/readme.md)
جستجوی گراف فرایند جستجوی یک گره خاص در یک گراف است. گراف یک ساختار داده است که از مجموعه‌ای محدود (و ممکن است قابل تغییر) از راس‌ها یا گره‌ها یا نقاط، به همراه مجموعه‌ای از زوج‌های نامرتب این راس‌ها برای گراف نامجهت یا مجموعه‌ای از زوج‌های مرتب برای گراف جهت‌دار تشکیل شده است. این زوج‌ها به عنوان یال‌ها، کمان‌ها یا خطوط برای گراف نامجهت، و به عنوان پیکان‌ها، یال‌های جهت‌دار، کمان‌های جهت‌دار یا خطوط جهت‌دار برای گراف جهت‌دار شناخته می‌شوند. راس‌ها ممکن است بخشی از ساختار گراف باشند یا ممکن است موجودیت‌های خارجی باشند که با شاخص‌های عددی یا ارجاع‌ها نمایش داده می‌شوند. گراف‌ها یکی از مفیدترین ساختارهای داده برای بسیاری از کاربردهای دنیای واقعی هستند. گراف‌ها برای مدل‌سازی روابط دوطرفه بین اشیاء استفاده می‌شوند. به عنوان مثال، شبکه مسیرهای هوایی یک گراف است که در آن شهرها راس‌ها و مسیرهای پروازی یال‌ها هستند. گراف‌ها همچنین برای نمایش شبکه‌ها استفاده می‌شوند. اینترنت را می‌توان به عنوان یک گراف مدل کرد که در آن رایانه‌ها راس‌ها و پیوندهای بین رایانه‌ها یال‌ها هستند. گراف‌ها همچنین در شبکه‌های اجتماعی مانند لینکدین و فیسبوک استفاده می‌شوند. گراف‌ها برای نمایش بسیاری از کاربردهای دنیای واقعی استفاده می‌شوند: شبکه‌های رایانه‌ای، طراحی مدار و زمان‌بندی هواپیمایی تنها چند نمونه هستند.

### [برنامه‌نویسی پویا](Algorithms/Dynamic%20Programming/README.md)
برنامه‌نویسی پویا هم یک روش بهینه‌سازی ریاضی و هم یک روش برنامه‌نویسی رایانه‌ای است. ریچارد بلمن این روش را در دهه ۱۹۵۰ توسعه داد و در بسیاری از زمینه‌ها از جمله مهندسی هوافضا تا اقتصاد کاربرد پیدا کرده است. در هر دو زمینه، این روش به ساده‌سازی یک مشکل پیچیده با تقسیم آن به زیرمسائل ساده‌تر به صورت بازگشتی اشاره دارد. در حالی که برخی از مسائل تصمیم‌گیری نمی‌توانند به این شکل تقسیم شوند، تصمیماتی که چندین نقطه زمانی را شامل می‌شوند اغلب به صورت بازگشتی تقسیم می‌شوند. به همین ترتیب، در علوم رایانه، اگر یک مسئله بتواند با تقسیم آن به زیرمسائل و سپس یافتن بهینه‌ترین راه‌حل‌ها برای زیرمسائل به طور بهینه حل شود، گفته می‌شود که دارای ساختار زیرمسئله بهینه است. برنامه‌نویسی پویا یکی از راه‌های حل مسائل با این ویژگی‌ها است. فرایند تقسیم یک مسئله پیچیده به زیرمسائل ساده‌تر "تقسیم و حل" نامیده می‌شود.


### [الگوریتم‌های حریصانه](Algorithms/Greedy%20Algorithm/readme.md)
الگوریتم‌های حریصانه کلاس ساده و شهودی از الگوریتم‌ها هستند که می‌توانند برای یافتن راه‌حل بهینه برای برخی مسائل بهینه‌سازی استفاده شوند. آنها به این دلیل حریصانه نامیده می‌شوند که در هر مرحله انتخابی را انجام می‌دهند که در آن لحظه بهترین به نظر می‌رسد. این بدان معناست که الگوریتم‌های حریصانه تضمین نمی‌کنند که راه‌حل بهینه کلی را برگردانند، بلکه به جای آن انتخاب‌های بهینه محلی را در امید یافتن بهینه کلی انجام می‌دهند. الگوریتم‌های حریصانه برای مسائل بهینه‌سازی استفاده می‌شوند. یک مسئله بهینه‌سازی می‌تواند با استفاده از روش حریصانه حل شود اگر مسئله دارای این ویژگی باشد: در هر مرحله، می‌توان انتخابی که در آن لحظه بهترین به نظر می‌رسد را انجام داد و راه‌حل بهینه برای کل مسئله به دست آید.


### [بازگشت به عقب](Algorithms/Backtracking/README.md)
بازگشت به عقب یک تکنیک الگوریتمی برای حل مسائل به صورت بازگشتی است که با تلاش برای ساخت یک راه‌حل به صورت تدریجی، یک قطعه در یک زمان، و حذف آن راه‌حل‌هایی که در هر لحظه از زمان (منظور زمان سپری شده تا رسیدن به هر سطح از درخت جستجو) شرایط مسئله را برآورده نمی‌کنند، عمل می‌کند.


### [شاخه و کران](Algorithms/Branch%20and%20Bound/README.md)
شاخه و کران یک تکنیک عمومی برای حل مسائل بهینه‌سازی ترکیبی است. این یک تکنیک شمارش سیستماتیک است که با استفاده از ساختار مسئله تعداد راه‌حل‌های کاندیدا را کاهش می‌دهد و راه‌حل‌هایی که نمی‌توانند بهینه باشند را حذف می‌کند.


### [پیچیدگی زمانی و پیچیدگی فضایی الگوریتم‌های جستجو و مرتب‌سازی مختلف](Not-Added)
**پیچیدگی زمانی**: به عنوان تعداد دفعاتی که مجموعه دستورالعمل خاصی انتظار می‌رود اجرا شود تعریف می‌شود، نه زمان کلی که صرف می‌شود. از آنجا که زمان یک پدیده وابسته است، پیچیدگی زمانی ممکن است بر اساس عواملی خارجی مانند سرعت پردازنده، کامپایلر مورد استفاده و غیره متفاوت باشد.

**پیچیدگی فضایی**: به مجموع فضای حافظه‌ای که برنامه برای اجرای خود مصرف می‌کند اشاره دارد.

هر دو به عنوان تابعی از اندازه ورودی (n) محاسبه می‌شوند. پیچیدگی زمانی یک الگوریتم با نماد O بزرگ بیان می‌شود.

کارایی یک الگوریتم به این دو پارامتر بستگی دارد.

انواع پیچیدگی زمانی:

- *بهترین پیچیدگی زمانی*: ورودی که الگوریتم کمترین یا حداقل زمان را برای آن می‌گیرد. در بهترین حالت، پیچیدگی زمانی پایین‌تر یک الگوریتم را محاسبه می‌کنیم. به عنوان مثال: اگر داده‌ای که باید جستجو شود در اولین مکان یک آرایه داده بزرگ در جستجوی خطی وجود داشته باشد، بهترین حالت رخ می‌دهد.
- *میانگین پیچیدگی زمانی*: تمام ورودی‌های تصادفی را می‌گیریم و زمان محاسبه را برای همه ورودی‌ها محاسبه می‌کنیم. سپس آن را بر تعداد کل ورودی‌ها تقسیم می‌کنیم.
- *بدترین پیچیدگی زمانی*: تعریف ورودی که الگوریتم بیشترین یا حداکثر زمان را برای آن می‌گیرد. در بدترین حالت، کران بالای یک الگوریتم را محاسبه می‌کنیم. مثال: اگر داده‌ای که باید جستجو شود در آخرین مکان یک آرایه داده بزرگ در الگوریتم جستجوی خطی وجود داشته باشد، بدترین حالت رخ می‌دهد.

برخی پیچیدگی‌های زمانی رایج:

- **O(1)**: این نشان‌دهنده زمان ثابت است. O(1) به طور معمول به این معنی است که الگوریتم زمان ثابتی خواهد داشت صرف‌نظر از اندازه ورودی. نقشه‌های هش مثال‌های کاملی از زمان ثابت هستند.

- **O(log n)**: این نشان‌دهنده زمان لگاریتمی است. O(log n) به این معنی است که عملیات‌ها با هر نمونه کاهش می‌یابند. جستجوی عناصر در درخت‌های جستجوی دودویی (BSTs) مثال خوبی از زمان لگاریتمی است.

- **O(n)**: این نشان‌دهنده زمان خطی است. O(n) به این معنی است که عملکرد مستقیماً متناسب با اندازه ورودی است. به بیان ساده، تعداد ورودی‌ها و زمان لازم برای اجرای آن ورودی‌ها متناسب خواهد بود. جستجوی خطی در آرایه‌ها مثال خوبی از پیچیدگی زمانی خطی است.

- **O(n*n)**: این نشان‌دهنده زمان درجه دوم است. O(n^2) به این معنی است که عملکرد مستقیماً متناسب با مربع ورودی گرفته شده است. به بیان ساده، زمان لازم برای اجرا تقریباً به اندازه مربع اندازه ورودی طول می‌کشد. حلقه‌های تو در تو مثال‌های کاملی از زمان درجه دوم هستند.

- **O(n log n)**: این نشان‌دهنده پیچیدگی زمانی چندجمله‌ای است. O(n log n) به این معنی است که عملکرد n برابر O(log n) است، (که بدترین پیچیدگی زمانی است). یک مثال خوب الگوریتم‌های تقسیم و حل مانند مرتب‌سازی ادغامی است. این الگوریتم ابتدا مجموعه را تقسیم می‌کند که زمان O(log n) می‌برد، سپس مجموعه را حل و مرتب می‌کند که زمان O(n) می‌برد - بنابراین مرتب‌سازی ادغامی زمان O(n log n) دارد.

| الگوریتم           |              | پیچیدگی زمانی |              | پیچیدگی فضایی |
|   :---:            |  :---:       |  :---:        |   :---:      |   :---:       |
|                   | بهترین       | میانگین      | بدترین      | بدترین       |
| مرتب‌سازی انتخاب  | Ω(n^2)       | θ(n^2)       | O(n^2)      | O(1)         |
| مرتب‌سازی حبابی   | Ω(n)         | θ(n^2)       | O(n^2)      | O(1)         |
| مرتب‌سازی درجی    | Ω(n)         | θ(n^2)       | O(n^2)      | O(1)         |
| مرتب‌سازی هیپ     | Ω(n log(n))  | θ(n log(n))  | O(n log(n)) | O(1)         |
| مرتب‌سازی سریع    | Ω(n log(n))  | θ(n log(n))  | O(n^2)      | O(n)         |
| مرتب‌سازی ادغامی  | Ω(n log(n))  | θ(n log(n))  | O(n log(n)) | O(n)         |
| مرتب‌سازی سطلی    | Ω(n +k)      | θ(n +k)      | O(n^2)      | O(n)         |
| مرتب‌سازی رادیوکس | Ω(nk)        | θ(nk)        | O(nk)       | O(n + k)     |
| مرتب‌سازی شمارشی  | Ω(n +k)      | θ(n +k)      | O(n +k)     | O(k)         |
| مرتب‌سازی پوسته‌ای| Ω(n log(n))  | θ(n log(n))  | O(n^2)      | O(1)         |
| مرتب‌سازی تیم     | Ω(n)         | θ(n log(n))  | O(n log(n)) | O(n)         |
| مرتب‌سازی درختی   | Ω(n log(n))  | θ(n log(n))  | O(n^2)      | O(n)         |
| مرتب‌سازی مکعبی   | Ω(n)         | θ(n log(n))  | O(n log(n)) | O(n)         |

| الگوریتم           |              | پیچیدگی زمانی |
|   :---:            |  :---:       |  :---:        |   :---:      |
|                   | بهترین       | میانگین      | بدترین      |
| جستجوی خطی        | O(1)         | O(N)         | O(N)        | O(1)         |
| جستجوی دودویی     | O(1)         | O(logN)      | O(logN)     |


## [آلن تورینگ](Not-Added)
آلن تورینگ (متولد ۲۳ ژوئن ۱۹۱۲، لندن، انگلستان — درگذشته ۷ ژوئن ۱۹۵۴، ویلمسلو، چشایر) یک ریاضیدان و منطق‌دان انگلیسی بود. او در دانشگاه کمبریج و موسسه مطالعات پیشرفته پرینستون تحصیل کرد. در مقاله مهم خود در سال ۱۹۳۶ با عنوان "درباره اعداد قابل محاسبه"، اثبات کرد که نمی‌تواند هیچ روش الگوریتمی جهانی برای تعیین حقیقت در ریاضیات وجود داشته باشد و ریاضیات همیشه شامل گزاره‌های غیرقابل تصمیم‌گیری (در مقابل ناشناخته) خواهد بود. این مقاله همچنین ماشین تورینگ را معرفی کرد. او باور داشت که رایانه‌ها در نهایت قادر به تفکری خواهند بود که از تفکر انسان قابل تشخیص نیست و آزمونی ساده (ببینید آزمون تورینگ) را برای ارزیابی این قابلیت پیشنهاد داد. مقالات او در این زمینه به طور گسترده‌ای به عنوان بنیان تحقیق در هوش مصنوعی شناخته می‌شوند. او در طول جنگ جهانی دوم کار ارزشمندی در رمزنگاری انجام داد و نقش مهمی در شکستن کد انیگما که آلمان برای ارتباطات رادیویی استفاده می‌کرد، داشت. پس از جنگ، او در دانشگاه منچستر تدریس کرد و کار بر روی چیزی که اکنون به عنوان هوش مصنوعی شناخته می‌شود را آغاز کرد. در میان این کارهای پیشگامانه، تورینگ در بستر خود با سم سیانور مسموم یافت شد. مرگ او پس از دستگیری‌اش به دلیل یک عمل همجنس‌گرایانه (که در آن زمان جرم بود) و محکومیت به ۱۲ ماه هورمون درمانی اتفاق افتاد.

پس از یک کمپین عمومی در سال ۲۰۰۹، نخست‌وزیر بریتانیا، گوردون براون، به طور رسمی از طرف دولت بریتانیا برای رفتار وحشتناک با تورینگ عذرخواهی کرد. ملکه الیزابت دوم در سال ۲۰۱۳ عفو پس از مرگ به او اعطا کرد. اصطلاح "قانون آلن تورینگ" اکنون به طور غیررسمی به قانونی در سال ۲۰۱۷ در بریتانیا اشاره دارد که به طور عطف به ماسبق مردانی را که تحت قوانین تاریخی که اعمال همجنس‌گرایانه را جرم می‌دانست، بخشیده است.

تورینگ میراث گسترده‌ای دارد که شامل مجسمه‌های او و بسیاری چیزهای نام‌گذاری شده به نام او، از جمله جایزه سالانه برای نوآوری‌های علوم رایانه می‌شود. او بر روی اسکناس ۵۰ پوندی فعلی بانک انگلستان قرار دارد که در ۲۳ ژوئن ۲۰۲۱ برای همزمانی با تولد او منتشر شد. یک سریال بی‌بی‌سی در سال ۲۰۱۹، به عنوان رای مخاطبان، او را بزرگترین فرد قرن بیستم نامید.


## [مهندسی نرم‌افزار](Software%20Engineering/readme.md)
مهندسی نرم‌افزار شاخه‌ای از علوم رایانه است که با طراحی، توسعه، تست و نگهداری نرم‌افزارهای کاربردی سروکار دارد. مهندسان نرم‌افزار اصول مهندسی و دانش زبان‌های برنامه‌نویسی را به کار می‌گیرند تا راه‌حل‌های نرم‌افزاری برای کاربران نهایی بسازند.

بیایید به تعاریف مختلف مهندسی نرم‌افزار نگاهی بیندازیم:

- IEEE در استاندارد ۶۱۰.۱۲-۱۹۹۰ خود، مهندسی نرم‌افزار را به عنوان کاربردی سیستماتیک، منظم، که رویکردی محاسبه‌پذیر برای توسعه، اجرا و نگهداری نرم‌افزار است، تعریف می‌کند.
- فریتز باوئر آن را به عنوان "استقرار و استفاده از اصول مهندسی استاندارد" تعریف کرد. این به شما کمک می‌کند نرم‌افزاری اقتصادی به دست آورید که قابل اعتماد بوده و به طور مؤثر بر روی ماشین‌های واقعی کار کند.
- بوهم مهندسی نرم‌افزار را به عنوان "کاربرد عملی دانش علمی برای طراحی خلاقانه و ساخت برنامه‌های رایانه‌ای" تعریف می‌کند. همچنین شامل مستندات مرتبط برای توسعه، اجرا و نگهداری آنها است.

### وظایف و مسئولیت‌های مهندس نرم‌افزار
مهندسان موفق می‌دانند چگونه از زبان‌های برنامه‌نویسی، پلتفرم‌ها و معماری‌های مناسب برای توسعه هر چیزی از بازی‌های رایانه‌ای تا سیستم‌های کنترل شبکه استفاده کنند. علاوه بر ساخت سیستم‌های خود، مهندسان نرم‌افزار نرم‌افزارهای ساخته شده توسط سایر مهندسان را نیز تست، بهبود و نگهداری می‌کنند.

در این نقش، وظایف روزانه شما ممکن است شامل موارد زیر باشد:

- طراحی و نگهداری سیستم‌های نرم‌افزاری
- ارزیابی و تست برنامه‌های جدید نرم‌افزاری
- بهینه‌سازی نرم‌افزار برای سرعت و مقیاس‌پذیری
- نوشتن و تست کد
- مشاوره با مشتریان، مهندسان، متخصصان امنیت و سایر ذی‌نفعان
- ارائه ویژگی‌های جدید به ذی‌نفعان و مشتریان داخلی

### مراحل مهندسی نرم‌افزار
فرایند مهندسی نرم‌افزار شامل چندین مرحله است، از جمله جمع‌آوری نیازها، طراحی، پیاده‌سازی، تست و نگهداری. با پیروی از رویکردی منظم به توسعه نرم‌افزار، مهندسان نرم‌افزار می‌توانند نرم‌افزار با کیفیت بالا که نیازهای کاربران را برآورده می‌کند، ایجاد کنند.

- اولین مرحله مهندسی نرم‌افزار جمع‌آوری نیازها است. در این مرحله، مهندس نرم‌افزار با مشتری کار می‌کند تا نیازهای عملکردی و غیرعملکردی نرم‌افزار را تعیین کند. نیازهای عملکردی توصیف می‌کنند که نرم‌افزار چه کاری باید انجام دهد، در حالی که نیازهای غیرعملکردی توصیف می‌کنند که چقدر خوب باید این کار را انجام دهد. جمع‌آوری نیازها مرحله‌ای حیاتی است زیرا اساس کل فرایند توسعه نرم‌افزار را تشکیل می‌دهد.

- پس از جمع‌آوری نیازها، مرحله بعدی طراحی است. در این مرحله، مهندس نرم‌افزار یک برنامه دقیق برای معماری و عملکرد نرم‌افزار ایجاد می‌کند. این برنامه شامل یک سند طراحی نرم‌افزار است که ساختار، رفتار و تعاملات نرم‌افزار با سایر سیستم‌ها را مشخص می‌کند. سند طراحی نرم‌افزار ضروری است زیرا به عنوان نقشه‌ای برای مرحله پیاده‌سازی عمل می‌کند.

- مرحله پیاده‌سازی جایی است که مهندس نرم‌افزار کد واقعی نرم‌افزار را ایجاد می‌کند. در اینجا سند طراحی به نرم‌افزار عملی تبدیل می‌شود. مرحله پیاده‌سازی شامل نوشتن کد، کامپایل کردن آن و تست برای اطمینان از مطابقت با نیازهای مشخص شده در سند طراحی است.

- تست مرحله‌ای حیاتی در مهندسی نرم‌افزار است. در این مرحله، مهندس نرم‌افزار بررسی می‌کند که آیا نرم‌افزار به درستی عمل می‌کند، قابل اعتماد است و استفاده از آن آسان است. این شامل چندین نوع تست است، از جمله تست واحد، تست یکپارچه‌سازی و تست سیستم. تست اطمینان می‌دهد که نرم‌افزار مطابق انتظار کار می‌کند.

- مرحله نهایی مهندسی نرم‌افزار نگهداری است. در این مرحله، مهندس نرم‌افزار تغییراتی در نرم‌افزار ایجاد می‌کند تا خطاها را اصلاح کند، ویژگی‌های جدید اضافه کند یا عملکرد آن را بهبود بخشد. نگهداری یک فرایند مداوم است که در طول عمر نرم‌افزار ادامه دارد.


### چرا مهندسی نرم‌افزار محبوب است؟

- علوم رایانه: پایه علمی برای نرم‌افزار ارائه می‌دهد، همان‌طور که مهندسی برق عمدتاً به فیزیک وابسته است.
- علم مدیریت: مهندسی نرم‌افزار کاربرمحور است و به کنترل فنی و مدیریتی نیاز دارد. بنابراین به طور گسترده‌ای در علم مدیریت استفاده می‌شود.
- اقتصاد: در این بخش، مهندسی نرم‌افزار به تخمین منابع و کنترل هزینه‌ها کمک می‌کند. یک سیستم محاسباتی باید توسعه یابد و داده‌ها به طور منظم با بودجه مشخص نگهداری شوند.
- مهندسی سیستم: اکثر نرم‌افزارها بخشی از یک سیستم بسیار بزرگتر هستند. برای مثال، نرم‌افزار در سیستم‌های پایش صنعتی یا نرم‌افزار پرواز در هواپیما. روش‌های مهندسی نرم‌افزار باید به مطالعه این نوع سیستم‌ها اعمال شود.

## [علم داده](Data%20Science/readme.md)
علم داده از طریق به‌کارگیری علوم رایانه، آمار و دانش حوزه مورد نظر، بینش‌های ارزشمند از داده‌های معمولاً ناپاک استخراج می‌کند. مثال‌هایی از استفاده از علم داده شامل استخراج احساس مشتری از رکوردهای تماس یا سیستم‌های توصیه خرید مشتق‌شده از رکوردهای فروش است.

## [مدارهای مجتمع](Integrated%20Circuits/readme.md)
یک مدار مجتمع یا مدار مجتمع تک‌پارچه (که به عنوان IC، چیپ یا میکروچیپ نیز شناخته می‌شود) مجموعه‌ای از مدارهای الکترونیکی است که بر روی یک قطعه کوچک صاف از ماده نیمه‌رسانا، معمولاً سیلیکون، قرار گرفته است. بسیاری از ترانزیستورهای MOSFET (ترانزیستورهای اثر میدان فلزی-اکسیدی-نیمه‌رسانا) در یک چیپ کوچک یکپارچه شده‌اند. این منجر به مدارهایی می‌شود که به مراتب کوچکتر، سریعتر و ارزانتر از آنهایی که از اجزای الکترونیکی مجزا ساخته شده‌اند، هستند. قابلیت تولید انبوه IC، قابلیت اطمینان و رویکرد بلوک‌سازی به طراحی مدارهای مجتمع، پذیرش سریع IC‌های استاندارد به جای ترانزیستورهای مجزا را تضمین کرده است. IC‌ها اکنون در تقریباً تمام تجهیزات الکترونیکی استفاده می‌شوند و دنیای الکترونیک را متحول کرده‌اند. رایانه‌ها، تلفن‌های همراه و سایر لوازم خانگی اکنون اجزای جدایی‌ناپذیر ساختار جوامع مدرن هستند که با اندازه کوچک و هزینه پایین IC‌ها مانند پردازنده‌های رایانه‌ای مدرن و میکروکنترلرها ممکن شده‌اند.

یکپارچه‌سازی بسیار بزرگ مقیاس به دلیل پیشرفت‌های فناوری در ساخت دستگاه‌های نیمه‌رسانای MOS (فلزی-اکسیدی-سیلیکونی) عملی شد. از زمان پیدایش آنها در دهه ۱۹۶۰، اندازه، سرعت و ظرفیت چیپ‌ها به طور قابل توجهی پیشرفت کرده است که توسط پیشرفت‌های فنی که ترانزیستورهای MOS بیشتری را در چیپ‌هایی با همان اندازه جای می‌دهند، هدایت می‌شود - یک چیپ مدرن ممکن است بسیاری از میلیاردها ترانزیستور MOS در مساحت به اندازه یک ناخن انسان داشته باشد. این پیشرفت‌ها که به طور تقریبی از قانون مور پیروی می‌کنند، باعث شده است که چیپ‌های رایانه‌ای امروزی میلیون‌ها بار ظرفیت و هزاران بار سرعت چیپ‌های رایانه‌ای اوایل دهه ۱۹۷۰ را داشته باشند.

IC‌ها دو مزیت اصلی نسبت به مدارهای مجزا دارند: هزینه و عملکرد. هزینه پایین است زیرا چیپ‌ها با تمام اجزای آنها به عنوان یک واحد توسط فوتولیتوگرافی چاپ می‌شوند، نه اینکه یک ترانزیستور در یک زمان ساخته شوند. علاوه بر این، IC‌های بسته‌بندی شده از مواد کمتری نسبت به مدارهای مجزا استفاده می‌کنند. عملکرد بالا است زیرا اجزای IC به سرعت سوئیچ می‌کنند و به دلیل اندازه کوچک و نزدیکی خود نسبتاً انرژی کمی مصرف می‌کنند. نقص اصلی IC‌ها هزینه بالای طراحی آنها و ساخت فوتوماسک‌های مورد نیاز است. این هزینه اولیه بالا به این معنی است که IC‌ها تنها در صورتی از نظر تجاری مقرون به صرفه هستند که حجم تولید بالایی پیش‌بینی شود.


### انواع
توزیع‌کنندگان مدرن قطعات الکترونیکی اغلب مدارهای مجتمع را به زیر دسته‌های بیشتری تقسیم می‌کنند:

- مدارهای مجتمع دیجیتال به عنوان مدارهای منطقی (مانند ریزپردازنده‌ها و ریزکنترلرها)، چیپ‌های حافظه (مانند حافظه MOS و حافظه‌های گیت شناور)، مدارهای واسط (تغییر سطح، سریالایزر/دی‌سریالایزر و غیره)، مدارهای مدیریت توان و دستگاه‌های قابل برنامه‌ریزی دسته‌بندی می‌شوند.
- مدارهای مجتمع آنالوگ به عنوان مدارهای مجتمع خطی و مدارهای RF (مدارهای فرکانس رادیویی) دسته‌بندی می‌شوند.
- مدارهای مجتمع مختلط سیگنال به عنوان مدارهای اکتساب داده (مبدل‌های A/D، مبدل‌های D/A و پتانسیومترهای دیجیتال)، مدارهای زمان‌بندی/ساعت، مدارهای خازنی تعویض‌شونده (SC) و مدارهای CMOS RF دسته‌بندی می‌شوند.
- مدارهای مجتمع سه‌بعدی (3D ICs) به مدارهای TSV (اتصال از طریق سیلیکون) و مدارهای اتصال Cu-Cu دسته‌بندی می‌شوند.


## [برنامه‌نویسی شیءگرا](Object%20Oriented%20Programming/readme.md)
برنامه‌نویسی شیءگرا یک پارادایم برنامه‌نویسی اساسی است که بر اساس مفاهیم اشیاء و داده‌ها است.

این روش استاندارد کدنویسی است که هر برنامه‌نویسی باید برای بهبود خوانایی و قابلیت استفاده مجدد از کد رعایت کند.

### * چهار مفهوم اساسی برنامه‌نویسی شیءگرا:
- انتزاع
- بسته‌بندی
- وراثت
- چندریختی

بیشتر درباره این مفاهیم برنامه‌نویسی شیءگرا [اینجا](Object%20Oriented%20Programming/readme.md) بخوانید.

## [برنامه‌نویسی تابعی](Functional%20Programming/readme.md)

در علوم رایانه، برنامه‌نویسی تابعی یک پارادایم برنامه‌نویسی است که در آن برنامه‌ها با اعمال و ترکیب توابع ساخته می‌شوند. این یک پارادایم برنامه‌نویسی اعلامی است که در آن تعریف توابع به صورت درختی از عبارات است که مقادیر را به مقادیر دیگر نگاشت می‌دهند، به جای دنباله‌ای از دستورات امری که حالت اجرای برنامه را به‌روزرسانی می‌کنند.

در برنامه‌نویسی تابعی، توابع به عنوان شهروندان درجه اول محسوب می‌شوند، به این معنا که می‌توانند به نام‌ها (شامل شناسه‌های محلی) متصل شوند، به عنوان آرگومان‌ها ارسال شوند و از توابع دیگر بازگردانده شوند، درست همان‌طور که هر نوع داده دیگری می‌تواند. این امکان می‌دهد برنامه‌ها به صورت سبک اعلامی و ترکیبی نوشته شوند، جایی که توابع کوچک به صورت مدولار ترکیب می‌شوند.

برنامه‌نویسی تابعی گاهی به عنوان مترادف با برنامه‌نویسی کاملاً تابعی تلقی می‌شود، زیرمجموعه‌ای از برنامه‌نویسی تابعی که تمام توابع را به عنوان توابع ریاضی قطعی، یا توابع خالص، تلقی می‌کند. هنگامی که یک تابع خالص با برخی آرگومان‌های مشخص فراخوانی می‌شود، همیشه همان نتیجه را برمی‌گرداند و نمی‌تواند تحت تأثیر هیچ حالت متغیری یا اثرات جانبی دیگر قرار گیرد. این در مقابل رویه‌های ناپاک، معمول در برنامه‌نویسی امری، است که می‌توانند اثرات جانبی داشته باشند (مانند تغییر حالت برنامه یا گرفتن ورودی از کاربر). طرفداران برنامه‌نویسی کاملاً تابعی ادعا می‌کنند که با محدود کردن اثرات جانبی، برنامه‌ها می‌توانند خطاهای کمتری داشته باشند، آسان‌تر دیباگ و تست شوند و برای روش‌های تأیید رسمی مناسب‌تر باشند.

برنامه‌نویسی تابعی ریشه در دانشگاه دارد و از حساب لامبدا، یک سیستم رسمی محاسباتی که تنها بر اساس توابع است، تکامل یافته است. برنامه‌نویسی تابعی به طور تاریخی کمتر از برنامه‌نویسی امری محبوب بوده است، اما بسیاری از زبان‌های تابعی امروزه در صنعت و آموزش استفاده می‌شوند.

برخی مثال‌ها از زبان‌های برنامه‌نویسی تابعی عبارتند از:
- <a href="https://lisp-lang.org/"> لیسپ عمومی </a>
- <a href="https://www.scheme.org/"> اسکیم </a>
- <a href="https://racket-lang.org/"> راکت </a>
- <a href="https://www.erlang.org/"> ارلنگ </a>
- <a href="https://www.haskell.org/"> هسکل </a>
- <a href="https://fsharp.org/"> F# </a>
- <a href="https://cs.lmu.edu/~ray/notes/introml/"> ML </a>

برنامه‌نویسی تابعی به طور تاریخی از *حساب لامبدا* مشتق شده است. حساب لامبدا یک چارچوب است که توسط آلونزو چرچ برای مطالعه محاسبات با توابع توسعه داده شده است. اغلب به آن "کوچکترین زبان برنامه‌نویسی جهان" گفته می‌شود. این چارچوب تعریفی از آنچه قابل محاسبه است و آنچه نیست ارائه می‌دهد. این از نظر توانایی محاسباتی معادل با ماشین تورینگ است و هر چیزی که توسط حساب لامبدا قابل محاسبه باشد، مانند هر چیزی که توسط ماشین تورینگ قابل محاسبه است، قابل محاسبه است. این چارچوبی نظری برای توصیف توابع و ارزیابی‌های آنها فراهم می‌کند.

برخی مفاهیم اساسی برنامه‌نویسی تابعی عبارتند از:
- توابع خالص
- بازگشت
- شفافیت ارجاعی
- توابع به عنوان درجه اول و توابع مرتبه بالاتر
- متغیرها غیرقابل تغییر هستند.

**توابع خالص**: این توابع دو ویژگی اصلی دارند. اول، آنها همیشه برای همان آرگومان‌ها همان خروجی را تولید می‌کنند، صرف‌نظر از هر چیز دیگری. دوم، آنها هیچ اثر جانبی ندارند. یعنی هیچ آرگومان یا متغیر محلی/جهانی یا جریان‌های ورودی/خروجی را تغییر نمی‌دهند. این ویژگی دوم *غیرقابل تغییر بودن* نامیده می‌شود. تنها نتیجه تابع خالص، مقداری است که برمی‌گرداند. آنها قطعی هستند. برنامه‌هایی که با استفاده از برنامه‌نویسی تابعی انجام می‌شوند، به دلیل نداشتن اثرات جانبی یا I/O پنهان، آسان برای دیباگ هستند. توابع خالص همچنین نوشتن برنامه‌های موازی/همزمان را آسان‌تر می‌کنند. هنگامی که کد به این سبک نوشته می‌شود، یک کامپایلر هوشمند می‌تواند کارهای زیادی انجام دهد - می‌تواند دستورات را به صورت موازی اجرا کند، نتایج را تا زمان نیاز ارزیابی کند و نتایج را حفظ کند زیرا نتایج تا زمانی که ورودی تغییر نکند، تغییر نمی‌کنند. در اینجا یک مثال ساده از یک تابع خالص در پایتون آورده شده است:

```python
def sum(x ,y): # sum یک تابع است که x و y را به عنوان آرگومان می‌گیرد
    return x + y  # x + y را برمی‌گرداند بدون تغییر مقدار
```

**بازگشت**: هیچ حلقه "for" یا "while" در زبان‌های برنامه‌نویسی تابعی خالص وجود ندارد. تکرار از طریق بازگشت پیاده‌سازی می‌شود. توابع بازگشتی خودشان را تکراراً فراخوانی می‌کنند تا یک حالت پایه رسیدگی شود. در اینجا یک مثال ساده از یک تابع بازگشتی در C آورده شده است:

```c
int fib(n) {
  if(n <= 1)
    return 1;
   else
     return (fib(n-1) + fib(n-2));
}
```
**شفافیت ارجاعی**: در برنامه‌های تابعی، متغیرها پس از تعریف شدن در طول برنامه تغییر نمی‌کنند. برنامه‌های تابعی دستورهای تخصیص ندارند. اگر نیاز به ذخیره مقداری داشته باشیم، یک متغیر جدید تعریف می‌کنیم. این هر گونه احتمال اثرات جانبی را از بین می‌برد زیرا هر متغیر را می‌توان در هر نقطه از اجرای برنامه با مقدار واقعی آن جایگزین کرد. حالت هر متغیر در هر لحظه ثابت است. مثال:

```bash
x = x + 1 # این مقدار تخصیص داده شده به متغیر x را تغییر داد
         # بنابراین، عبارت شفافیت ارجاعی ندارد
```

**توابع درجه اول و می‌توانند مرتبه بالاتر باشند**: توابع درجه اول به عنوان متغیرهای درجه اول تلقی می‌شوند. متغیرهای درجه اول می‌توانند به عنوان پارامتر به توابع ارسال شوند، می‌توانند از توابع بازگردانده شوند یا در ساختارهای داده ذخیره شوند.

ترکیبی از کاربرد توابع ممکن است با استفاده از فرمی از لیسپ به نام **funcall** تعریف شود، که به عنوان آرگومان‌ها یک تابع و یک سری آرگومان می‌گیرد و آن تابع را به آن آرگومان‌ها اعمال می‌کند:

```Lisp
(defun filter (list-of-elements test)
    (cond ((null list-of-elements) nil)
          ((funcall test (car list-of-elements))
            (cons (car list-of-elements)
                (filter (cdr list-of-elements)
                      test)))
           (t (filter (cdr list-of-elements)
                       test))))
```
تابع **filter** تست را به اولین عنصر لیست اعمال می‌کند. اگر تست مقدار غیر nil برگرداند، عنصر را به نتیجه فیلتر اعمال‌شده به cdr لیست اضافه می‌کند؛ در غیر این صورت، فقط cdr فیلتر شده را برمی‌گرداند. این تابع ممکن است با گذراندن پیش‌شرط‌های مختلف به عنوان پارامترها برای انجام وظایف مختلف فیلتر کردن استفاده شود:

```Lisp
    > (filter '(1 3 -9 5 -2 -7 6) #'plusp)   ; فیلتر کردن همه اعداد منفی
```    
    خروجی: (1 3 5 6)

```Lisp
   > (filter '(1 2 3 4 5 6 7 8 9) #'evenp)   ; فیلتر کردن همه اعداد فرد
```   
   خروجی: (2 4 6 8)

   و به همین ترتیب.

**متغیرها غیرقابل تغییر هستند**: در برنامه‌نویسی تابعی، نمی‌توان متغیری را پس از مقداردهی اولیه آن تغییر داد. ما می‌توانیم متغیرهای جدید ایجاد کنیم - اما نمی‌توانیم متغیرهای موجود را تغییر دهیم و این واقعاً به حفظ حالت در طول اجرای برنامه کمک می‌کند. هنگامی که متغیری ایجاد کرده و مقدار آن را تنظیم می‌کنیم، می‌توانیم با اطمینان کامل بدانیم که مقدار آن متغیر هرگز تغییر نخواهد کرد.


## [حافظه و ذخیره‌سازی](Memory%20and%20Storage/readme.md)

### حافظه
اصطلاح _حافظه_ به جزء داخل کامپیوتر شما اشاره دارد که امکان دسترسی به داده‌های کوتاه‌مدت را فراهم می‌کند. شما ممکن است این جزء را به عنوان DRAM یا حافظه دسترسی تصادفی پویا بشناسید. کامپیوتر شما بسیاری از عملیات‌ها را با دسترسی به داده‌های ذخیره‌شده در حافظه کوتاه‌مدت خود انجام می‌دهد. برخی مثال‌ها از این عملیات‌ها شامل ویرایش یک سند، بارگذاری برنامه‌ها و مرور اینترنت می‌باشد. سرعت و عملکرد سیستم شما به مقدار حافظه‌ای که روی کامپیوترتان نصب شده است، بستگی دارد.

اگر یک میز و یک فایل کابینت دارید، میز نمایانگر حافظه کامپیوتر شما است. آیتم‌هایی که نیاز دارید بلافاصله استفاده کنید، روی میز شما برای دسترسی آسان قرار می‌گیرند. با این حال، به دلیل محدودیت‌های اندازه، میز نمی‌تواند چیزهای زیادی را ذخیره کند.

### ذخیره‌سازی
در حالی که حافظه به محل داده‌های کوتاه‌مدت اشاره دارد، _ذخیره‌سازی_ جزء داخل کامپیوتر شما است که به شما امکان می‌دهد داده‌ها را به‌صورت بلندمدت ذخیره و دسترسی داشته باشید. معمولاً ذخیره‌سازی به شکل یک درایو حالت جامد (SSD) یا یک هارد دیسک (HDD) است. ذخیره‌سازی برنامه‌ها، سیستم‌عامل و فایل‌های شما را به‌صورت نامحدود نگهداری می‌کند. کامپیوترها نیاز دارند که اطلاعات را از سیستم ذخیره‌سازی بخوانند و بنویسند، بنابراین سرعت ذخیره‌سازی تعیین می‌کند که سیستم شما چقدر سریع می‌تواند بوت شود، بارگذاری و دسترسی به آنچه ذخیره کرده‌اید انجام دهد.

در حالی که میز نمایانگر حافظه کامپیوتر است، فایل کابینت نمایانگر ذخیره‌سازی کامپیوتر شما است. فایل کابینت مواردی را که نیاز به ذخیره و نگهداری دارند، اما لزوماً برای دسترسی فوری نیاز نیستند، نگه می‌دارد. اندازه فایل کابینت به این معنا است که می‌تواند چیزهای زیادی را نگه دارد.

**تفاوت مهم** بین حافظه و ذخیره‌سازی این است که حافظه هنگام خاموش شدن کامپیوتر پاک می‌شود. از طرف دیگر، ذخیره‌سازی بدون توجه به تعداد دفعات خاموش کردن کامپیوتر دست‌نخورده باقی می‌ماند. بنابراین، در تشبیه میز و فایل کابینت، هر فایلی که روی میز باقی بماند هنگام ترک دفتر دور ریخته می‌شود. همه چیز در فایل کابینت باقی خواهد ماند.

### حافظه مجازی
در قلب سیستم‌های کامپیوتری، حافظه قرار دارد، فضایی که برنامه‌ها در آن اجرا می‌شوند و داده‌ها ذخیره می‌شوند. اما وقتی برنامه‌هایی که اجرا می‌کنید و داده‌هایی که با آنها کار می‌کنید، از ظرفیت فیزیکی حافظه کامپیوترتان بیشتر شوند، چه اتفاقی می‌افتد؟ اینجاست که حافظه مجازی وارد عمل می‌شود و به عنوان یک افزونه هوشمند برای حافظه کامپیوترتان عمل می‌کند و قابلیت‌های آن را افزایش می‌دهد.

**تعریف و هدف حافظه مجازی:**

حافظه مجازی یک تکنیک مدیریت حافظه است که توسط سیستم‌عامل‌ها به کار گرفته می‌شود تا از محدودیت‌های حافظه فیزیکی (RAM) فراتر رود. این حافظه برای برنامه‌های نرم‌افزاری توهم دسترسی به حافظه بیشتری را ایجاد می‌کند تا آنچه به‌طور فیزیکی روی کامپیوتر نصب شده است. به عبارت دیگر، حافظه مجازی به برنامه‌ها این امکان را می‌دهد که از فضای حافظه‌ای فراتر از حد حافظه فیزیکی کامپیوتر استفاده کنند.

هدف اصلی حافظه مجازی، امکان انجام چندوظیفه‌ای مؤثر و اجرای برنامه‌های بزرگ‌تر است، همه این‌ها در حالی که پاسخگویی سیستم حفظ می‌شود. این کار با ایجاد تعامل یکپارچه بین RAM فیزیکی و دستگاه‌های ذخیره‌سازی ثانویه، مانند هارد دیسک یا SSD انجام می‌شود.

**چگونه حافظه مجازی حافظه فیزیکی موجود را گسترش می‌دهد:**

حافظه مجازی را به عنوان پلی که بین RAM کامپیوتر و ذخیره‌سازی ثانویه (دیسک‌ها) ایجاد می‌شود، در نظر بگیرید. وقتی یک برنامه را اجرا می‌کنید، بخش‌هایی از آن در حافظه سریع‌تر (RAM) بارگذاری می‌شود. با این حال، ممکن است همه بخش‌های برنامه به‌طور همزمان استفاده نشوند.

حافظه مجازی از این وضعیت بهره می‌برد و بخش‌هایی از برنامه که به‌طور فعال استفاده نمی‌شوند را از RAM به ذخیره‌سازی ثانویه منتقل می‌کند و در نتیجه فضای بیشتری در RAM برای بخش‌های فعال ایجاد می‌کند. این فرایند برای کاربر و برنامه‌های در حال اجرا شفاف است. وقتی بخش‌های منتقل‌شده دوباره مورد نیاز قرار بگیرند، به RAM بازگردانده می‌شوند، در حالی که بخش‌های کمتر فعال ممکن است به ذخیره‌سازی ثانویه منتقل شوند.

این جابجایی پویا داده‌ها بین حافظه فیزیکی و حافظه مجازی توسط سیستم‌عامل مدیریت می‌شود. این امکان را به برنامه‌ها می‌دهد که حتی اگر بزرگ‌تر از RAM موجود باشند اجرا شوند، زیرا سیستم‌عامل به‌طور هوشمندانه تصمیم می‌گیرد چه داده‌هایی باید برای عملکرد بهینه در RAM باشد.

به‌طور خلاصه، حافظه مجازی به عنوان یک لایه مجازی‌سازی عمل می‌کند که حافظه فیزیکی موجود را با انتقال موقت بخش‌هایی از برنامه‌ها و داده‌ها بین RAM و ذخیره‌سازی ثانویه گسترش می‌دهد. این فرایند اطمینان می‌دهد که کامپیوتر می‌تواند وظایف بزرگ‌تر و برنامه‌های متعدد را به‌طور همزمان انجام دهد، همه این‌ها در حالی که عملکرد و پاسخگویی کارآمد حفظ می‌شود.

## [سیستم فایل](File%20System/readme.md)
در محاسبات، سیستم فایل یا فایل سیستم (اغلب به اختصار fs) یک روش و ساختار داده است که سیستم‌عامل از آن برای کنترل نحوه ذخیره و بازیابی داده‌ها استفاده می‌کند. بدون سیستم فایل، داده‌های قرار داده‌شده در یک رسانه ذخیره‌سازی به یک بدنه بزرگ داده تبدیل می‌شوند که هیچ راهی برای تشخیص مکان توقف یک قطعه داده و شروع قطعه دیگر یا محل قرارگیری هر قطعه داده هنگام بازیابی آن وجود نخواهد داشت. با جداسازی داده‌ها به قطعات و دادن یک نام به هر قطعه، داده‌ها به راحتی جدا و شناسایی می‌شوند. هر گروه داده به نام "فایل" نام‌گذاری می‌شود، مشابه با سیستم مدیریت داده‌های کاغذی. ساختار و قواعد منطقی مورد استفاده برای مدیریت گروه‌های داده و نام‌های آن‌ها به نام "سیستم فایل" شناخته می‌شود.

انواع مختلفی از سیستم‌های فایل وجود دارد که هرکدام دارای ساختار و منطق منحصر به فرد، ویژگی‌های سرعت، انعطاف‌پذیری، امنیت، اندازه و غیره هستند. برخی سیستم‌های فایل برای استفاده در برنامه‌های خاص طراحی شده‌اند. به عنوان مثال، سیستم فایل ISO 9660 به‌طور خاص برای دیسک‌های نوری طراحی شده است.

سیستم‌های فایل می‌توانند در انواع مختلف دستگاه‌های ذخیره‌سازی با استفاده از رسانه‌های مختلف استفاده شوند. از سال ۲۰۱۹، هارد دیسک‌ها به‌عنوان دستگاه‌های اصلی ذخیره‌سازی شناخته می‌شوند و پیش‌بینی می‌شود در آینده نزدیک نیز باقی بمانند. انواع دیگر رسانه‌هایی که استفاده می‌شوند شامل SSDها، نوارهای مغناطیسی و دیسک‌های نوری هستند. در برخی موارد، مانند tmpfs، حافظه اصلی کامپیوتر (RAM) برای استفاده کوتاه‌مدت یک سیستم فایل موقت ایجاد می‌کند.

برخی سیستم‌های فایل در دستگاه‌های ذخیره‌سازی محلی استفاده می‌شوند؛ برخی دیگر دسترسی به فایل را از طریق یک پروتکل شبکه (مانند NFS، SMB یا 9P) فراهم می‌کنند. برخی سیستم‌های فایل "مجازی" هستند، به این معنی که "فایل‌های" ارائه‌شده (که به آن‌ها فایل‌های مجازی می‌گویند) در صورت درخواست محاسبه می‌شوند (مانند procfs و sysfs) یا صرفاً نگاشتی به یک سیستم فایل دیگر هستند که به عنوان ذخیره‌گاه پشتیبان استفاده می‌شود. سیستم فایل دسترسی به محتوای فایل‌ها و متاداده‌های مربوط به آن‌ها را مدیریت می‌کند. این سیستم مسئول ترتیب‌دهی فضای ذخیره‌سازی است؛ اطمینان از قابلیت اطمینان، کارایی و تنظیم با توجه به رسانه فیزیکی ذخیره‌سازی از ملاحظات طراحی مهم است.

### نحوه عملکرد سیستم‌های فایل
سیستم فایل داده‌ها را ذخیره و سازمان‌دهی می‌کند و می‌توان آن را به عنوان نوعی شاخص برای همه داده‌های موجود در یک دستگاه ذخیره‌سازی تصور کرد. این دستگاه‌ها می‌توانند شامل هارد دیسک‌ها، درایوهای نوری و درایوهای فلش باشند.

سیستم‌های فایل کنوانسیون‌هایی را برای نام‌گذاری فایل‌ها مشخص می‌کنند، از جمله حداکثر تعداد کاراکترها در یک نام، کاراکترهایی که می‌توان استفاده کرد، و در برخی سیستم‌ها، طول پسوند نام فایل. در بسیاری از سیستم‌های فایل، نام فایل‌ها نسبت به حروف کوچک و بزرگ حساس نیستند.

علاوه بر خود فایل، سیستم‌های فایل اطلاعاتی مانند اندازه فایل و ویژگی‌های آن، محل و سلسله‌مراتب در دایرکتوری را در متاداده ذخیره می‌کنند. متاداده می‌تواند بلوک‌های آزاد فضای ذخیره‌سازی موجود روی دیسک و میزان فضای موجود را نیز شناسایی کند.

سیستم فایل همچنین شامل فرمتی برای مشخص کردن مسیر به یک فایل از طریق ساختار دایرکتوری‌ها است. یک فایل در یک دایرکتوری -- یا پوشه در سیستم‌عامل ویندوز -- یا زیر دایرکتوری در محل مورد نظر در ساختار درخت قرار می‌گیرد. سیستم‌عامل‌های کامپیوتر و موبایل دارای سیستم‌های فایلی هستند که فایل‌ها را در یک ساختار درخت سلسله‌مراتبی قرار می‌دهند.

پیش از ایجاد فایل‌ها و دایرکتوری‌ها روی رسانه ذخیره‌سازی، باید پارتیشن‌ها به‌وجود آیند. پارتیشن بخشی از هارد دیسک یا ذخیره‌سازی دیگر است که سیستم‌عامل آن را جداگانه مدیریت می‌کند. یک سیستم فایل در پارتیشن اولیه قرار دارد و برخی سیستم‌عامل‌ها اجازه چندین پارتیشن روی یک دیسک را می‌دهند. در این حالت، اگر یک سیستم فایل خراب شود، داده‌های پارتیشن دیگر محفوظ خواهند ماند.

### انواع سیستم‌های فایل
چندین نوع سیستم فایل وجود دارد که همگی دارای ساختارها و ویژگی‌های منطقی مختلفی هستند، مانند سرعت و اندازه. نوع سیستم فایل می‌تواند بر اساس سیستم‌عامل و نیازهای آن متفاوت باشد. ویندوز، مک او اس ایکس و لینوکس سه سیستم‌عامل رایانه‌ای رایج هستند. سیستم‌عامل‌های موبایل شامل Apple iOS و Google Android هستند.

سیستم‌های فایل اصلی عبارتند از:

- **جدول تخصیص فایل (FAT)**: توسط سیستم‌عامل ویندوز پشتیبانی می‌شود. FAT ساده و قابل اطمینان در نظر گرفته می‌شود و بر اساس سیستم‌های فایل قدیمی طراحی شده است. FAT در سال ۱۹۷۷ برای فلاپی دیسک‌ها طراحی شد اما بعداً برای هارد دیسک‌ها نیز تطبیق یافت. با اینکه FAT کارآمد و با اکثر سیستم‌عامل‌های فعلی سازگار است، نمی‌تواند با عملکرد و مقیاس‌پذیری سیستم‌های فایل مدرن‌تر رقابت کند.

- **سیستم فایل جهانی (GFS)**: یک سیستم فایل برای سیستم‌عامل لینوکس است و یک سیستم فایل دیسک اشتراکی است. GFS دسترسی مستقیم به ذخیره‌سازی بلوک اشتراکی را فراهم می‌کند و می‌تواند به عنوان یک سیستم فایل محلی استفاده شود.

- **GFS2**: نسخه به‌روزرسانی شده‌ای با ویژگی‌هایی است که در GFS اصلی وجود نداشت، مانند سیستم متاداده به‌روزرسانی شده. هر دو سیستم فایل GFS و GFS2 تحت شرایط مجوز عمومی عمومی گنو به‌عنوان نرم‌افزار رایگان در دسترس هستند.

- **سیستم فایل سلسله‌مراتبی (HFS)**: برای استفاده با سیستم‌عامل‌های مک توسعه یافته است. HFS همچنین می‌تواند به عنوان Mac OS Standard نامیده شود و توسط Mac OS Extended جایگزین شد. ابتدا در سال ۱۹۸۵ برای فلاپی و هارد دیسک‌ها معرفی شد و سیستم فایل اصلی مکینتاش را جایگزین کرد. همچنین می‌تواند روی CD-ROMها استفاده شود.

- **سیستم فایل NT**: که به عنوان سیستم فایل فناوری جدید (NTFS) نیز شناخته می‌شود، سیستم فایل پیش‌فرض محصولات ویندوز از سیستم‌عامل Windows NT 3.1 به بعد است. بهبودهای نسبت به سیستم فایل FAT شامل پشتیبانی بهتر از متاداده، عملکرد و استفاده از فضای دیسک است. NTFS همچنین در سیستم‌عامل لینوکس از طریق یک درایور NTFS منبع باز رایگان پشتیبانی می‌شود. سیستم‌عامل‌های مک پشتیبانی فقط خواندنی از NTFS دارند.

- **فرمت دیسک جهانی (UDF)**: یک سیستم فایل بی‌طرف فروشنده برای رسانه‌های نوری و DVDها است. UDF جایگزین سیستم فایل ISO 9660 شده و سیستم فایل رسمی برای ویدیو و صدای DVD است که توسط انجمن DVD انتخاب شده است.

